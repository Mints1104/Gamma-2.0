<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Float,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Int,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import android.view.View&#10;import android.view.WindowManager&#10;&#10;class DragTouchListener(&#10;    private val params: WindowManager.LayoutParams,&#10;    private val windowManager: WindowManager,&#10;    private val rootView: View&#10;) : View.OnTouchListener {&#10;    private val rootView: View&#10;    private var initialY = 0&#10;    private var downRawX = 0f&#10;    private var downRawY = 0f&#10;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;                val newY = initialY + deltaY&#10;&#10;                // 2) get screen &amp; overlay dimensions&#10;                val dm = rootView.resources.displayMetrics&#10;                val maxX = dm.widthPixels  - rootView.width&#10;                val maxY = dm.heightPixels - rootView.height&#10;&#10;                // 3) clamp to [0..max]&#10;                params.x = newX.coerceIn(0, maxX)&#10;                return true&#10;            }&#10;        }&#10;                Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#10;                // 1) calculate desired new position&#10;        return false&#10;    }&#10;                val newX = initialX + deltaX&#10;                val newY = initialY + deltaY&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#13;&#10;&#13;&#10;import android.os.Handler&#13;&#10;import android.os.Looper&#13;&#10;import android.util.Log&#13;&#10;import android.view.MotionEvent&#13;&#10;import android.view.View&#13;&#10;import android.view.WindowManager&#13;&#10;&#13;&#10;class DragTouchListener(&#13;&#10;    private val params: WindowManager.LayoutParams,&#13;&#10;    private val windowManager: WindowManager,&#13;&#10;    private val rootView: View,&#13;&#10;    private val onLongPress: (() -&gt; Unit)? = null&#13;&#10;) : View.OnTouchListener {&#13;&#10;&#13;&#10;    private var initialX = 0&#13;&#10;    private var initialY = 0&#13;&#10;    private var downRawX = 0f&#13;&#10;    private var downRawY = 0f&#13;&#10;    private var hasMoved = false&#13;&#10;&#13;&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#13;&#10;    private val longPressRunnable = Runnable {&#13;&#10;        if (!hasMoved) {&#13;&#10;            Log.d(&quot;DragTouch&quot;, &quot;Long press detected!&quot;)&#13;&#10;            onLongPress?.invoke()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        private const val LONG_PRESS_TIMEOUT = 500L // 500ms for long press&#13;&#10;        private const val MOVE_THRESHOLD = 10 // pixels&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#13;&#10;        when (event.action) {&#13;&#10;            MotionEvent.ACTION_DOWN -&gt; {&#13;&#10;                Log.d(&quot;DragTouch&quot;, &quot;DOWN at (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                initialX = params.x&#13;&#10;                initialY = params.y&#13;&#10;                downRawX = event.rawX&#13;&#10;                downRawY = event.rawY&#13;&#10;                hasMoved = false&#13;&#10;&#13;&#10;                // Start long press detection&#13;&#10;                longPressHandler.postDelayed(longPressRunnable, LONG_PRESS_TIMEOUT)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_MOVE -&gt; {&#13;&#10;                val deltaX = (event.rawX - downRawX).toInt()&#13;&#10;                val deltaY = (event.rawY - downRawY).toInt()&#13;&#10;&#13;&#10;                // Check if user has moved beyond threshold&#13;&#10;                if (Math.abs(deltaX) &gt; MOVE_THRESHOLD || Math.abs(deltaY) &gt; MOVE_THRESHOLD) {&#13;&#10;                    hasMoved = true&#13;&#10;                    longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;&#13;&#10;                    Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                    // Calculate desired new position&#13;&#10;                    val newX = initialX + deltaX&#13;&#10;                    val newY = initialY + deltaY&#13;&#10;&#13;&#10;                    // Get screen &amp; overlay dimensions&#13;&#10;                    val dm = rootView.resources.displayMetrics&#13;&#10;                    val maxX = dm.widthPixels - rootView.width&#13;&#10;                    val maxY = dm.heightPixels - rootView.height&#13;&#10;&#13;&#10;                    // Clamp to [0..max]&#13;&#10;                    params.x = newX.coerceIn(0, maxX)&#13;&#10;                    params.y = newY.coerceIn(0, maxY)&#13;&#10;&#13;&#10;                    // Apply update&#13;&#10;                    windowManager.updateViewLayout(rootView, params)&#13;&#10;                }&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#13;&#10;                // Cancel long press if finger is lifted&#13;&#10;                longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return false&#13;&#10;    }&#13;&#10;&#13;&#10;    /** Expose current overlay X (left) */&#13;&#10;    fun getCurrentParamsX(): Int = params.x&#13;&#10;&#13;&#10;    /** Expose current overlay Y (top) */&#13;&#10;    fun getCurrentParamsY(): Int = params.y&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;interface ItemTouchHelperAdapter {&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean&#10;}&#10;&#10;class ItemTouchHelperCallback(&#10;    private val adapter: ItemTouchHelperAdapter&#10;) : ItemTouchHelper.Callback() {&#10;&#10;    override fun isLongPressDragEnabled(): Boolean = false&#10;&#10;    override fun isItemViewSwipeEnabled(): Boolean = false&#10;&#10;    override fun getMovementFlags(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder&#10;    ): Int {&#10;        val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN&#10;        return makeMovementFlags(dragFlags, 0)&#10;    }&#10;&#10;    override fun onMove(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder,&#10;        target: RecyclerView.ViewHolder&#10;    ): Boolean {&#10;        return adapter.onItemMove(viewHolder.adapterPosition, target.adapterPosition)&#10;    }&#10;&#10;    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;        // Not implemented&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // All items can now be dragged&#10;            dragIcon.alpha = 1.0f&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FavoritesFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FavoritesFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.ClipData&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.view.*&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.coordinatorlayout.widget.CoordinatorLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.recyclerviews.FavoritesAdapter&#10;import java.util.Collections&#10;import androidx.core.content.edit&#10;&#10;private const val PREFS_NAME = &quot;FavoritesPrefs&quot;&#10;private const val SORT_ORDER_KEY = &quot;sort_order&quot;&#10;private const val SORT_ORDER_NAME = &quot;name&quot;&#10;private const val SORT_ORDER_DEFAULT = &quot;default&quot;&#10;&#10;&#10;class FavoritesFragment : Fragment(), FavoriteDialogFragment.FavoriteDialogListener {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: FavoritesAdapter&#10;    private lateinit var addFavoriteFab: View&#10;    private var favoritesList = mutableListOf&lt;FavoriteLocation&gt;()&#10;    private val gson = Gson()&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val FAVORITES_SORTED = &quot;favorites_sorted&quot;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val view = inflater.inflate(R.layout.fragment_favorites, container, false)&#10;        recyclerView = view.findViewById(R.id.favoritesRecyclerView)&#10;        addFavoriteFab = view.findViewById(R.id.addFavoriteFab)&#10;        return view&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        adapter = FavoritesAdapter(&#10;            onDeleteFavorite = { favorite -&gt; deleteFavorite(favorite) },&#10;            onEditFavorite = { favorite, position -&gt; showEditFavoriteDialog(favorite, position) },&#10;            onCopyFavorite = { favorite -&gt; copyFavorite(favorite) },&#10;            onTeleportFavorite = { favorite -&gt; teleportToFavorite(favorite) }&#10;        )&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        loadFavorites()&#10;&#10;&#10;&#10;        addFavoriteFab.setOnClickListener {&#10;            showAddFavoriteDialog()&#10;        }&#10;        val itemTouchHelper = ItemTouchHelper(itemTouchHelperCallback)&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;    }&#10;&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.favorites_menu, menu)&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.menu_import_favorites -&gt; {&#10;                showImportFavoritesDialog()&#10;                true&#10;            }&#10;            R.id.action_sortByName -&gt; {&#10;                saveSortOrderPreference(SORT_ORDER_NAME)&#10;                sortFavsByName()&#10;                true&#10;            }&#10;&#10;            R.id.action_sortByDefault -&gt; {&#10;                sortFavsByDefault()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: String) {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { putString(SORT_ORDER_KEY, sortOrder) }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val sortedList = favoritesList.toMutableList().apply {&#10;            sortBy { it.name }&#10;        }&#10;        adapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        loadFavorites()&#10;    }&#10;&#10;&#10;&#10;    private fun loadSortOrderPreference(): String {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return prefs.getString(SORT_ORDER_KEY, SORT_ORDER_DEFAULT) ?: SORT_ORDER_DEFAULT&#10;    }&#10;&#10;    private fun applySavedSortOrder() {&#10;        when (loadSortOrderPreference()) {&#10;            SORT_ORDER_NAME -&gt; sortFavsByName()&#10;            SORT_ORDER_DEFAULT -&gt; sortFavsByDefault()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing favorites via JSON.&#10;     */&#10;    private fun showImportFavoritesDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_favorites, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importFavorites(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports favorites from the provided JSON string.&#10;     */&#10;    private fun importFavorites(jsonString: String) {&#10;        try {&#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            // Merge imported favorites with the current list, avoiding duplicates.&#10;            for (fav in importedFavorites) {&#10;                if (!favoritesList.any { it.lat == fav.lat &amp;&amp; it.lng == fav.lng &amp;&amp; it.name == fav.name }) {&#10;                    favoritesList.add(fav)&#10;                }&#10;            }&#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            Toast.makeText(requireContext(), &quot;Favorites imported&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import favorites&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    private fun loadFavorites() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        val json = prefs.getString(KEY_FAVORITES, &quot;[]&quot;) ?: &quot;[]&quot;&#10;        val type = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val listType = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val loadedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(json, listType)&#10;&#10;        val orderJson = prefs.getString(&quot;favorites_order&quot;, &quot;[]&quot;)&#10;        val orderType = TypeToken&#10;            .getParameterized(List::class.java, String::class.java)&#10;            .type&#10;        val originalOrder: List&lt;String&gt; = gson.fromJson(orderJson, orderType)&#10;&#10;        // Reorder the loadedFavorites to match the original order&#10;        favoritesList = if (originalOrder.isNotEmpty()) {&#10;            loadedFavorites.sortedBy { originalOrder.indexOf(it.name) }.toMutableList()&#10;        } else {&#10;            loadedFavorites.toMutableList()&#10;        }&#10;&#10;        adapter.submitList(favoritesList.toList())&#10;    }&#10;&#10;&#10;    private fun saveFavorites() {&#10;        val ctx = context ?: return&#10;        val prefs = ctx&#10;            .getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val editor = prefs.edit()&#10;        editor.putString(KEY_FAVORITES, gson.toJson(favoritesList))&#10;        editor.putString(&quot;favorites_order&quot;, gson.toJson(favoritesList.map { it.name }))&#10;        editor.apply()&#10;    }&#10;&#10;&#10;&#10;    private fun saveSortingOrder() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_SORTED, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(KEY_FAVORITES, gson.toJson(favoritesList)).apply()&#10;&#10;    }&#10;&#10;    private fun deleteFavorite(favorite: FavoriteLocation) {&#10;        val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;        val deletedIndex = favoritesList.indexOf(favorite).takeIf { it != -1 } ?: return&#10;        favoritesList.removeAt(deletedIndex)&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;        Snackbar.make(rootView, &quot;Deleted: ${favorite.name}&quot;, Snackbar.LENGTH_LONG)&#10;            .setAction(&quot;UNDO&quot;) {&#10;                favoritesList.add(deletedIndex, favorite)&#10;                adapter.submitList(favoritesList.toList())&#10;                saveFavorites()&#10;            }&#10;            .show()&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    private fun copyFavorite(favorite: FavoriteLocation) {&#10;        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager&#10;        val clip = ClipData.newPlainText(&quot;Favorite Coordinates&quot;, &quot;${favorite.lat}, ${favorite.lng}&quot;)&#10;        clipboard.setPrimaryClip(clip)&#10;        Toast.makeText(requireContext(), &quot;Coordinates copied to clipboard&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;&#10;    /**&#10;     * Teleports to the favorite location based on the user's teleport method preference.&#10;     * If &quot;ipogo&quot; is selected, it opens an ipogo URL; if &quot;joystick&quot; is selected, it sends an intent.&#10;     */&#10;    private fun teleportToFavorite(favorite: FavoriteLocation) {&#10;        val context = requireContext()&#10;        val teleportPrefs = context.getSharedPreferences(&quot;teleport_prefs&quot;, Context.MODE_PRIVATE)&#10;        val method = teleportPrefs.getString(&quot;teleport_method&quot;, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;&#10;        if (method == &quot;ipogo&quot;) {&#10;            val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;            startActivity(intent)&#10;            return&#10;        }&#10;&#10;        val baseIntent = Intent().apply {&#10;            action = &quot;theappninjas.gpsjoystick.TELEPORT&quot;&#10;            putExtra(&quot;lat&quot;, favorite.lat.toFloat())&#10;            putExtra(&quot;lng&quot;, favorite.lng.toFloat())&#10;        }&#10;        val knownComponents = listOf(&#10;            ComponentName(&#10;                &quot;com.theappninjas.fakegpsjoystick&quot;,&#10;                &quot;com.theappninjas.fakegpsjoystick.service.OverlayService&quot;&#10;            ),&#10;            ComponentName(&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw&quot;,&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw.service.OverlayService&quot;&#10;            )&#10;        )&#10;&#10;        var serviceStarted = false&#10;        for (component in knownComponents) {&#10;            val intent = Intent(baseIntent).apply {&#10;                this.component = component&#10;            }&#10;            try {&#10;                val compName = context.startService(intent)&#10;                if (compName != null) {&#10;                    serviceStarted = true&#10;                    break&#10;                }&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            val dynamicIntent = Intent(baseIntent).apply { component = null }&#10;            val pm = context.packageManager&#10;            val services = pm.queryIntentServices(dynamicIntent, 0)&#10;            if (services.isNotEmpty()) {&#10;                val serviceInfo = services.first().serviceInfo&#10;                dynamicIntent.component = ComponentName(serviceInfo.packageName, serviceInfo.name)&#10;                try {&#10;                    val compName = context.startService(dynamicIntent)&#10;                    serviceStarted = (compName != null)&#10;                } catch (e: Exception) {&#10;                }&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            Toast.makeText(context, &quot;Error: Joystick not found&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    /**&#10;     * Opens the dialog to add a new favorite.&#10;     */&#10;    private fun showAddFavoriteDialog() {&#10;        val dialog = FavoriteDialogFragment.newInstance(null, -1)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;    /**&#10;     * Opens the dialog to edit an existing favorite.&#10;     */&#10;    private fun showEditFavoriteDialog(favorite: FavoriteLocation, position: Int) {&#10;        val dialog = FavoriteDialogFragment.newInstance(favorite, position)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;&#10;    override fun onFavoriteSaved(favorite: FavoriteLocation, position: Int) {&#10;        if (position == -1) {&#10;            favoritesList.add(favorite)&#10;            Toast.makeText(requireContext(), &quot;Favorite added&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            favoritesList[position] = favorite&#10;            Toast.makeText(requireContext(), &quot;Favorite updated&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;    }&#10;&#10;&#10;    private val itemTouchHelperCallback = object : ItemTouchHelper.SimpleCallback(&#10;        ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0&#10;    ) {&#10;        override fun onMove(&#10;            recyclerView: RecyclerView,&#10;            viewHolder: RecyclerView.ViewHolder,&#10;            target: RecyclerView.ViewHolder&#10;        ): Boolean {&#10;            // Use adapterPosition everywhere&#10;            val from = viewHolder.adapterPosition&#10;            val to   = target.adapterPosition&#10;            if (from == RecyclerView.NO_POSITION || to == RecyclerView.NO_POSITION) return false&#10;&#10;            // Make a mutable copy, swap, and resubmit&#10;            // Update BOTH the favorites list AND the adapter&#10;            Collections.swap(favoritesList, from, to)&#10;            adapter.submitList(favoritesList.toList())&#10;            return true&#10;        }&#10;&#10;&#10;        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;            // No swipe action.&#10;        }&#10;&#10;        override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {&#10;            super.clearView(recyclerView, viewHolder)&#10;            saveFavorites()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.ClipData&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.view.*&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.coordinatorlayout.widget.CoordinatorLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.recyclerviews.FavoritesAdapter&#10;import java.util.Collections&#10;import androidx.core.content.edit&#10;&#10;private const val PREFS_NAME = &quot;FavoritesPrefs&quot;&#10;private const val SORT_ORDER_KEY = &quot;sort_order&quot;&#10;private const val SORT_ORDER_NAME = &quot;name&quot;&#10;private const val SORT_ORDER_DEFAULT = &quot;default&quot;&#10;&#10;&#10;class FavoritesFragment : Fragment(), FavoriteDialogFragment.FavoriteDialogListener {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: FavoritesAdapter&#10;    private lateinit var addFavoriteFab: View&#10;    private var favoritesList = mutableListOf&lt;FavoriteLocation&gt;()&#10;    private val gson = Gson()&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val FAVORITES_SORTED = &quot;favorites_sorted&quot;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val view = inflater.inflate(R.layout.fragment_favorites, container, false)&#10;        recyclerView = view.findViewById(R.id.favoritesRecyclerView)&#10;        addFavoriteFab = view.findViewById(R.id.addFavoriteFab)&#10;        return view&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        adapter = FavoritesAdapter(&#10;            onDeleteFavorite = { favorite -&gt; deleteFavorite(favorite) },&#10;            onEditFavorite = { favorite, position -&gt; showEditFavoriteDialog(favorite, position) },&#10;            onCopyFavorite = { favorite -&gt; copyFavorite(favorite) },&#10;            onTeleportFavorite = { favorite -&gt; teleportToFavorite(favorite) }&#10;        )&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        loadFavorites()&#10;&#10;&#10;&#10;        addFavoriteFab.setOnClickListener {&#10;            showAddFavoriteDialog()&#10;        }&#10;        val itemTouchHelper = ItemTouchHelper(itemTouchHelperCallback)&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;    }&#10;&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.favorites_menu, menu)&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.menu_import_favorites -&gt; {&#10;                showImportFavoritesDialog()&#10;                true&#10;            }&#10;            R.id.menu_import_hotspots -&gt; {&#10;                showImportHotspotsDialog()&#10;                true&#10;            }&#10;            R.id.action_sortByName -&gt; {&#10;                saveSortOrderPreference(SORT_ORDER_NAME)&#10;                sortFavsByName()&#10;                true&#10;            }&#10;&#10;            R.id.action_sortByDefault -&gt; {&#10;                sortFavsByDefault()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: String) {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { putString(SORT_ORDER_KEY, sortOrder) }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val sortedList = favoritesList.toMutableList().apply {&#10;            sortBy { it.name }&#10;        }&#10;        adapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        loadFavorites()&#10;    }&#10;&#10;&#10;&#10;    private fun loadSortOrderPreference(): String {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return prefs.getString(SORT_ORDER_KEY, SORT_ORDER_DEFAULT) ?: SORT_ORDER_DEFAULT&#10;    }&#10;&#10;    private fun applySavedSortOrder() {&#10;        when (loadSortOrderPreference()) {&#10;            SORT_ORDER_NAME -&gt; sortFavsByName()&#10;            SORT_ORDER_DEFAULT -&gt; sortFavsByDefault()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing favorites via JSON.&#10;     */&#10;    private fun showImportFavoritesDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_favorites, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importFavorites(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Displays a confirmation dialog for importing hotspots.&#10;     */&#10;    private fun showImportHotspotsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_confirm_import_hotspots, null)&#10;&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelConfirmButton)&#10;        val confirmButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmImportButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        confirmButton.setOnClickListener {&#10;            importHotspots()&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports hotspots from the hotspots.txt file in the res folder.&#10;     */&#10;    private fun importHotspots() {&#10;        try {&#10;            val inputStream = resources.openRawResource(R.raw.hotspots)&#10;            val jsonString = inputStream.bufferedReader().use { it.readText() }&#10;            &#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedHotspots: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            &#10;            // Store the current list before making changes&#10;            val previousList = favoritesList.toList()&#10;            val addedLocations = mutableListOf&lt;FavoriteLocation&gt;()&#10;            &#10;            // Merge imported hotspots with the current list, avoiding duplicates&#10;            for (hotspot in importedHotspots) {&#10;                if (!favoritesList.any { it.lat == hotspot.lat &amp;&amp; it.lng == hotspot.lng &amp;&amp; it.name == hotspot.name }) {&#10;                    favoritesList.add(hotspot)&#10;                    addedLocations.add(hotspot)&#10;                }&#10;            }&#10;            &#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            &#10;            // Show snackbar with undo option&#10;            val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;            val message = if (addedLocations.isNotEmpty()) {&#10;                &quot;Imported ${addedLocations.size} hotspot(s)&quot;&#10;            } else {&#10;                &quot;No new hotspots to import&quot;&#10;            }&#10;            &#10;            Snackbar.make(rootView, message, Snackbar.LENGTH_LONG)&#10;                .setAction(&quot;UNDO&quot;) {&#10;                    // Restore the previous list&#10;                    favoritesList.clear()&#10;                    favoritesList.addAll(previousList)&#10;                    adapter.submitList(favoritesList.toList())&#10;                    saveFavorites()&#10;                    Toast.makeText(requireContext(), &quot;Import undone&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                .show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import hotspots: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Imports favorites from the provided JSON string.&#10;     */&#10;    private fun importFavorites(jsonString: String) {&#10;        try {&#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            // Merge imported favorites with the current list, avoiding duplicates.&#10;            for (fav in importedFavorites) {&#10;                if (!favoritesList.any { it.lat == fav.lat &amp;&amp; it.lng == fav.lng &amp;&amp; it.name == fav.name }) {&#10;                    favoritesList.add(fav)&#10;                }&#10;            }&#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            Toast.makeText(requireContext(), &quot;Favorites imported&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import favorites&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    private fun loadFavorites() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        val json = prefs.getString(KEY_FAVORITES, &quot;[]&quot;) ?: &quot;[]&quot;&#10;        val type = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val listType = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val loadedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(json, listType)&#10;&#10;        val orderJson = prefs.getString(&quot;favorites_order&quot;, &quot;[]&quot;)&#10;        val orderType = TypeToken&#10;            .getParameterized(List::class.java, String::class.java)&#10;            .type&#10;        val originalOrder: List&lt;String&gt; = gson.fromJson(orderJson, orderType)&#10;&#10;        // Reorder the loadedFavorites to match the original order&#10;        favoritesList = if (originalOrder.isNotEmpty()) {&#10;            loadedFavorites.sortedBy { originalOrder.indexOf(it.name) }.toMutableList()&#10;        } else {&#10;            loadedFavorites.toMutableList()&#10;        }&#10;&#10;        adapter.submitList(favoritesList.toList())&#10;    }&#10;&#10;&#10;    private fun saveFavorites() {&#10;        val ctx = context ?: return&#10;        val prefs = ctx&#10;            .getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val editor = prefs.edit()&#10;        editor.putString(KEY_FAVORITES, gson.toJson(favoritesList))&#10;        editor.putString(&quot;favorites_order&quot;, gson.toJson(favoritesList.map { it.name }))&#10;        editor.apply()&#10;    }&#10;&#10;&#10;&#10;    private fun saveSortingOrder() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_SORTED, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(KEY_FAVORITES, gson.toJson(favoritesList)).apply()&#10;&#10;    }&#10;&#10;    private fun deleteFavorite(favorite: FavoriteLocation) {&#10;        val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;        val deletedIndex = favoritesList.indexOf(favorite).takeIf { it != -1 } ?: return&#10;        favoritesList.removeAt(deletedIndex)&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;        Snackbar.make(rootView, &quot;Deleted: ${favorite.name}&quot;, Snackbar.LENGTH_LONG)&#10;            .setAction(&quot;UNDO&quot;) {&#10;                favoritesList.add(deletedIndex, favorite)&#10;                adapter.submitList(favoritesList.toList())&#10;                saveFavorites()&#10;            }&#10;            .show()&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    private fun copyFavorite(favorite: FavoriteLocation) {&#10;        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager&#10;        val clip = ClipData.newPlainText(&quot;Favorite Coordinates&quot;, &quot;${favorite.lat}, ${favorite.lng}&quot;)&#10;        clipboard.setPrimaryClip(clip)&#10;        Toast.makeText(requireContext(), &quot;Coordinates copied to clipboard&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;&#10;    /**&#10;     * Teleports to the favorite location based on the user's teleport method preference.&#10;     * If &quot;ipogo&quot; is selected, it opens an ipogo URL; if &quot;joystick&quot; is selected, it sends an intent.&#10;     */&#10;    private fun teleportToFavorite(favorite: FavoriteLocation) {&#10;        val context = requireContext()&#10;        val teleportPrefs = context.getSharedPreferences(&quot;teleport_prefs&quot;, Context.MODE_PRIVATE)&#10;        val method = teleportPrefs.getString(&quot;teleport_method&quot;, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;&#10;        if (method == &quot;ipogo&quot;) {&#10;            val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;            startActivity(intent)&#10;            return&#10;        }&#10;&#10;        val baseIntent = Intent().apply {&#10;            action = &quot;theappninjas.gpsjoystick.TELEPORT&quot;&#10;            putExtra(&quot;lat&quot;, favorite.lat.toFloat())&#10;            putExtra(&quot;lng&quot;, favorite.lng.toFloat())&#10;        }&#10;        val knownComponents = listOf(&#10;            ComponentName(&#10;                &quot;com.theappninjas.fakegpsjoystick&quot;,&#10;                &quot;com.theappninjas.fakegpsjoystick.service.OverlayService&quot;&#10;            ),&#10;            ComponentName(&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw&quot;,&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw.service.OverlayService&quot;&#10;            )&#10;        )&#10;&#10;        var serviceStarted = false&#10;        for (component in knownComponents) {&#10;            val intent = Intent(baseIntent).apply {&#10;                this.component = component&#10;            }&#10;            try {&#10;                val compName = context.startService(intent)&#10;                if (compName != null) {&#10;                    serviceStarted = true&#10;                    break&#10;                }&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            val dynamicIntent = Intent(baseIntent).apply { component = null }&#10;            val pm = context.packageManager&#10;            val services = pm.queryIntentServices(dynamicIntent, 0)&#10;            if (services.isNotEmpty()) {&#10;                val serviceInfo = services.first().serviceInfo&#10;                dynamicIntent.component = ComponentName(serviceInfo.packageName, serviceInfo.name)&#10;                try {&#10;                    val compName = context.startService(dynamicIntent)&#10;                    serviceStarted = (compName != null)&#10;                } catch (e: Exception) {&#10;                }&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            Toast.makeText(context, &quot;Error: Joystick not found&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    /**&#10;     * Opens the dialog to add a new favorite.&#10;     */&#10;    private fun showAddFavoriteDialog() {&#10;        val dialog = FavoriteDialogFragment.newInstance(null, -1)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;    /**&#10;     * Opens the dialog to edit an existing favorite.&#10;     */&#10;    private fun showEditFavoriteDialog(favorite: FavoriteLocation, position: Int) {&#10;        val dialog = FavoriteDialogFragment.newInstance(favorite, position)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;&#10;    override fun onFavoriteSaved(favorite: FavoriteLocation, position: Int) {&#10;        if (position == -1) {&#10;            favoritesList.add(favorite)&#10;            Toast.makeText(requireContext(), &quot;Favorite added&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            favoritesList[position] = favorite&#10;            Toast.makeText(requireContext(), &quot;Favorite updated&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;    }&#10;&#10;&#10;    private val itemTouchHelperCallback = object : ItemTouchHelper.SimpleCallback(&#10;        ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0&#10;    ) {&#10;        override fun onMove(&#10;            recyclerView: RecyclerView,&#10;            viewHolder: RecyclerView.ViewHolder,&#10;            target: RecyclerView.ViewHolder&#10;        ): Boolean {&#10;            // Use adapterPosition everywhere&#10;            val from = viewHolder.adapterPosition&#10;            val to   = target.adapterPosition&#10;            if (from == RecyclerView.NO_POSITION || to == RecyclerView.NO_POSITION) return false&#10;&#10;            // Make a mutable copy, swap, and resubmit&#10;            // Update BOTH the favorites list AND the adapter&#10;            Collections.swap(favoritesList, from, to)&#10;            adapter.submitList(favoritesList.toList())&#10;            return true&#10;        }&#10;&#10;&#10;        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;            // No swipe action.&#10;        }&#10;&#10;        override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {&#10;            super.clearView(recyclerView, viewHolder)&#10;            saveFavorites()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;&#10;        saveRocketItem?.isVisible = (currentFilterType == &quot;Rocket&quot;)&#10;        saveQuestItem?.isVisible  = (currentFilterType == &quot;Quest&quot;)&#10;    }&#10;&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_save_rocket -&gt; {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;Pokmon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;Pokmon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;Pokmon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;Pokmon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;Pokmon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;Pokmon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if its one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;Pokmon Encounter&quot;, &quot;Mega Energy&quot;, &quot;Pokmon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;Pokmon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;Pokmon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;Pokmon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire Spinda block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main Spinda checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main Spinda checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specificform checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;&quot; else &quot;&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;        val refreshFiltersItem = menu.findItem(R.id.action_refresh_filters)&#10;&#10;        saveRocketItem?.isVisible = (currentFilterType == &quot;Rocket&quot;)&#10;        saveQuestItem?.isVisible  = (currentFilterType == &quot;Quest&quot;)&#10;        refreshFiltersItem?.isVisible = (currentFilterType == &quot;Quest&quot;)&#10;    }&#10;&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_save_rocket -&gt; {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;Pokmon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;Pokmon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;Pokmon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;Pokmon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;Pokmon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;Pokmon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if its one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;Pokmon Encounter&quot;, &quot;Mega Energy&quot;, &quot;Pokmon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;Pokmon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;Pokmon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;Pokmon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire Spinda block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main Spinda checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main Spinda checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specificform checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;&quot; else &quot;&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.RaidsAdapter&#10;import com.mints.projectgammatwo.viewmodels.RaidsViewModel&#10;import androidx.core.net.toUri&#10;&#10;class RaidsFragment : Fragment() {&#10;&#10;    private val viewModel: RaidsViewModel by viewModels()&#10;    private lateinit var adapter: RaidsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_raids, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.raidsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = RaidsAdapter { raid -&gt;&#10;            viewModel.deleteRaid(raid)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchRaids()&#10;        }&#10;&#10;        viewModel.raidsLiveData.observe(viewLifecycleOwner) { raids -&gt;&#10;            adapter.submitList(raids)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if (raids.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No raids available. Please check your data sources in Settings.&quot;&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            if (errorMessage.isNotEmpty()) {&#10;                Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                swipeRefresh.isRefreshing = false&#10;            }&#10;        }&#10;&#10;        val raidsCountTextView = view.findViewById&lt;TextView&gt;(R.id.raidsCountText)&#10;        viewModel.raidsCountLiveData.observe(viewLifecycleOwner) { count -&gt;&#10;            raidsCountTextView.text = &quot;Total Raids: $count&quot;&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchRaids()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        })&#10;&#10;        adapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        })&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.scrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        val layoutManager = recyclerView.layoutManager as? LinearLayoutManager ?: return&#10;&#10;        if (adapter.itemCount == 0) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;No items, hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;&#10;        val firstVisibleItem = layoutManager.findFirstVisibleItemPosition()&#10;        Log.d(&#10;            &quot;FAB_DEBUG&quot;,&#10;            &quot;First visible item: $firstVisibleItem, Total items: ${adapter.itemCount}&quot;&#10;        )&#10;&#10;        if (firstVisibleItem != RecyclerView.NO_POSITION &amp;&amp; firstVisibleItem &gt; 2) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Showing FAB&quot;)&#10;            scrollToTopFab.show()&#10;        } else {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;        }&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;raids&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;QuestsViewModel&quot;, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(tag, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                val responses = deferredList.map { it.await() }&#10;&#10;                // Filter successful responses&#10;                val successfulResponses = responses.mapNotNull { (source, result) -&gt;&#10;                    result.getOrNull()?.let { response -&gt;&#10;                        Pair(source, response)&#10;                    }&#10;                }&#10;&#10;                // If no successful responses, handle the error state&#10;                if (successfulResponses.isEmpty()) {&#10;                    Log.w(tag, &quot;No successful API responses received&quot;)&#10;                    _raidsLiveData.postValue(emptyList())&#10;                    _raidsCountLiveData.postValue(0)&#10;                    _filterSizeLiveData.postValue(0)&#10;                    _error.postValue(&quot;Unable to fetch raids. Please check your connection.&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Process successful responses&#10;                val combinedRaids = successfulResponses.flatMap { (source, response) -&gt;&#10;                    response.body()?.raids?.map { raid -&gt;&#10;                        raid.copy(source = source)&#10;                    } ?: emptyList()&#10;                }.toMutableList()&#10;&#10;                // Filter raids (you might want to add filtering preferences similar to HomeViewModel)&#10;                val filteredRaids = combinedRaids&#10;                    .filter { raid -&gt;&#10;                        // Add any filtering logic here&#10;                        // For now, we'll include all raids&#10;                        true&#10;                    }&#10;                    .sortedBy { it.raid_start }&#10;                    .reversed()&#10;&#10;                // Update LiveData&#10;                _raidsLiveData.postValue(filteredRaids)&#10;                _raidsCountLiveData.postValue(filteredRaids.size)&#10;                _filterSizeLiveData.postValue(filteredRaids.size)&#10;&#10;                Log.d(tag, &quot;Successfully fetched raids from ${successfulResponses.size} sources. Total raids: ${filteredRaids.size}&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                e(tag, &quot;Error in fetchRaids&quot;, e)&#10;                _raidsLiveData.postValue(emptyList())&#10;                _raidsCountLiveData.postValue(0)&#10;                _filterSizeLiveData.postValue(0)&#10;                _error.postValue(&quot;An unexpected error occurred&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getRaids(): List&lt;Raid&gt;? {&#10;        return _raidsLiveData.value&#10;    }&#10;&#10;    // Method to handle raid deletion (if needed)&#10;    fun deleteRaid(raid: Raid) {&#10;        _raidsLiveData.value = _raidsLiveData.value?.toMutableList()?.apply { remove(raid) }&#10;        _raidsCountLiveData.value = _raidsLiveData.value?.size ?: 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:id=&quot;@+id/appBarLayout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/CustomToolbarTheme&quot;&#10;            app:popupTheme=&quot;@style/OverflowMenuTheme&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.fragment.app.FragmentContainerView&#10;        android:id=&quot;@+id/nav_host_fragment&quot;&#10;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&#10;        app:layout_constraintRight_toRightOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/appBarLayout&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/bottomNav&quot;&#10;        app:defaultNavHost=&quot;true&quot;&#10;        app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.bottomnavigation.BottomNavigationView&#10;        android:id=&quot;@+id/bottomNav&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:menu=&quot;@menu/bottom_nav_menu&quot; /&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:id=&quot;@+id/appBarLayout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/CustomToolbarTheme&quot;&#10;            app:popupTheme=&quot;@style/OverflowMenuTheme&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.fragment.app.FragmentContainerView&#10;        android:id=&quot;@+id/nav_host_fragment&quot;&#10;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&#10;        app:layout_constraintRight_toRightOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/appBarLayout&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/bottomNav&quot;&#10;        app:defaultNavHost=&quot;true&quot;&#10;        app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.bottomnavigation.BottomNavigationView&#10;        android:id=&quot;@+id/bottomNav&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:menu=&quot;@menu/bottom_nav_menu&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmTitle&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import Hotspots&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Message --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmMessage&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;This will import all hotspot locations to your favorites. Do you want to continue?&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmTitle&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Cancel Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/cancelConfirmButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Cancel&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/confirmImportButton&quot; /&gt;&#10;&#10;    &lt;!-- Confirm Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/confirmImportButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/cancelConfirmButton&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:background=&quot;?android:attr/selectableItemBackground&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle for reordering --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/drag_icon&quot;&#10;        android:layout_width=&quot;24dp&quot;&#10;        android:layout_height=&quot;24dp&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        android:contentDescription=&quot;Drag to reorder&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Icon Preview --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/button_icon&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:contentDescription=&quot;Button icon&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/drag_icon&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Name --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/button_name&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textColor=&quot;?android:attr/textColorPrimary&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/button_icon&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/visibility_switch&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Visibility Switch --&gt;&#10;    &lt;androidx.appcompat.widget.SwitchCompat&#10;        android:id=&quot;@+id/visibility_switch&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;320dp&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:background=&quot;@android:color/background_dark&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/drag_handle&quot;&#10;        android:layout_width=&quot;48dp&quot;&#10;        android:layout_height=&quot;48dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Drag handle&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/title&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:text=&quot;Customize Overlay&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/drag_handle&quot; /&gt;&#10;&#10;    &lt;!-- Close Button --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/close_customization_button&quot;&#10;        android:layout_width=&quot;36dp&quot;&#10;        android:layout_height=&quot;36dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Close&quot;&#10;        android:src=&quot;@drawable/close_24px&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/title&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;!-- Button Size Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Size:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_value&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;48dp&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;SeekBar&#10;        android:id=&quot;@+id/size_seekbar&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:max=&quot;64&quot;&#10;        android:min=&quot;32&quot;&#10;        android:progress=&quot;48&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;!-- Button Visibility Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/visibility_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Visibility:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_seekbar&quot; /&gt;&#10;&#10;    &lt;!-- RecyclerView for button customization --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/buttons_recycler_view&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:maxHeight=&quot;300dp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/visibility_label&quot; /&gt;&#10;&#10;    &lt;!-- Reset Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/reset_button&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Reset to Defaults&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/buttons_recycler_view&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/raw/hotspots.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/raw/hotspots.txt" />
              <option name="updatedContent" value="[&#10;    {&#10;        &quot;name&quot;: &quot;Kiritimati&quot;,&#10;        &quot;lat&quot;: 1.98715,&#10;        &quot;lng&quot;: -157.47714&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Pago Pago&quot;,&#10;        &quot;lat&quot;: -14.27859,&#10;        &quot;lng&quot;: -170.68886&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sau Paulo Brazil&quot;,&#10;        &quot;lat&quot;: -23.58659,&#10;        &quot;lng&quot;: -46.65702&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sau Luis Brazil&quot;,&#10;        &quot;lat&quot;: -2.5578,&#10;        &quot;lng&quot;: -44.30924&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Santa Cruz Spain&quot;,&#10;        &quot;lat&quot;: 28.48952,&#10;        &quot;lng&quot;: -16.31807&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Indaial Brazil&quot;,&#10;        &quot;lat&quot;: -26.89304,&#10;        &quot;lng&quot;: -49.22998&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Izmir Turkey&quot;,&#10;        &quot;lat&quot;: 38.46297,&#10;        &quot;lng&quot;: 27.21787&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Antalya Turkey&quot;,&#10;        &quot;lat&quot;: 36.87944,&#10;        &quot;lng&quot;: 30.709&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Canary Islands&quot;,&#10;        &quot;lat&quot;: 28.1289,&#10;        &quot;lng&quot;: -15.4339&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Alcatraz Island&quot;,&#10;        &quot;lat&quot;: 37.82658,&#10;        &quot;lng&quot;: -122.42296&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Bornova Buyuk Park Turkey&quot;,&#10;        &quot;lat&quot;: 38.46314,&#10;        &quot;lng&quot;: 27.21649&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Bryant Park&quot;,&#10;        &quot;lat&quot;: 40.7536,&#10;        &quot;lng&quot;: -73.9832&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Budapest&quot;,&#10;        &quot;lat&quot;: 47.52876,&#10;        &quot;lng&quot;: 19.05138&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Busan&quot;,&#10;        &quot;lat&quot;: 35.15621,&#10;        &quot;lng&quot;: 129.05732&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Ceasers Palace&quot;,&#10;        &quot;lat&quot;: 36.116,&#10;        &quot;lng&quot;: -115.17422&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyland&quot;,&#10;        &quot;lat&quot;: 33.81195,&#10;        &quot;lng&quot;: -117.91907&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Central Park&quot;,&#10;        &quot;lat&quot;: 40.77042,&#10;        &quot;lng&quot;: -73.97464&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Dallas&quot;,&#10;        &quot;lat&quot;: 32.7759,&#10;        &quot;lng&quot;: -96.79678&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyworld FL&quot;,&#10;        &quot;lat&quot;: 28.41597,&#10;        &quot;lng&quot;: -81.58093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Greece&quot;,&#10;        &quot;lat&quot;: 40.62773,&#10;        &quot;lng&quot;: 22.95471&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Hong Kong&quot;,&#10;        &quot;lat&quot;: 22.31905,&#10;        &quot;lng&quot;: 114.17212&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Honolulu&quot;,&#10;        &quot;lat&quot;: 21.29836,&#10;        &quot;lng&quot;: -157.86011&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Korea&quot;,&#10;        &quot;lat&quot;: 37.56792,&#10;        &quot;lng&quot;: 126.98776&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Las Vegas&quot;,&#10;        &quot;lat&quot;: 36.11207,&#10;        &quot;lng&quot;: -115.1719&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;London&quot;,&#10;        &quot;lat&quot;: 51.51008,&#10;        &quot;lng&quot;: -0.12385&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Melbourne&quot;,&#10;        &quot;lat&quot;: -37.81751,&#10;        &quot;lng&quot;: 144.9633&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;MonteCarlo&quot;,&#10;        &quot;lat&quot;: 36.10447,&#10;        &quot;lng&quot;: -115.17458&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;New York&quot;,&#10;        &quot;lat&quot;: 40.75593,&#10;        &quot;lng&quot;: -73.98461&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;NianticHQ&quot;,&#10;        &quot;lat&quot;: 37.78946,&#10;        &quot;lng&quot;: -122.40162&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Osaka&quot;,&#10;        &quot;lat&quot;: 34.70246,&#10;        &quot;lng&quot;: 135.50024&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Peru&quot;,&#10;        &quot;lat&quot;: -11.56302,&#10;        &quot;lng&quot;: -77.27028&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Pier 39&quot;,&#10;        &quot;lat&quot;: 37.80867,&#10;        &quot;lng&quot;: -122.40982&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Royal Botanical Gardens&quot;,&#10;        &quot;lat&quot;: -33.8642,&#10;        &quot;lng&quot;: 151.2178&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Santa Monica&quot;,&#10;        &quot;lat&quot;: 34.00903,&#10;        &quot;lng&quot;: -118.49728&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Shinjuku Tokyo&quot;,&#10;        &quot;lat&quot;: 35.68902,&#10;        &quot;lng&quot;: 139.70122&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Singapore&quot;,&#10;        &quot;lat&quot;: 1.28872,&#10;        &quot;lng&quot;: 103.84874&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sydney&quot;,&#10;        &quot;lat&quot;: -33.86882,&#10;        &quot;lng&quot;: 151.2093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Times Square&quot;,&#10;        &quot;lat&quot;: 40.7589,&#10;        &quot;lng&quot;: -73.9851&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyland Japan&quot;,&#10;        &quot;lat&quot;: 35.63121,&#10;        &quot;lng&quot;: 139.88093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Ueno Onshi Tokyo&quot;,&#10;        &quot;lat&quot;: 35.71238,&#10;        &quot;lng&quot;: 139.77247&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;UnionSquare&quot;,&#10;        &quot;lat&quot;: 37.78799,&#10;        &quot;lng&quot;: -122.40744&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Zaragoza&quot;,&#10;        &quot;lat&quot;: 41.66134,&#10;        &quot;lng&quot;: -0.89283&#10;    }&#10;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>