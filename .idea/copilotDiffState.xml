<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Int,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.data&#13;&#10;&#13;&#10;data class ExportData(&#13;&#10;    val dataSources: Set&lt;String&gt;,&#13;&#10;    val enabledCharacters: Set&lt;Int&gt;,&#13;&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#13;&#10;    val enabledQuests: Set&lt;String&gt;,&#13;&#10;    val homeCoordinates: String,&#13;&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#13;&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#13;&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#13;&#10;    val activeRocketFilter: String,&#13;&#10;    val activeQuestFilter: String,&#13;&#10;    val overlayButtonSize: Int,&#13;&#10;    val overlayButtonOrder: List&lt;String&gt;,&#13;&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#13;&#10;&#13;&#10;import android.os.Handler&#13;&#10;import android.os.Looper&#13;&#10;import android.util.Log&#13;&#10;import android.view.MotionEvent&#13;&#10;import android.view.View&#13;&#10;import android.view.WindowManager&#13;&#10;&#13;&#10;class DragTouchListener(&#13;&#10;    private val params: WindowManager.LayoutParams,&#13;&#10;    private val windowManager: WindowManager,&#13;&#10;    private val rootView: View,&#13;&#10;    private val onLongPress: (() -&gt; Unit)? = null&#13;&#10;) : View.OnTouchListener {&#13;&#10;&#13;&#10;    private var initialX = 0&#13;&#10;    private var initialY = 0&#13;&#10;    private var downRawX = 0f&#13;&#10;    private var downRawY = 0f&#13;&#10;    private var hasMoved = false&#13;&#10;&#13;&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#13;&#10;    private val longPressRunnable = Runnable {&#13;&#10;        if (!hasMoved) {&#13;&#10;            Log.d(&quot;DragTouch&quot;, &quot;Long press detected!&quot;)&#13;&#10;            onLongPress?.invoke()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        private const val LONG_PRESS_TIMEOUT = 500L // 500ms for long press&#13;&#10;        private const val MOVE_THRESHOLD = 10 // pixels&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#13;&#10;        when (event.action) {&#13;&#10;            MotionEvent.ACTION_DOWN -&gt; {&#13;&#10;                Log.d(&quot;DragTouch&quot;, &quot;DOWN at (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                initialX = params.x&#13;&#10;                initialY = params.y&#13;&#10;                downRawX = event.rawX&#13;&#10;                downRawY = event.rawY&#13;&#10;                hasMoved = false&#13;&#10;&#13;&#10;                // Start long press detection&#13;&#10;                longPressHandler.postDelayed(longPressRunnable, LONG_PRESS_TIMEOUT)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_MOVE -&gt; {&#13;&#10;                val deltaX = (event.rawX - downRawX).toInt()&#13;&#10;                val deltaY = (event.rawY - downRawY).toInt()&#13;&#10;&#13;&#10;                // Check if user has moved beyond threshold&#13;&#10;                if (Math.abs(deltaX) &gt; MOVE_THRESHOLD || Math.abs(deltaY) &gt; MOVE_THRESHOLD) {&#13;&#10;                    hasMoved = true&#13;&#10;                    longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;&#13;&#10;                    Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                    // Calculate desired new position&#13;&#10;                    val newX = initialX + deltaX&#13;&#10;                    val newY = initialY + deltaY&#13;&#10;&#13;&#10;                    // Get screen &amp; overlay dimensions&#13;&#10;                    val dm = rootView.resources.displayMetrics&#13;&#10;                    val maxX = dm.widthPixels - rootView.width&#13;&#10;                    val maxY = dm.heightPixels - rootView.height&#13;&#10;&#13;&#10;                    // Clamp to [0..max]&#13;&#10;                    params.x = newX.coerceIn(0, maxX)&#13;&#10;                    params.y = newY.coerceIn(0, maxY)&#13;&#10;&#13;&#10;                    // Apply update&#13;&#10;                    windowManager.updateViewLayout(rootView, params)&#13;&#10;                }&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#13;&#10;                // Cancel long press if finger is lifted&#13;&#10;                longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return false&#13;&#10;    }&#13;&#10;&#13;&#10;    /** Expose current overlay X (left) */&#13;&#10;    fun getCurrentParamsX(): Int = params.x&#13;&#10;&#13;&#10;    /** Expose current overlay Y (top) */&#13;&#10;    fun getCurrentParamsY(): Int = params.y&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;interface ItemTouchHelperAdapter {&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean&#10;}&#10;&#10;class ItemTouchHelperCallback(&#10;    private val adapter: ItemTouchHelperAdapter&#10;) : ItemTouchHelper.Callback() {&#10;&#10;    override fun isLongPressDragEnabled(): Boolean = false&#10;&#10;    override fun isItemViewSwipeEnabled(): Boolean = false&#10;&#10;    override fun getMovementFlags(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder&#10;    ): Int {&#10;        val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN&#10;        return makeMovementFlags(dragFlags, 0)&#10;    }&#10;&#10;    override fun onMove(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder,&#10;        target: RecyclerView.ViewHolder&#10;    ): Boolean {&#10;        return adapter.onItemMove(viewHolder.adapterPosition, target.adapterPosition)&#10;    }&#10;&#10;    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;        // Not implemented&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/DeletedInvasionsAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/DeletedInvasionsAdapter.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import androidx.core.net.toUri&#10;import android.text.format.DateFormat&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Date&#10;&#10;class DeletedInvasionsAdapter : ListAdapter&lt;DeletedInvasionsAdapter.UIModel, DeletedInvasionsAdapter.VH&gt;(Diff()) {&#10;&#10;    data class UIModel(&#10;        val name: String,&#10;        val source: String,&#10;        val characterName: String,&#10;        val typeDescription: String,&#10;        val lat: Double,&#10;        val lng: Double,&#10;        val timestamp: Long,&#10;    )&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {&#10;        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_deleted_invasion, parent, false)&#10;        return VH(v)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: VH, position: Int) = holder.bind(getItem(position))&#10;&#10;    class VH(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val name: TextView = itemView.findViewById(R.id.nameText)&#10;        private val source: TextView = itemView.findViewById(R.id.sourceText)&#10;        private val character: TextView = itemView.findViewById(R.id.characterText)&#10;        private val type: TextView = itemView.findViewById(R.id.typeText)&#10;        private val coords: TextView = itemView.findViewById(R.id.coordsText)&#10;        private val time: TextView = itemView.findViewById(R.id.timeText)&#10;        private val btnCopy: Button = itemView.findViewById(R.id.copyButton)&#10;        private val btnTeleport: Button = itemView.findViewById(R.id.teleportButton)&#10;&#10;        fun bind(m: UIModel) {&#10;            val ctx = itemView.context&#10;            name.text = ctx.getString(R.string.deleted_item_name, m.name)&#10;            source.text = ctx.getString(R.string.deleted_item_source, m.source.replaceFirstChar { it.uppercase() })&#10;            character.text = ctx.getString(R.string.deleted_item_character, m.characterName)&#10;            type.text = ctx.getString(R.string.deleted_item_type, m.typeDescription)&#10;            coords.text = ctx.getString(R.string.deleted_item_coords, m.lat, m.lng)&#10;&#10;            val timeStr = DateFormat.getMediumDateFormat(ctx).format(Date(m.timestamp)) + &quot; &quot; +&#10;                    DateFormat.getTimeFormat(ctx).format(Date(m.timestamp))&#10;            time.text = ctx.getString(R.string.deleted_item_time, timeStr)&#10;&#10;            btnCopy.setOnClickListener {&#10;                val c = ctx.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager&#10;                val text = &quot;${m.lat},${m.lng}&quot;&#10;                c.setPrimaryClip(ClipData.newPlainText(&quot;Coordinates&quot;, text))&#10;                val toast = Toast.makeText(ctx, R.string.coords_copied, Toast.LENGTH_SHORT)&#10;                toast.show()&#10;            }&#10;            btnTeleport.setOnClickListener {&#10;                val url = &quot;https://ipogo.app/?coords=${m.lat},${m.lng}&quot;&#10;                val intent = Intent(Intent.ACTION_VIEW, url.toUri())&#10;                ctx.startActivity(intent)&#10;            }&#10;        }&#10;    }&#10;&#10;    class Diff : DiffUtil.ItemCallback&lt;UIModel&gt;() {&#10;        override fun areItemsTheSame(oldItem: UIModel, newItem: UIModel): Boolean =&#10;            oldItem.lat == newItem.lat &amp;&amp; oldItem.lng == newItem.lng &amp;&amp; oldItem.timestamp == newItem.timestamp&#10;&#10;        override fun areContentsTheSame(oldItem: UIModel, newItem: UIModel): Boolean = oldItem == newItem&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/InvasionsAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/InvasionsAdapter.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Invasion&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class InvasionsAdapter(&#10;    private val onDeleteInvasion: (Invasion) -&gt; Unit&#10;) : ListAdapter&lt;Invasion, InvasionsAdapter.InvasionViewHolder&gt;(InvasionDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): InvasionViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_invasion, parent, false)&#10;        return InvasionViewHolder(view, onDeleteInvasion)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: InvasionViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    class InvasionViewHolder(&#10;        itemView: View,&#10;        private val onDeleteInvasion: (Invasion) -&gt; Unit&#10;    ) : RecyclerView.ViewHolder(itemView) {&#10;        private val characterNameText: TextView = itemView.findViewById(R.id.characterNameText)&#10;        private val typeText: TextView = itemView.findViewById(R.id.typeText)&#10;        private val locationNameText: TextView = itemView.findViewById(R.id.locationText)&#10;        private val sourceText: TextView = itemView.findViewById(R.id.sourceText)  // New TextView for source&#10;        private val coordinatesText: TextView = itemView.findViewById(R.id.coordinatesText)&#10;        private val timeText: TextView = itemView.findViewById(R.id.timeText)&#10;        private val teleportButton: Button = itemView.findViewById(R.id.teleportButton)&#10;        private val copyButton: Button = itemView.findViewById(R.id.copyButton)&#10;        private val deleteButton: Button = itemView.findViewById(R.id.deleteButton)&#10;        private val dateFormat = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;&#10;        fun bind(invasion: Invasion) {&#10;            characterNameText.text = invasion.characterName&#10;            typeText.text = invasion.typeDescription&#10;            locationNameText.text = &quot;Pokestop: ${invasion.name}&quot;&#10;            val invasionText = invasion.source.lowercase().replaceFirstChar { it.uppercase() }&#10;&#10;            // Bind the source. (Assumes your Invasion data class has a &quot;source&quot; property.)&#10;            sourceText.text = &quot;Source: $invasionText&quot;&#10;&#10;            val coordsFormatted = String.format(&quot;%.5f, %.5f&quot;, invasion.lat, invasion.lng)&#10;            coordinatesText.text = &quot;Location: $coordsFormatted&quot;&#10;            val startTime = dateFormat.format(Date(invasion.invasion_start * 1000))&#10;            val endTime = dateFormat.format(Date(invasion.invasion_end * 1000))&#10;            timeText.text = &quot;Time: $startTime - $endTime&quot;&#10;&#10;            // Teleport button&#10;            teleportButton.setOnClickListener {&#10;                val url = &quot;https://ipogo.app/?coords=${invasion.lat},${invasion.lng}&quot;&#10;                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;                itemView.context.startActivity(intent)&#10;                onDeleteInvasion(invasion)&#10;            }&#10;&#10;            // Copy button&#10;            copyButton.setOnClickListener {&#10;                val coordsText = &quot;${invasion.lat},${invasion.lng}&quot;&#10;                val clipboard = itemView.context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager&#10;                val clip = ClipData.newPlainText(&quot;Coordinates&quot;, coordsText)&#10;                clipboard.setPrimaryClip(clip)&#10;                Toast.makeText(itemView.context, &quot;Coordinates copied to clipboard&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;&#10;            // Delete button&#10;            deleteButton.setOnClickListener {&#10;                onDeleteInvasion(invasion)&#10;            }&#10;        }&#10;    }&#10;&#10;    class InvasionDiffCallback : DiffUtil.ItemCallback&lt;Invasion&gt;() {&#10;        override fun areItemsTheSame(oldItem: Invasion, newItem: Invasion): Boolean {&#10;            return oldItem.lat == newItem.lat &amp;&amp; oldItem.lng == newItem.lng&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: Invasion, newItem: Invasion): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import androidx.core.net.toUri&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Invasion&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class InvasionsAdapter(&#10;    private val onDeleteInvasion: (Invasion) -&gt; Unit&#10;) : ListAdapter&lt;Invasion, InvasionsAdapter.InvasionViewHolder&gt;(InvasionDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): InvasionViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_invasion, parent, false)&#10;        return InvasionViewHolder(view, onDeleteInvasion)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: InvasionViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    class InvasionViewHolder(&#10;        itemView: View,&#10;        private val onDeleteInvasion: (Invasion) -&gt; Unit&#10;    ) : RecyclerView.ViewHolder(itemView) {&#10;        private val characterNameText: TextView = itemView.findViewById(R.id.characterNameText)&#10;        private val typeText: TextView = itemView.findViewById(R.id.typeText)&#10;        private val locationNameText: TextView = itemView.findViewById(R.id.locationText)&#10;        private val sourceText: TextView = itemView.findViewById(R.id.sourceText)&#10;        private val coordinatesText: TextView = itemView.findViewById(R.id.coordinatesText)&#10;        private val timeText: TextView = itemView.findViewById(R.id.timeText)&#10;        private val teleportButton: Button = itemView.findViewById(R.id.teleportButton)&#10;        private val copyButton: Button = itemView.findViewById(R.id.copyButton)&#10;        private val deleteButton: Button = itemView.findViewById(R.id.deleteButton)&#10;        private val dateFormat = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;&#10;        fun bind(invasion: Invasion) {&#10;            val ctx = itemView.context&#10;            characterNameText.text = invasion.characterName&#10;            typeText.text = invasion.typeDescription&#10;            locationNameText.text = ctx.getString(R.string.invasion_item_name, invasion.name)&#10;            val invasionText = invasion.source.lowercase().replaceFirstChar { it.uppercase() }&#10;            sourceText.text = ctx.getString(R.string.invasion_item_source, invasionText)&#10;&#10;            val coordsFormatted = String.format(Locale.getDefault(), &quot;%.5f, %.5f&quot;, invasion.lat, invasion.lng)&#10;            coordinatesText.text = ctx.getString(R.string.invasion_item_coords, coordsFormatted)&#10;            val startTime = dateFormat.format(Date(invasion.invasion_start * 1000))&#10;            val endTime = dateFormat.format(Date(invasion.invasion_end * 1000))&#10;            timeText.text = ctx.getString(R.string.invasion_item_time_range, startTime, endTime)&#10;&#10;            teleportButton.setOnClickListener {&#10;                val url = &quot;https://ipogo.app/?coords=${invasion.lat},${invasion.lng}&quot;&#10;                val intent = Intent(Intent.ACTION_VIEW, url.toUri())&#10;                ctx.startActivity(intent)&#10;                onDeleteInvasion(invasion)&#10;            }&#10;&#10;            copyButton.setOnClickListener {&#10;                val coordsText = &quot;${invasion.lat},${invasion.lng}&quot;&#10;                val clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager&#10;                val clip = ClipData.newPlainText(&quot;Coordinates&quot;, coordsText)&#10;                clipboard.setPrimaryClip(clip)&#10;                Toast.makeText(ctx, R.string.coords_copied, Toast.LENGTH_SHORT).show()&#10;            }&#10;&#10;            deleteButton.setOnClickListener {&#10;                onDeleteInvasion(invasion)&#10;            }&#10;        }&#10;    }&#10;&#10;    class InvasionDiffCallback : DiffUtil.ItemCallback&lt;Invasion&gt;() {&#10;        override fun areItemsTheSame(oldItem: Invasion, newItem: Invasion): Boolean {&#10;            return oldItem.lat == newItem.lat &amp;&amp; oldItem.lng == newItem.lng&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: Invasion, newItem: Invasion): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;            // Keep button icon at full opacity&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;            // Keep button icon at full opacity&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // All items can now be dragged&#10;            dragIcon.alpha = 1.0f&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/DeletedInvasionsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/DeletedInvasionsFragment.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.DeletedEntry&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.recyclerviews.DeletedInvasionsAdapter&#10;&#10;class DeletedInvasionsFragment : Fragment() {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: DeletedInvasionsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var emptyText: TextView&#10;    private lateinit var countText: TextView&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_deleted_invasions, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        recyclerView = view.findViewById(R.id.deletedRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        emptyText = view.findViewById(R.id.emptyText)&#10;        countText = view.findViewById(R.id.deletedCountText)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;&#10;        adapter = DeletedInvasionsAdapter()&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkFab()&#10;            }&#10;        })&#10;&#10;        scrollToTopFab.setOnClickListener { recyclerView.smoothScrollToPosition(0) }&#10;&#10;        swipeRefresh.setOnRefreshListener { loadData() }&#10;&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        val repo = DeletedInvasionsRepository(requireContext())&#10;        val entries: List&lt;DeletedEntry&gt; = repo.getDeletedEntries()&#10;            .sortedByDescending { it.timestamp }&#10;            .toList()&#10;&#10;        // Map optional fields to display strings with explicit type for lambda param&#10;        val mapped = entries.map { e: DeletedEntry -&gt;&#10;            val characterName = e.character?.let { DataMappings.characterNamesMap[it] } ?: getString(R.string.deleted_unknown_character)&#10;            val typeDesc = e.type?.let { DataMappings.typeDescriptionsMap[it] } ?: getString(R.string.deleted_unknown_type)&#10;            DeletedInvasionsAdapter.UIModel(&#10;                name = e.name ?: getString(R.string.deleted_unknown_stop),&#10;                source = e.source ?: getString(R.string.deleted_unknown_source),&#10;                characterName = characterName,&#10;                typeDescription = typeDesc,&#10;                lat = e.lat,&#10;                lng = e.lng,&#10;                timestamp = e.timestamp&#10;            )&#10;        }&#10;&#10;        adapter.submitList(mapped)&#10;        swipeRefresh.isRefreshing = false&#10;&#10;        countText.text = resources.getQuantityString(R.plurals.deleted_count, mapped.size, mapped.size)&#10;        emptyText.visibility = if (mapped.isEmpty()) View.VISIBLE else View.GONE&#10;        checkFab()&#10;    }&#10;&#10;    private fun checkFab() {&#10;        if (adapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide(); return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/QuestsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/QuestsFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.VisitedQuestsPreferences&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.QuestsAdapter&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;import androidx.core.net.toUri&#10;&#10;&#10;class QuestsFragment : Fragment() {&#10;&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var questsCountText: TextView&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var questsAdapter: QuestsAdapter&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var questErrorHandler: TextView&#10;&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_quests, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        questsCountText = view.findViewById(R.id.questsCountText)&#10;        recyclerView = view.findViewById(R.id.questsRecyclerView)&#10;        questErrorHandler = view.findViewById(R.id.errorHandlerText)&#10;        questsAdapter = QuestsAdapter { quest: Quests.Quest -&gt;&#10;            questsViewModel.saveLastVisitedCoordinates(quest)&#10;&#10;            val questId = &quot;${quest.name}|${quest.lat}|${quest.lng}&quot;&#10;            val visitedPreferences = VisitedQuestsPreferences(requireContext())&#10;            visitedPreferences.addVisitedQuest(questId)&#10;            val currentList = questsAdapter.currentList.toMutableList()&#10;            currentList.remove(quest)&#10;            questsAdapter.submitList(currentList)&#10;            updateQuestsCount(currentList.size)&#10;        }&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = questsAdapter&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        setupScrollToTop()&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests: List&lt;Quests.Quest&gt; -&gt;&#10;            questsAdapter.submitList(quests)&#10;            updateQuestsCount(quests.size)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if(questsViewModel.filterSizeLiveData.value == 0) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.text = &quot;No quest filters enabled. Please go to the filter tab to filter quests.&quot;&#10;&#10;            } else if(quests.isEmpty()) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.text = &quot;No quests available. Please check your filters or change the data source in the Settings.&quot;&#10;            } else {&#10;                questErrorHandler.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;&#10;        }&#10;&#10;        questsViewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;&#10;&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            questsViewModel.fetchQuests()&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;        updateServiceButtonState(startServiceButton)&#10;&#10;        swipeRefresh.isRefreshing = true&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        questsAdapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        // Handle FAB click&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (questsAdapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        // Check if we have overlay permission&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            // We have permission, start service directly&#10;            serviceManager.startOverlayService(&quot;quests&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;&#10;    private fun updateQuestsCount(count: Int) {&#10;        questsCountText.text = &quot;Total Quests: $count&quot;&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.VisitedQuestsPreferences&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.QuestsAdapter&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;import androidx.core.net.toUri&#10;&#10;&#10;class QuestsFragment : Fragment() {&#10;&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var questsCountText: TextView&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var questsAdapter: QuestsAdapter&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var questErrorHandler: TextView&#10;&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_quests, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        questsCountText = view.findViewById(R.id.questsCountText)&#10;        recyclerView = view.findViewById(R.id.questsRecyclerView)&#10;        questErrorHandler = view.findViewById(R.id.errorHandlerText)&#10;        questsAdapter = QuestsAdapter { quest: Quests.Quest -&gt;&#10;            questsViewModel.saveLastVisitedCoordinates(quest)&#10;&#10;            val questId = &quot;${quest.name}|${quest.lat}|${quest.lng}&quot;&#10;            val visitedPreferences = VisitedQuestsPreferences(requireContext())&#10;            visitedPreferences.addVisitedQuest(questId)&#10;            val currentList = questsAdapter.currentList.toMutableList()&#10;            currentList.remove(quest)&#10;            questsAdapter.submitList(currentList)&#10;            updateQuestsCount(currentList.size)&#10;        }&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = questsAdapter&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        setupScrollToTop()&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests: List&lt;Quests.Quest&gt; -&gt;&#10;            questsAdapter.submitList(quests)&#10;            updateQuestsCount(quests.size)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if(questsViewModel.filterSizeLiveData.value == 0) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.setText(R.string.no_quest_filters_message)&#10;&#10;            } else if(quests.isEmpty()) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.setText(R.string.no_quests_available_message)&#10;            } else {&#10;                questErrorHandler.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;&#10;        }&#10;&#10;        questsViewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;&#10;&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            questsViewModel.fetchQuests()&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;        updateServiceButtonState(startServiceButton)&#10;&#10;        swipeRefresh.isRefreshing = true&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        questsAdapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        // Handle FAB click&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (questsAdapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        // Check if we have overlay permission&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            // We have permission, start service directly&#10;            serviceManager.startOverlayService(&quot;quests&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.setText(R.string.enable_overlay_permissions)&#10;        } else {&#10;            button.setText(R.string.enable_overlay)&#10;        }&#10;    }&#10;&#10;    private fun updateQuestsCount(count: Int) {&#10;        questsCountText.text = getString(R.string.total_quests, count)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.RaidsAdapter&#10;import com.mints.projectgammatwo.viewmodels.RaidsViewModel&#10;import androidx.core.net.toUri&#10;&#10;class RaidsFragment : Fragment() {&#10;&#10;    private val viewModel: RaidsViewModel by viewModels()&#10;    private lateinit var adapter: RaidsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_raids, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.raidsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = RaidsAdapter { raid -&gt;&#10;            viewModel.deleteRaid(raid)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchRaids()&#10;        }&#10;&#10;        viewModel.raidsLiveData.observe(viewLifecycleOwner) { raids -&gt;&#10;            adapter.submitList(raids)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if (raids.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No raids available. Please check your data sources in Settings.&quot;&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            if (errorMessage.isNotEmpty()) {&#10;                Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                swipeRefresh.isRefreshing = false&#10;            }&#10;        }&#10;&#10;        val raidsCountTextView = view.findViewById&lt;TextView&gt;(R.id.raidsCountText)&#10;        viewModel.raidsCountLiveData.observe(viewLifecycleOwner) { count -&gt;&#10;            raidsCountTextView.text = &quot;Total Raids: $count&quot;&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchRaids()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        })&#10;&#10;        adapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        })&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.scrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        val layoutManager = recyclerView.layoutManager as? LinearLayoutManager ?: return&#10;&#10;        if (adapter.itemCount == 0) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;No items, hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;&#10;        val firstVisibleItem = layoutManager.findFirstVisibleItemPosition()&#10;        Log.d(&#10;            &quot;FAB_DEBUG&quot;,&#10;            &quot;First visible item: $firstVisibleItem, Total items: ${adapter.itemCount}&quot;&#10;        )&#10;&#10;        if (firstVisibleItem != RecyclerView.NO_POSITION &amp;&amp; firstVisibleItem &gt; 2) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Showing FAB&quot;)&#10;            scrollToTopFab.show()&#10;        } else {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;        }&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;raids&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.edit&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.ExportData&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;        private const val KEY_FAVORITES = &quot;favorites_list&quot;&#10;        private const val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;        private const val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;        private const val SOURCE_NYC = &quot;NYC&quot;&#10;        private const val SOURCE_LONDON = &quot;LONDON&quot;&#10;        private const val SOURCE_SINGAPORE = &quot;Singapore&quot;&#10;        private const val SOURCE_VANCOUVER = &quot;VANCOUVER&quot;&#10;        private const val SOURCE_SYDNEY = &quot;SYDNEY&quot;&#10;&#10;        private const val FILTER_TYPE_ROCKET = &quot;Rocket&quot;&#10;        private const val FILTER_TYPE_QUEST = &quot;Quest&quot;&#10;    }&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(SOURCE_NYC)&#10;        checkboxLondon.isChecked = selectedSources.contains(SOURCE_LONDON)&#10;        checkboxSG.isChecked = selectedSources.contains(SOURCE_SINGAPORE)&#10;        checkboxVancouver.isChecked = selectedSources.contains(SOURCE_VANCOUVER)&#10;        checkboxSydney.isChecked = selectedSources.contains(SOURCE_SYDNEY)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(SOURCE_NYC)&#10;            if (checkboxLondon.isChecked) newSelection.add(SOURCE_LONDON)&#10;            if (checkboxSG.isChecked) newSelection.add(SOURCE_SINGAPORE)&#10;            if (checkboxVancouver.isChecked) newSelection.add(SOURCE_VANCOUVER)&#10;            if (checkboxSydney.isChecked) newSelection.add(SOURCE_SYDNEY)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(SOURCE_NYC)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit { putString(KEY_TELEPORT_METHOD, method) }&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val initialCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(initialCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = getString(R.string.home_coords_hint)&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), getString(R.string.home_coords_saved, coords), Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        getString(R.string.home_coords_invalid),&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Use latest saved value if available&#10;                    val previous = homeCoordinatesManager.getHomeCoordinatesString()&#10;                    if (previous.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(previous)) {&#10;                        homeCoordinates.setText(previous)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = getString(R.string.overlay_size_dp, currentSize)&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = getString(R.string.overlay_size_dp, progress)&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = getString(R.string.overlay_size_dp, defaultSize)&#10;&#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; getString(R.string.overlay_button_drag_handle)&#10;            &quot;close_button&quot; -&gt; getString(R.string.overlay_button_close)&#10;            &quot;right_button&quot; -&gt; getString(R.string.overlay_button_next)&#10;            &quot;left_button&quot; -&gt; getString(R.string.overlay_button_previous)&#10;            &quot;home_button&quot; -&gt; getString(R.string.overlay_button_home)&#10;            &quot;refresh_button&quot; -&gt; getString(R.string.overlay_button_refresh)&#10;            &quot;switch_modes&quot; -&gt; getString(R.string.overlay_button_switch_mode)&#10;            &quot;filter_tab&quot; -&gt; getString(R.string.overlay_button_filters)&#10;            &quot;favorites_tab&quot; -&gt; getString(R.string.overlay_button_favorites)&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        val deletedEntries = deletedRepo.getDeletedEntries()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Deleted entries count: ${deletedEntries.size}&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            // you used QUEST_SPINDA_PREFIX = &quot;spinda_&quot;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            deletedEntries = deletedEntries,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.settings_share_subject))&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, getString(R.string.settings_share_chooser_title)))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_export_failed, e.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        cancelButton.setOnClickListener { dialog.dismiss() }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), getString(R.string.settings_import_input_empty), Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit { putString(KEY_FAVORITES, gson.toJson(importData.favorites)) }&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.deletedEntries.size} deleted entries&quot;)&#10;            deletedRepo.setDeletedEntries(importData.deletedEntries)&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters (non-null in ExportData)&#10;            val rocketFilters = importData.savedRocketFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${rocketFilters.size} rocket filters to import&quot;)&#10;&#10;            // Clear existing filters first&#10;            val existingFilterNames = filterPreferences.listFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;            for (name in existingFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_ROCKET)&#10;            }&#10;&#10;            // Import the filters&#10;            for ((name, characters) in rocketFilters) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledCharacters(characters)&#10;                    filterPreferences.saveCurrentAsFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active rocket filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;            if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                rocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeRocketFilter, FILTER_TYPE_ROCKET)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Import saved quest filters (non-null in ExportData)&#10;            val questFilters = importData.savedQuestFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${questFilters.size} quest filters to import&quot;)&#10;&#10;            // Clear existing quest filters first&#10;            val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;            for (name in existingQuestFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_QUEST)&#10;            }&#10;&#10;            // Import the quest filters&#10;            for ((name, questIds) in questFilters) {&#10;                val questStrings = questIds.toSet() // already Set&lt;String&gt;&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                    val forms: Set&lt;String&gt; = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                    filterPreferences.saveEnabledSpindaForms(forms)&#10;                    filterPreferences.saveCurrentQuestFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active quest filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;            if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                questFilters.containsKey(importData.activeQuestFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeQuestFilter, FILTER_TYPE_QUEST)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Update UI checkboxes and overlay customization&#10;            checkboxNYC.isChecked = importData.dataSources.contains(SOURCE_NYC)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(SOURCE_LONDON)&#10;            checkboxSG.isChecked = importData.dataSources.contains(SOURCE_SINGAPORE)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(SOURCE_VANCOUVER)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(SOURCE_SYDNEY)&#10;&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_success), Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_failed, ex.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.edit&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.ExportData&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;        private const val KEY_FAVORITES = &quot;favorites_list&quot;&#10;        private const val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;        private const val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;        private const val SOURCE_NYC = &quot;NYC&quot;&#10;        private const val SOURCE_LONDON = &quot;LONDON&quot;&#10;        private const val SOURCE_SINGAPORE = &quot;Singapore&quot;&#10;        private const val SOURCE_VANCOUVER = &quot;VANCOUVER&quot;&#10;        private const val SOURCE_SYDNEY = &quot;SYDNEY&quot;&#10;&#10;        private const val FILTER_TYPE_ROCKET = &quot;Rocket&quot;&#10;        private const val FILTER_TYPE_QUEST = &quot;Quest&quot;&#10;    }&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(SOURCE_NYC)&#10;        checkboxLondon.isChecked = selectedSources.contains(SOURCE_LONDON)&#10;        checkboxSG.isChecked = selectedSources.contains(SOURCE_SINGAPORE)&#10;        checkboxVancouver.isChecked = selectedSources.contains(SOURCE_VANCOUVER)&#10;        checkboxSydney.isChecked = selectedSources.contains(SOURCE_SYDNEY)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(SOURCE_NYC)&#10;            if (checkboxLondon.isChecked) newSelection.add(SOURCE_LONDON)&#10;            if (checkboxSG.isChecked) newSelection.add(SOURCE_SINGAPORE)&#10;            if (checkboxVancouver.isChecked) newSelection.add(SOURCE_VANCOUVER)&#10;            if (checkboxSydney.isChecked) newSelection.add(SOURCE_SYDNEY)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(SOURCE_NYC)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit { putString(KEY_TELEPORT_METHOD, method) }&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val initialCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(initialCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = getString(R.string.home_coords_hint)&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), getString(R.string.home_coords_saved, coords), Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        getString(R.string.home_coords_invalid),&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Use latest saved value if available&#10;                    val previous = homeCoordinatesManager.getHomeCoordinatesString()&#10;                    if (previous.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(previous)) {&#10;                        homeCoordinates.setText(previous)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = getString(R.string.overlay_size_dp, currentSize)&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = getString(R.string.overlay_size_dp, progress)&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = getString(R.string.overlay_size_dp, defaultSize)&#10;&#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; getString(R.string.overlay_button_drag_handle)&#10;            &quot;close_button&quot; -&gt; getString(R.string.overlay_button_close)&#10;            &quot;right_button&quot; -&gt; getString(R.string.overlay_button_next)&#10;            &quot;left_button&quot; -&gt; getString(R.string.overlay_button_previous)&#10;            &quot;home_button&quot; -&gt; getString(R.string.overlay_button_home)&#10;            &quot;refresh_button&quot; -&gt; getString(R.string.overlay_button_refresh)&#10;            &quot;switch_modes&quot; -&gt; getString(R.string.overlay_button_switch_mode)&#10;            &quot;filter_tab&quot; -&gt; getString(R.string.overlay_button_filters)&#10;            &quot;favorites_tab&quot; -&gt; getString(R.string.overlay_button_favorites)&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.settings_share_subject))&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, getString(R.string.settings_share_chooser_title)))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_export_failed, e.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        cancelButton.setOnClickListener { dialog.dismiss() }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), getString(R.string.settings_import_input_empty), Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit { putString(KEY_FAVORITES, gson.toJson(importData.favorites)) }&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters (non-null in ExportData)&#10;            val rocketFilters = importData.savedRocketFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${rocketFilters.size} rocket filters to import&quot;)&#10;&#10;            // Clear existing filters first&#10;            val existingFilterNames = filterPreferences.listFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;            for (name in existingFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_ROCKET)&#10;            }&#10;&#10;            // Import the filters&#10;            for ((name, characters) in rocketFilters) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledCharacters(characters)&#10;                    filterPreferences.saveCurrentAsFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active rocket filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;            if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                rocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeRocketFilter, FILTER_TYPE_ROCKET)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Import saved quest filters (non-null in ExportData)&#10;            val questFilters = importData.savedQuestFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${questFilters.size} quest filters to import&quot;)&#10;&#10;            // Clear existing quest filters first&#10;            val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;            for (name in existingQuestFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_QUEST)&#10;            }&#10;&#10;            // Import the quest filters&#10;            for ((name, questIds) in questFilters) {&#10;                val questStrings = questIds.toSet() // already Set&lt;String&gt;&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                    val forms: Set&lt;String&gt; = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                    filterPreferences.saveEnabledSpindaForms(forms)&#10;                    filterPreferences.saveCurrentQuestFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active quest filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;            if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                questFilters.containsKey(importData.activeQuestFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeQuestFilter, FILTER_TYPE_QUEST)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Update UI checkboxes and overlay customization&#10;            checkboxNYC.isChecked = importData.dataSources.contains(SOURCE_NYC)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(SOURCE_LONDON)&#10;            checkboxSG.isChecked = importData.dataSources.contains(SOURCE_SINGAPORE)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(SOURCE_VANCOUVER)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(SOURCE_SYDNEY)&#10;&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_success), Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_failed, ex.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;QuestsViewModel&quot;, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(tag, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                val responses = deferredList.map { it.await() }&#10;&#10;                // Filter successful responses&#10;                val successfulResponses = responses.mapNotNull { (source, result) -&gt;&#10;                    result.getOrNull()?.let { response -&gt;&#10;                        Pair(source, response)&#10;                    }&#10;                }&#10;&#10;                // If no successful responses, handle the error state&#10;                if (successfulResponses.isEmpty()) {&#10;                    Log.w(tag, &quot;No successful API responses received&quot;)&#10;                    _raidsLiveData.postValue(emptyList())&#10;                    _raidsCountLiveData.postValue(0)&#10;                    _filterSizeLiveData.postValue(0)&#10;                    _error.postValue(&quot;Unable to fetch raids. Please check your connection.&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Process successful responses&#10;                val combinedRaids = successfulResponses.flatMap { (source, response) -&gt;&#10;                    response.body()?.raids?.map { raid -&gt;&#10;                        raid.copy(source = source)&#10;                    } ?: emptyList()&#10;                }.toMutableList()&#10;&#10;                // Filter raids (you might want to add filtering preferences similar to HomeViewModel)&#10;                val filteredRaids = combinedRaids&#10;                    .filter { raid -&gt;&#10;                        // Add any filtering logic here&#10;                        // For now, we'll include all raids&#10;                        true&#10;                    }&#10;                    .sortedBy { it.raid_start }&#10;                    .reversed()&#10;&#10;                // Update LiveData&#10;                _raidsLiveData.postValue(filteredRaids)&#10;                _raidsCountLiveData.postValue(filteredRaids.size)&#10;                _filterSizeLiveData.postValue(filteredRaids.size)&#10;&#10;                Log.d(tag, &quot;Successfully fetched raids from ${successfulResponses.size} sources. Total raids: ${filteredRaids.size}&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                e(tag, &quot;Error in fetchRaids&quot;, e)&#10;                _raidsLiveData.postValue(emptyList())&#10;                _raidsCountLiveData.postValue(0)&#10;                _filterSizeLiveData.postValue(0)&#10;                _error.postValue(&quot;An unexpected error occurred&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getRaids(): List&lt;Raid&gt;? {&#10;        return _raidsLiveData.value&#10;    }&#10;&#10;    // Method to handle raid deletion (if needed)&#10;    fun deleteRaid(raid: Raid) {&#10;        _raidsLiveData.value = _raidsLiveData.value?.toMutableList()?.apply { remove(raid) }&#10;        _raidsCountLiveData.value = _raidsLiveData.value?.size ?: 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmTitle&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import Hotspots&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Message --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmMessage&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;This will import all hotspot locations to your favorites. Do you want to continue?&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmTitle&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Cancel Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/cancelConfirmButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Cancel&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/confirmImportButton&quot; /&gt;&#10;&#10;    &lt;!-- Confirm Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/confirmImportButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/cancelConfirmButton&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_deleted_invasions.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_deleted_invasions.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/deletedCountText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:padding=&quot;14dp&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:background=&quot;?attr/colorPrimary&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt;&#10;&#10;    &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;        android:id=&quot;@+id/swipeRefresh&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/deletedCountText&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;FrameLayout&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;            &lt;androidx.recyclerview.widget.RecyclerView&#10;                android:id=&quot;@+id/deletedRecyclerView&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;match_parent&quot;&#10;                app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;/&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/emptyText&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;match_parent&quot;&#10;                android:gravity=&quot;center&quot;&#10;                android:text=&quot;@string/deleted_empty&quot;&#10;                android:textSize=&quot;18sp&quot;&#10;                android:visibility=&quot;gone&quot;/&gt;&#10;        &lt;/FrameLayout&gt;&#10;    &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;&#10;&#10;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton&#10;        android:id=&quot;@+id/scrollToTopFab&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginEnd=&quot;16dp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:src=&quot;@drawable/keyboard_arrow_up_24px&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        android:contentDescription=&quot;@string/cd_scroll_to_top&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_deleted_invasion.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_deleted_invasion.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;12dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/nameText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/teleportButton&quot;&#10;        android:text=&quot;@string/deleted_item_name_placeholder&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/sourceText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;@id/nameText&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/nameText&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;@id/nameText&quot;&#10;        android:text=&quot;@string/deleted_item_source_placeholder&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/characterText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;@id/sourceText&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/sourceText&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;@id/sourceText&quot;&#10;        android:text=&quot;@string/deleted_item_character_placeholder&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/typeText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;@id/characterText&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/characterText&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;@id/characterText&quot;&#10;        android:text=&quot;@string/deleted_item_type_placeholder&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/coordsText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;@id/typeText&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/typeText&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;@id/typeText&quot;&#10;        android:text=&quot;@string/deleted_item_coords_placeholder&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/timeText&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;@id/coordsText&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/coordsText&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;@id/coordsText&quot;&#10;        android:text=&quot;@string/deleted_item_time_placeholder&quot;/&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/copyButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;@string/copy&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/teleportButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;@string/teleport&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/copyButton&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.cardview.widget.CardView&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:layout_margin=&quot;8dp&quot;&#10;    app:cardElevation=&quot;4dp&quot;&#10;    app:cardCornerRadius=&quot;8dp&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;16dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/nameText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/sourceText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:textSize=&quot;14sp&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/characterText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:textSize=&quot;14sp&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/typeText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:textSize=&quot;14sp&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/coordsText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:textSize=&quot;14sp&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timeText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:textSize=&quot;14sp&quot;/&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;horizontal&quot;&#10;            android:layout_marginTop=&quot;8dp&quot;&#10;            style=&quot;?android:attr/buttonBarStyle&quot;&gt;&#10;&#10;            &lt;Button&#10;                android:id=&quot;@+id/copyButton&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;@string/copy&quot;&#10;                style=&quot;?android:attr/buttonBarButtonStyle&quot;/&gt;&#10;&#10;            &lt;Button&#10;                android:id=&quot;@+id/teleportButton&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:layout_marginStart=&quot;8dp&quot;&#10;                android:text=&quot;@string/teleport&quot;&#10;                style=&quot;?android:attr/buttonBarButtonStyle&quot;/&gt;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/androidx.cardview.widget.CardView&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:background=&quot;?android:attr/selectableItemBackground&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle for reordering --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/drag_icon&quot;&#10;        android:layout_width=&quot;24dp&quot;&#10;        android:layout_height=&quot;24dp&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        android:contentDescription=&quot;Drag to reorder&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Icon Preview --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/button_icon&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:contentDescription=&quot;Button icon&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/drag_icon&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Name --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/button_name&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textColor=&quot;?android:attr/textColorPrimary&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/button_icon&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/visibility_switch&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Visibility Switch --&gt;&#10;    &lt;androidx.appcompat.widget.SwitchCompat&#10;        android:id=&quot;@+id/visibility_switch&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;320dp&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:background=&quot;@android:color/background_dark&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/drag_handle&quot;&#10;        android:layout_width=&quot;48dp&quot;&#10;        android:layout_height=&quot;48dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Drag handle&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/title&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:text=&quot;Customize Overlay&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/drag_handle&quot; /&gt;&#10;&#10;    &lt;!-- Close Button --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/close_customization_button&quot;&#10;        android:layout_width=&quot;36dp&quot;&#10;        android:layout_height=&quot;36dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Close&quot;&#10;        android:src=&quot;@drawable/close_24px&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/title&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;!-- Button Size Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Size:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_value&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;48dp&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;SeekBar&#10;        android:id=&quot;@+id/size_seekbar&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:max=&quot;64&quot;&#10;        android:min=&quot;32&quot;&#10;        android:progress=&quot;48&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;!-- Button Visibility Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/visibility_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Visibility:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_seekbar&quot; /&gt;&#10;&#10;    &lt;!-- RecyclerView for button customization --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/buttons_recycler_view&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:maxHeight=&quot;300dp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/visibility_label&quot; /&gt;&#10;&#10;    &lt;!-- Reset Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/reset_button&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Reset to Defaults&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/buttons_recycler_view&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>