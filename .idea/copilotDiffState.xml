<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/DeletedEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/DeletedEntry.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;&#10;/**&#10; * Represents a single record of a user-deleted invasion.&#10; * @property lat Latitude of the invasion (as shown in the feed at time of deletion)&#10; * @property lng Longitude of the invasion (as shown in the feed at time of deletion)&#10; * @property timestamp Epoch millis when the deletion was recorded&#10; */&#10;data class DeletedEntry(val lat: Double, val lng: Double, val timestamp: Long)&#10;&#10;/**&#10; * Repository for persisting and querying deleted invasions.&#10; *&#10; * Storage details:&#10; * - Backed by SharedPreferences using a string set. Each item is encoded as:&#10; *   &quot;lat,lng,timestamp&quot;.&#10; * - Using a Set prevents duplicate entries for the same encoded value.&#10; * - Data is lightweight and survives process death but is not intended for&#10; *   long-term analytics or multi-user sync.&#10; *&#10; * Limitations:&#10; * - Deletion identity is based on exact lat/lng string encoding. Minor&#10; *   coordinate rounding changes in source data could affect matching.&#10; * - Only coordinates and timestamp are stored (no name/type/source fields).&#10; */&#10;class DeletedInvasionsRepository(context: Context) {&#10;    // SharedPreferences file and key used to store the encoded deletions&#10;    private val prefs: SharedPreferences =&#10;        context.getSharedPreferences(&quot;deleted_invasions&quot;, Context.MODE_PRIVATE)&#10;    private val key = &quot;deleted_invasions_set&quot;&#10;&#10;    /**&#10;     * Record a deletion for the given invasion.&#10;     *&#10;     * Behavior:&#10;     * - Skips certain transient/derived invasion types (7, 8, 9) to avoid&#10;     *   persisting non-standard entries.&#10;     * - Persists an encoded entry of the form &quot;lat,lng,timestamp&quot;.&#10;     */&#10;    fun addDeletedInvasion(invasion: Invasion) {&#10;        // Ignore specific types deemed non-persistent&#10;        if (invasion.type == 8 || invasion.type == 9 || invasion.type == 7) return&#10;&#10;        val currentTime = System.currentTimeMillis()&#10;        val entry = &quot;${invasion.lat},${invasion.lng},$currentTime&quot;&#10;        val set = prefs.getStringSet(key, mutableSetOf())?.toMutableSet() ?: mutableSetOf()&#10;        set.add(entry) // Set semantics deduplicate identical entries&#10;        // edit {} from core-ktx applies the change atomically&#10;        prefs.edit { putStringSet(key, set) }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all deleted entries from storage, decoding them to DeletedEntry objects.&#10;     *&#10;     * Malformed entries are skipped defensively.&#10;     */&#10;    fun getDeletedEntries(): Set&lt;DeletedEntry&gt; {&#10;        val set = prefs.getStringSet(key, emptySet()) ?: emptySet()&#10;        return set.mapNotNull { entry -&gt;&#10;            val parts = entry.split(&quot;,&quot;)&#10;            if (parts.size &gt;= 3) {&#10;                try {&#10;                    val lat = parts[0].toDouble()&#10;                    val lng = parts[1].toDouble()&#10;                    val timestamp = parts[2].toLong()&#10;                    DeletedEntry(lat, lng, timestamp)&#10;                } catch (e: Exception) {&#10;                    // Skip any malformed or legacy entries&#10;                    null&#10;                }&#10;            } else null&#10;        }.toSet()&#10;    }&#10;&#10;    /**&#10;     * Check if an invasion was previously deleted by matching exact lat/lng.&#10;     * Note: relies on exact coordinate equality; small precision differences&#10;     * in source data may prevent a match.&#10;     */&#10;    fun isInvasionDeleted(invasion: Invasion): Boolean {&#10;        return getDeletedEntries().any { it.lat == invasion.lat &amp;&amp; it.lng == invasion.lng }&#10;    }&#10;&#10;    /**&#10;     * Count entries deleted within the last 24 hours (rolling window).&#10;     */&#10;    fun getDeletionCountLast24Hours(): Int {&#10;        val twentyFourHoursAgo = System.currentTimeMillis() - 24 * 60 * 60 * 1000&#10;        return getDeletedEntries().count { it.timestamp &gt;= twentyFourHoursAgo }&#10;    }&#10;&#10;    /**&#10;     * Remove all deletion records.&#10;     */&#10;    fun resetDeletedInvasions() {&#10;        prefs.edit { remove(key) }&#10;    }&#10;&#10;    /**&#10;     * Overwrite storage with the provided set of entries.&#10;     * Entries are re-encoded to the &quot;lat,lng,timestamp&quot; string form.&#10;     */&#10;    fun setDeletedEntries(entries: Set&lt;DeletedEntry&gt;) {&#10;        val stringSet = entries.map { &quot;${it.lat},${it.lng},${it.timestamp}&quot; }.toSet()&#10;        prefs.edit { putStringSet(key, stringSet) }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import com.google.gson.Gson&#10;&#10;/**&#10; * Represents a single record of a user-deleted invasion.&#10; * @property lat Latitude of the invasion at time of deletion&#10; * @property lng Longitude of the invasion at time of deletion&#10; * @property timestamp Epoch millis when the deletion was recorded&#10; * @property name Optional PokÃ©stop/invasion display name at time of deletion&#10; * @property source Optional source key from which this invasion was fetched&#10; * @property character Optional character ID associated with the invasion&#10; * @property type Optional invasion type ID&#10; */&#10;data class DeletedEntry(&#10;    val lat: Double,&#10;    val lng: Double,&#10;    val timestamp: Long,&#10;    val name: String? = null,&#10;    val source: String? = null,&#10;    val character: Int? = null,&#10;    val type: Int? = null,&#10;)&#10;&#10;/**&#10; * Repository for persisting and querying deleted invasions.&#10; *&#10; * Storage details:&#10; * - Backed by SharedPreferences using a string set.&#10; * - Entries are now encoded as JSON (safer for arbitrary strings like names).&#10; * - Backward-compatible: legacy entries encoded as &quot;lat,lng,timestamp&quot; are&#10; *   still parsed and represented as DeletedEntry with optional fields null.&#10; * - Using a Set prevents duplicate entries for the same encoded value.&#10; *&#10; * Limitations:&#10; * - Deletion identity is based on exact lat/lng equality when checking with&#10; *   isInvasionDeleted; small coordinate precision changes may prevent a match.&#10; */&#10;class DeletedInvasionsRepository(context: Context) {&#10;    private val prefs: SharedPreferences =&#10;        context.getSharedPreferences(&quot;deleted_invasions&quot;, Context.MODE_PRIVATE)&#10;    private val key = &quot;deleted_invasions_set&quot;&#10;&#10;    // Gson instance for JSON (de)serialization&#10;    private val gson = Gson()&#10;&#10;    /**&#10;     * Record a deletion for the given invasion.&#10;     *&#10;     * Behavior:&#10;     * - Skips certain transient/derived invasion types (7, 8, 9) to avoid&#10;     *   persisting non-standard entries.&#10;     * - Persists as JSON for robust storage of string fields.&#10;     */&#10;    fun addDeletedInvasion(invasion: Invasion) {&#10;        // Ignore specific types deemed non-persistent&#10;        if (invasion.type == 8 || invasion.type == 9 || invasion.type == 7) return&#10;&#10;        val entry = DeletedEntry(&#10;            lat = invasion.lat,&#10;            lng = invasion.lng,&#10;            timestamp = System.currentTimeMillis(),&#10;            name = invasion.name,&#10;            source = invasion.source,&#10;            character = invasion.character,&#10;            type = invasion.type&#10;        )&#10;        val encoded = gson.toJson(entry)&#10;&#10;        val set = prefs.getStringSet(key, mutableSetOf())?.toMutableSet() ?: mutableSetOf()&#10;        set.add(encoded) // Set semantics deduplicate identical entries&#10;        prefs.edit { putStringSet(key, set) }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all deleted entries from storage, decoding them to DeletedEntry objects.&#10;     *&#10;     * Supports both JSON (current) and legacy CSV (&quot;lat,lng,timestamp&quot;) formats.&#10;     * Malformed entries are skipped defensively.&#10;     */&#10;    fun getDeletedEntries(): Set&lt;DeletedEntry&gt; {&#10;        val set = prefs.getStringSet(key, emptySet()) ?: emptySet()&#10;        return set.mapNotNull { raw -&gt;&#10;            val entry = raw.trim()&#10;            try {&#10;                if (entry.startsWith(&quot;{&quot;)) {&#10;                    // Current JSON format&#10;                    gson.fromJson(entry, DeletedEntry::class.java)&#10;                } else {&#10;                    // Legacy CSV: lat,lng,timestamp&#10;                    val parts = entry.split(&quot;,&quot;)&#10;                    if (parts.size &gt;= 3) {&#10;                        val lat = parts[0].toDouble()&#10;                        val lng = parts[1].toDouble()&#10;                        val timestamp = parts[2].toLong()&#10;                        DeletedEntry(lat, lng, timestamp)&#10;                    } else null&#10;                }&#10;            } catch (_: Exception) {&#10;                // Skip malformed or legacy entries we cannot parse&#10;                null&#10;            }&#10;        }.toSet()&#10;    }&#10;&#10;    /**&#10;     * Check if an invasion was previously deleted by matching exact lat/lng.&#10;     * Note: relies on exact coordinate equality; small precision differences&#10;     * in source data may prevent a match.&#10;     */&#10;    fun isInvasionDeleted(invasion: Invasion): Boolean {&#10;        return getDeletedEntries().any { it.lat == invasion.lat &amp;&amp; it.lng == invasion.lng }&#10;    }&#10;&#10;    /**&#10;     * Count entries deleted within the last 24 hours (rolling window).&#10;     */&#10;    fun getDeletionCountLast24Hours(): Int {&#10;        val twentyFourHoursAgo = System.currentTimeMillis() - 24 * 60 * 60 * 1000&#10;        return getDeletedEntries().count { it.timestamp &gt;= twentyFourHoursAgo }&#10;    }&#10;&#10;    /**&#10;     * Remove all deletion records.&#10;     */&#10;    fun resetDeletedInvasions() {&#10;        prefs.edit { remove(key) }&#10;    }&#10;&#10;    /**&#10;     * Overwrite storage with the provided set of entries.&#10;     * Entries are encoded to JSON for storage.&#10;     */&#10;    fun setDeletedEntries(entries: Set&lt;DeletedEntry&gt;) {&#10;        val stringSet = entries.map { gson.toJson(it) }.toSet()&#10;        prefs.edit { putStringSet(key, stringSet) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Int,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.data&#13;&#10;&#13;&#10;data class ExportData(&#13;&#10;    val dataSources: Set&lt;String&gt;,&#13;&#10;    val enabledCharacters: Set&lt;Int&gt;,&#13;&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#13;&#10;    val enabledQuests: Set&lt;String&gt;,&#13;&#10;    val homeCoordinates: String,&#13;&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#13;&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#13;&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#13;&#10;    val activeRocketFilter: String,&#13;&#10;    val activeQuestFilter: String,&#13;&#10;    val overlayButtonSize: Int,&#13;&#10;    val overlayButtonOrder: List&lt;String&gt;,&#13;&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;    private val rootView: View&#10;    private val rootView: View&#10;    private val rootView: View&#10;&#10;    private val rootView: View&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#13;&#10;&#13;&#10;import android.os.Handler&#13;&#10;import android.os.Looper&#13;&#10;import android.util.Log&#13;&#10;import android.view.MotionEvent&#13;&#10;import android.view.View&#13;&#10;import android.view.WindowManager&#13;&#10;&#13;&#10;class DragTouchListener(&#13;&#10;    private val params: WindowManager.LayoutParams,&#13;&#10;    private val windowManager: WindowManager,&#13;&#10;    private val rootView: View,&#13;&#10;    private val onLongPress: (() -&gt; Unit)? = null&#13;&#10;) : View.OnTouchListener {&#13;&#10;&#13;&#10;    private var initialX = 0&#13;&#10;    private var initialY = 0&#13;&#10;    private var downRawX = 0f&#13;&#10;    private var downRawY = 0f&#13;&#10;    private var hasMoved = false&#13;&#10;&#13;&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#13;&#10;    private val longPressRunnable = Runnable {&#13;&#10;        if (!hasMoved) {&#13;&#10;            Log.d(&quot;DragTouch&quot;, &quot;Long press detected!&quot;)&#13;&#10;            onLongPress?.invoke()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        private const val LONG_PRESS_TIMEOUT = 500L // 500ms for long press&#13;&#10;        private const val MOVE_THRESHOLD = 10 // pixels&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#13;&#10;        when (event.action) {&#13;&#10;            MotionEvent.ACTION_DOWN -&gt; {&#13;&#10;                Log.d(&quot;DragTouch&quot;, &quot;DOWN at (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                initialX = params.x&#13;&#10;                initialY = params.y&#13;&#10;                downRawX = event.rawX&#13;&#10;                downRawY = event.rawY&#13;&#10;                hasMoved = false&#13;&#10;&#13;&#10;                // Start long press detection&#13;&#10;                longPressHandler.postDelayed(longPressRunnable, LONG_PRESS_TIMEOUT)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_MOVE -&gt; {&#13;&#10;                val deltaX = (event.rawX - downRawX).toInt()&#13;&#10;                val deltaY = (event.rawY - downRawY).toInt()&#13;&#10;&#13;&#10;                // Check if user has moved beyond threshold&#13;&#10;                if (Math.abs(deltaX) &gt; MOVE_THRESHOLD || Math.abs(deltaY) &gt; MOVE_THRESHOLD) {&#13;&#10;                    hasMoved = true&#13;&#10;                    longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;&#13;&#10;                    Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                    // Calculate desired new position&#13;&#10;                    val newX = initialX + deltaX&#13;&#10;                    val newY = initialY + deltaY&#13;&#10;&#13;&#10;                    // Get screen &amp; overlay dimensions&#13;&#10;                    val dm = rootView.resources.displayMetrics&#13;&#10;                    val maxX = dm.widthPixels - rootView.width&#13;&#10;                    val maxY = dm.heightPixels - rootView.height&#13;&#10;&#13;&#10;                    // Clamp to [0..max]&#13;&#10;                    params.x = newX.coerceIn(0, maxX)&#13;&#10;                    params.y = newY.coerceIn(0, maxY)&#13;&#10;&#13;&#10;                    // Apply update&#13;&#10;                    windowManager.updateViewLayout(rootView, params)&#13;&#10;                }&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#13;&#10;                // Cancel long press if finger is lifted&#13;&#10;                longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return false&#13;&#10;    }&#13;&#10;&#13;&#10;    /** Expose current overlay X (left) */&#13;&#10;    fun getCurrentParamsX(): Int = params.x&#13;&#10;&#13;&#10;    /** Expose current overlay Y (top) */&#13;&#10;    fun getCurrentParamsY(): Int = params.y&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;interface ItemTouchHelperAdapter {&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean&#10;}&#10;&#10;class ItemTouchHelperCallback(&#10;    private val adapter: ItemTouchHelperAdapter&#10;) : ItemTouchHelper.Callback() {&#10;&#10;    override fun isLongPressDragEnabled(): Boolean = false&#10;&#10;    override fun isItemViewSwipeEnabled(): Boolean = false&#10;&#10;    override fun getMovementFlags(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder&#10;    ): Int {&#10;        val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN&#10;        return makeMovementFlags(dragFlags, 0)&#10;    }&#10;&#10;    override fun onMove(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder,&#10;        target: RecyclerView.ViewHolder&#10;    ): Boolean {&#10;        return adapter.onItemMove(viewHolder.adapterPosition, target.adapterPosition)&#10;    }&#10;&#10;    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;        // Not implemented&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // All items can now be dragged&#10;            dragIcon.alpha = 1.0f&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;    }&#10;&#10;        return when (item.itemId) {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;PokÃ©mon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;PokÃ©mon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;PokÃ©mon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;PokÃ©mon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;PokÃ©mon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;PokÃ©mon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if itâs one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;PokÃ©mon Encounter&quot;, &quot;Mega Energy&quot;, &quot;PokÃ©mon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;PokÃ©mon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;PokÃ©mon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;PokÃ©mon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire âSpindaâ block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main âSpindaâ checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main âSpindaâ checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;â¶&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specificâform checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;â¼&quot; else &quot;â¶&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;        val refreshFiltersItem = menu.findItem(R.id.action_refresh_filters)&#10;&#10;        saveRocketItem?.isVisible = (currentFilterType == &quot;Rocket&quot;)&#10;        saveQuestItem?.isVisible  = (currentFilterType == &quot;Quest&quot;)&#10;        refreshFiltersItem?.isVisible = (currentFilterType == &quot;Quest&quot;)&#10;    }&#10;&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_save_rocket -&gt; {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;PokÃ©mon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;PokÃ©mon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;PokÃ©mon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;PokÃ©mon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;PokÃ©mon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;PokÃ©mon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if itâs one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;PokÃ©mon Encounter&quot;, &quot;Mega Energy&quot;, &quot;PokÃ©mon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;PokÃ©mon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;PokÃ©mon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;PokÃ©mon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire âSpindaâ block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main âSpindaâ checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main âSpindaâ checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;â¶&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specificâform checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;â¼&quot; else &quot;â¶&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/HomeFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.InvasionsAdapter&#10;import com.mints.projectgammatwo.viewmodels.HomeViewModel&#10;import androidx.core.net.toUri&#10;import androidx.core.view.MenuProvider&#10;import com.mints.projectgammatwo.data.DataMappings&#10;class HomeFragment : Fragment() {&#10;&#10;    private val viewModel: HomeViewModel by viewModels()&#10;    private lateinit var adapter: InvasionsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_home, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        requireActivity().addMenuProvider(object : MenuProvider {&#10;            override fun onCreateMenu(menu: Menu, menuInflater: MenuInflater) {&#10;                menuInflater.inflate(R.menu.rockets_nav_menu, menu)&#10;            }&#10;&#10;            override fun onMenuItemSelected(menuItem: MenuItem): Boolean {&#10;                return when (menuItem.itemId) {&#10;                    R.id.action_open_journal -&gt; {&#10;                        testGetDeletedInvasions()&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;        }, viewLifecycleOwner)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.invasionsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = InvasionsAdapter { invasion -&gt;&#10;            viewModel.deleteInvasion(invasion)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchInvasions()&#10;        }&#10;&#10;        viewModel.invasions.observe(viewLifecycleOwner) { invasions -&gt;&#10;            adapter.submitList(invasions)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            val filterSize = viewModel.currentFilterSize.value&#10;            if (filterSize == 0) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No rocket filters enabled. Please go to the filter tab to select characters.&quot;&#10;            } else if (invasions.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No invasions available. Please check your filters or change the data source in Settings.&quot;&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;        val deletedCountTextView = view.findViewById&lt;TextView&gt;(R.id.deletedCountText)&#10;        viewModel.deletedCount.observe(viewLifecycleOwner) { count -&gt;&#10;            deletedCountTextView.text = &quot;Battled in last 24h: $count&quot;&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchInvasions()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    private fun testGetDeletedInvasions() {&#10;        val deletedInvasions = viewModel.getDeletedInvasions()&#10;        deletedInvasions.forEach { deletedEntry -&gt;&#10;            val characterName = deletedEntry.character?.let {&#10;                DataMappings.characterNamesMap[it]&#10;            } ?: &quot;Unknown Character&quot;&#10;&#10;            val typeDescription = deletedEntry.type.let {&#10;                DataMappings.typeDescriptionsMap[it]&#10;            } ?: &quot;Unknown Type&quot;&#10;&#10;            Log.d(&quot;Test&quot;,&quot;DeletedInvasion: ${deletedEntry.name} from source ${deletedEntry.source}, Name: $characterName, Type: $typeDescription&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { adapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { adapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        adapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (adapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;invasions&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.InvasionsAdapter&#10;import com.mints.projectgammatwo.viewmodels.HomeViewModel&#10;import androidx.core.net.toUri&#10;import androidx.core.view.MenuProvider&#10;import com.mints.projectgammatwo.data.DataMappings&#10;class HomeFragment : Fragment() {&#10;&#10;    private val viewModel: HomeViewModel by viewModels()&#10;    private lateinit var adapter: InvasionsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_home, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        requireActivity().addMenuProvider(object : MenuProvider {&#10;            override fun onCreateMenu(menu: Menu, menuInflater: MenuInflater) {&#10;                menuInflater.inflate(R.menu.rockets_nav_menu, menu)&#10;            }&#10;&#10;            override fun onMenuItemSelected(menuItem: MenuItem): Boolean {&#10;                return when (menuItem.itemId) {&#10;                    R.id.action_open_journal -&gt; {&#10;                        testGetDeletedInvasions()&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;        }, viewLifecycleOwner)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.invasionsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = InvasionsAdapter { invasion -&gt;&#10;            viewModel.deleteInvasion(invasion)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchInvasions()&#10;        }&#10;&#10;        viewModel.invasions.observe(viewLifecycleOwner) { invasions -&gt;&#10;            adapter.submitList(invasions)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            val filterSize = viewModel.currentFilterSize.value&#10;            if (filterSize == 0) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.setText(R.string.no_rocket_filters_message)&#10;            } else if (invasions.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.setText(R.string.no_invasions_available_message)&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;        val deletedCountTextView = view.findViewById&lt;TextView&gt;(R.id.deletedCountText)&#10;        viewModel.deletedCount.observe(viewLifecycleOwner) { count -&gt;&#10;            deletedCountTextView.text = getString(R.string.battles_last_24h, count)&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchInvasions()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    private fun testGetDeletedInvasions() {&#10;        val deletedInvasions = viewModel.getDeletedInvasions()&#10;        deletedInvasions.forEach { deletedEntry -&gt;&#10;            val characterName = deletedEntry.character?.let {&#10;                DataMappings.characterNamesMap[it]&#10;            } ?: &quot;Unknown Character&quot;&#10;&#10;            val typeDescription = deletedEntry.type.let {&#10;                DataMappings.typeDescriptionsMap[it]&#10;            } ?: &quot;Unknown Type&quot;&#10;&#10;            Log.d(&quot;Test&quot;,&quot;DeletedInvasion: ${deletedEntry.name} from source ${deletedEntry.source}, Name: $characterName, Type: $typeDescription&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { adapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { adapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        adapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (adapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;invasions&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.setText(R.string.enable_overlay_permissions)&#10;        } else {&#10;            button.setText(R.string.enable_overlay)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/QuestsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/QuestsFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.VisitedQuestsPreferences&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.QuestsAdapter&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;import androidx.core.net.toUri&#10;&#10;&#10;class QuestsFragment : Fragment() {&#10;&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var questsCountText: TextView&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var questsAdapter: QuestsAdapter&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var questErrorHandler: TextView&#10;&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_quests, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        questsCountText = view.findViewById(R.id.questsCountText)&#10;        recyclerView = view.findViewById(R.id.questsRecyclerView)&#10;        questErrorHandler = view.findViewById(R.id.errorHandlerText)&#10;        questsAdapter = QuestsAdapter { quest: Quests.Quest -&gt;&#10;            questsViewModel.saveLastVisitedCoordinates(quest)&#10;&#10;            val questId = &quot;${quest.name}|${quest.lat}|${quest.lng}&quot;&#10;            val visitedPreferences = VisitedQuestsPreferences(requireContext())&#10;            visitedPreferences.addVisitedQuest(questId)&#10;            val currentList = questsAdapter.currentList.toMutableList()&#10;            currentList.remove(quest)&#10;            questsAdapter.submitList(currentList)&#10;            updateQuestsCount(currentList.size)&#10;        }&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = questsAdapter&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        setupScrollToTop()&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests: List&lt;Quests.Quest&gt; -&gt;&#10;            questsAdapter.submitList(quests)&#10;            updateQuestsCount(quests.size)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if(questsViewModel.filterSizeLiveData.value == 0) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.text = &quot;No quest filters enabled. Please go to the filter tab to filter quests.&quot;&#10;&#10;            } else if(quests.isEmpty()) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.text = &quot;No quests available. Please check your filters or change the data source in the Settings.&quot;&#10;            } else {&#10;                questErrorHandler.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;&#10;        }&#10;&#10;        questsViewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;&#10;&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            questsViewModel.fetchQuests()&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;        updateServiceButtonState(startServiceButton)&#10;&#10;        swipeRefresh.isRefreshing = true&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        questsAdapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        // Handle FAB click&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (questsAdapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        // Check if we have overlay permission&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            // We have permission, start service directly&#10;            serviceManager.startOverlayService(&quot;quests&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;&#10;    private fun updateQuestsCount(count: Int) {&#10;        questsCountText.text = &quot;Total Quests: $count&quot;&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.VisitedQuestsPreferences&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.QuestsAdapter&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;import androidx.core.net.toUri&#10;&#10;&#10;class QuestsFragment : Fragment() {&#10;&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var questsCountText: TextView&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var questsAdapter: QuestsAdapter&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var questErrorHandler: TextView&#10;&#10;    // Track listeners to properly unregister on view teardown&#10;    private var scrollListener: RecyclerView.OnScrollListener? = null&#10;    private var dataObserver: RecyclerView.AdapterDataObserver? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_quests, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        questsCountText = view.findViewById(R.id.questsCountText)&#10;        recyclerView = view.findViewById(R.id.questsRecyclerView)&#10;        questErrorHandler = view.findViewById(R.id.errorHandlerText)&#10;        questsAdapter = QuestsAdapter { quest: Quests.Quest -&gt;&#10;            questsViewModel.saveLastVisitedCoordinates(quest)&#10;&#10;            val questId = &quot;${quest.name}|${quest.lat}|${quest.lng}&quot;&#10;            val visitedPreferences = VisitedQuestsPreferences(requireContext())&#10;            visitedPreferences.addVisitedQuest(questId)&#10;            val currentList = questsAdapter.currentList.toMutableList()&#10;            currentList.remove(quest)&#10;            questsAdapter.submitList(currentList)&#10;            updateQuestsCount(currentList.size)&#10;        }&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = questsAdapter&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        setupScrollToTop()&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests: List&lt;Quests.Quest&gt; -&gt;&#10;            questsAdapter.submitList(quests)&#10;            updateQuestsCount(quests.size)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if(questsViewModel.filterSizeLiveData.value == 0) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.setText(R.string.no_quest_filters_message)&#10;&#10;            } else if(quests.isEmpty()) {&#10;                questErrorHandler.visibility = View.VISIBLE&#10;                questErrorHandler.setText(R.string.no_quests_available_message)&#10;            } else {&#10;                questErrorHandler.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;&#10;        }&#10;&#10;        questsViewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;            swipeRefresh.isRefreshing = false&#10;        }&#10;&#10;&#10;&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            questsViewModel.fetchQuests()&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;        updateServiceButtonState(startServiceButton)&#10;&#10;        swipeRefresh.isRefreshing = true&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        // Unregister listeners to avoid leaks and duplicate callbacks when the view is recreated&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        scrollListener = null&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        dataObserver = null&#10;        super.onDestroyView()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        // Remove existing listener if any (defensive in case of multiple calls)&#10;        scrollListener?.let { recyclerView.removeOnScrollListener(it) }&#10;        val newScrollListener = object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;        recyclerView.addOnScrollListener(newScrollListener)&#10;        scrollListener = newScrollListener&#10;&#10;        // Unregister previous observer if any, then add a new one tied to this view lifecycle&#10;        dataObserver?.let { questsAdapter.unregisterAdapterDataObserver(it) }&#10;        val newObserver = object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        }&#10;        questsAdapter.registerAdapterDataObserver(newObserver)&#10;        dataObserver = newObserver&#10;&#10;        // Handle FAB click&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.smoothScrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        // Hide when there's nothing to scroll or we are at the top&#10;        if (questsAdapter.itemCount == 0 || !recyclerView.canScrollVertically(-1)) {&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;        scrollToTopFab.show()&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        // Check if we have overlay permission&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            // We have permission, start service directly&#10;            serviceManager.startOverlayService(&quot;quests&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.setText(R.string.enable_overlay_permissions)&#10;        } else {&#10;            button.setText(R.string.enable_overlay)&#10;        }&#10;    }&#10;&#10;    private fun updateQuestsCount(count: Int) {&#10;        questsCountText.text = getString(R.string.total_quests, count)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.RaidsAdapter&#10;import com.mints.projectgammatwo.viewmodels.RaidsViewModel&#10;import androidx.core.net.toUri&#10;&#10;class RaidsFragment : Fragment() {&#10;&#10;    private val viewModel: RaidsViewModel by viewModels()&#10;    private lateinit var adapter: RaidsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_raids, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.raidsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = RaidsAdapter { raid -&gt;&#10;            viewModel.deleteRaid(raid)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchRaids()&#10;        }&#10;&#10;        viewModel.raidsLiveData.observe(viewLifecycleOwner) { raids -&gt;&#10;            adapter.submitList(raids)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if (raids.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No raids available. Please check your data sources in Settings.&quot;&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            if (errorMessage.isNotEmpty()) {&#10;                Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                swipeRefresh.isRefreshing = false&#10;            }&#10;        }&#10;&#10;        val raidsCountTextView = view.findViewById&lt;TextView&gt;(R.id.raidsCountText)&#10;        viewModel.raidsCountLiveData.observe(viewLifecycleOwner) { count -&gt;&#10;            raidsCountTextView.text = &quot;Total Raids: $count&quot;&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchRaids()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        })&#10;&#10;        adapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        })&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.scrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        val layoutManager = recyclerView.layoutManager as? LinearLayoutManager ?: return&#10;&#10;        if (adapter.itemCount == 0) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;No items, hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;&#10;        val firstVisibleItem = layoutManager.findFirstVisibleItemPosition()&#10;        Log.d(&#10;            &quot;FAB_DEBUG&quot;,&#10;            &quot;First visible item: $firstVisibleItem, Total items: ${adapter.itemCount}&quot;&#10;        )&#10;&#10;        if (firstVisibleItem != RecyclerView.NO_POSITION &amp;&amp; firstVisibleItem &gt; 2) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Showing FAB&quot;)&#10;            scrollToTopFab.show()&#10;        } else {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;        }&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;raids&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.edit&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.ExportData&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;        private const val KEY_FAVORITES = &quot;favorites_list&quot;&#10;        private const val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;        private const val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;        private const val SOURCE_NYC = &quot;NYC&quot;&#10;        private const val SOURCE_LONDON = &quot;LONDON&quot;&#10;        private const val SOURCE_SINGAPORE = &quot;Singapore&quot;&#10;        private const val SOURCE_VANCOUVER = &quot;VANCOUVER&quot;&#10;        private const val SOURCE_SYDNEY = &quot;SYDNEY&quot;&#10;&#10;        private const val FILTER_TYPE_ROCKET = &quot;Rocket&quot;&#10;        private const val FILTER_TYPE_QUEST = &quot;Quest&quot;&#10;    }&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(SOURCE_NYC)&#10;        checkboxLondon.isChecked = selectedSources.contains(SOURCE_LONDON)&#10;        checkboxSG.isChecked = selectedSources.contains(SOURCE_SINGAPORE)&#10;        checkboxVancouver.isChecked = selectedSources.contains(SOURCE_VANCOUVER)&#10;        checkboxSydney.isChecked = selectedSources.contains(SOURCE_SYDNEY)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(SOURCE_NYC)&#10;            if (checkboxLondon.isChecked) newSelection.add(SOURCE_LONDON)&#10;            if (checkboxSG.isChecked) newSelection.add(SOURCE_SINGAPORE)&#10;            if (checkboxVancouver.isChecked) newSelection.add(SOURCE_VANCOUVER)&#10;            if (checkboxSydney.isChecked) newSelection.add(SOURCE_SYDNEY)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(SOURCE_NYC)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit { putString(KEY_TELEPORT_METHOD, method) }&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val initialCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(initialCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = getString(R.string.home_coords_hint)&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), getString(R.string.home_coords_saved, coords), Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        getString(R.string.home_coords_invalid),&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Use latest saved value if available&#10;                    val previous = homeCoordinatesManager.getHomeCoordinatesString()&#10;                    if (previous.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(previous)) {&#10;                        homeCoordinates.setText(previous)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = getString(R.string.overlay_size_dp, currentSize)&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = getString(R.string.overlay_size_dp, progress)&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = getString(R.string.overlay_size_dp, defaultSize)&#10;&#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; getString(R.string.overlay_button_drag_handle)&#10;            &quot;close_button&quot; -&gt; getString(R.string.overlay_button_close)&#10;            &quot;right_button&quot; -&gt; getString(R.string.overlay_button_next)&#10;            &quot;left_button&quot; -&gt; getString(R.string.overlay_button_previous)&#10;            &quot;home_button&quot; -&gt; getString(R.string.overlay_button_home)&#10;            &quot;refresh_button&quot; -&gt; getString(R.string.overlay_button_refresh)&#10;            &quot;switch_modes&quot; -&gt; getString(R.string.overlay_button_switch_mode)&#10;            &quot;filter_tab&quot; -&gt; getString(R.string.overlay_button_filters)&#10;            &quot;favorites_tab&quot; -&gt; getString(R.string.overlay_button_favorites)&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        val deletedEntries = deletedRepo.getDeletedEntries()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Deleted entries count: ${deletedEntries.size}&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            // you used QUEST_SPINDA_PREFIX = &quot;spinda_&quot;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            deletedEntries = deletedEntries,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.settings_share_subject))&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, getString(R.string.settings_share_chooser_title)))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_export_failed, e.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        cancelButton.setOnClickListener { dialog.dismiss() }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), getString(R.string.settings_import_input_empty), Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit { putString(KEY_FAVORITES, gson.toJson(importData.favorites)) }&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.deletedEntries.size} deleted entries&quot;)&#10;            deletedRepo.setDeletedEntries(importData.deletedEntries)&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters (non-null in ExportData)&#10;            val rocketFilters = importData.savedRocketFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${rocketFilters.size} rocket filters to import&quot;)&#10;&#10;            // Clear existing filters first&#10;            val existingFilterNames = filterPreferences.listFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;            for (name in existingFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_ROCKET)&#10;            }&#10;&#10;            // Import the filters&#10;            for ((name, characters) in rocketFilters) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledCharacters(characters)&#10;                    filterPreferences.saveCurrentAsFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active rocket filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;            if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                rocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeRocketFilter, FILTER_TYPE_ROCKET)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Import saved quest filters (non-null in ExportData)&#10;            val questFilters = importData.savedQuestFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${questFilters.size} quest filters to import&quot;)&#10;&#10;            // Clear existing quest filters first&#10;            val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;            for (name in existingQuestFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_QUEST)&#10;            }&#10;&#10;            // Import the quest filters&#10;            for ((name, questIds) in questFilters) {&#10;                val questStrings = questIds.toSet() // already Set&lt;String&gt;&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                    val forms: Set&lt;String&gt; = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                    filterPreferences.saveEnabledSpindaForms(forms)&#10;                    filterPreferences.saveCurrentQuestFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active quest filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;            if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                questFilters.containsKey(importData.activeQuestFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeQuestFilter, FILTER_TYPE_QUEST)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Update UI checkboxes and overlay customization&#10;            checkboxNYC.isChecked = importData.dataSources.contains(SOURCE_NYC)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(SOURCE_LONDON)&#10;            checkboxSG.isChecked = importData.dataSources.contains(SOURCE_SINGAPORE)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(SOURCE_VANCOUVER)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(SOURCE_SYDNEY)&#10;&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_success), Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_failed, ex.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.edit&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.ExportData&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;        private const val KEY_FAVORITES = &quot;favorites_list&quot;&#10;        private const val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;        private const val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;        private const val SOURCE_NYC = &quot;NYC&quot;&#10;        private const val SOURCE_LONDON = &quot;LONDON&quot;&#10;        private const val SOURCE_SINGAPORE = &quot;Singapore&quot;&#10;        private const val SOURCE_VANCOUVER = &quot;VANCOUVER&quot;&#10;        private const val SOURCE_SYDNEY = &quot;SYDNEY&quot;&#10;&#10;        private const val FILTER_TYPE_ROCKET = &quot;Rocket&quot;&#10;        private const val FILTER_TYPE_QUEST = &quot;Quest&quot;&#10;    }&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(SOURCE_NYC)&#10;        checkboxLondon.isChecked = selectedSources.contains(SOURCE_LONDON)&#10;        checkboxSG.isChecked = selectedSources.contains(SOURCE_SINGAPORE)&#10;        checkboxVancouver.isChecked = selectedSources.contains(SOURCE_VANCOUVER)&#10;        checkboxSydney.isChecked = selectedSources.contains(SOURCE_SYDNEY)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(SOURCE_NYC)&#10;            if (checkboxLondon.isChecked) newSelection.add(SOURCE_LONDON)&#10;            if (checkboxSG.isChecked) newSelection.add(SOURCE_SINGAPORE)&#10;            if (checkboxVancouver.isChecked) newSelection.add(SOURCE_VANCOUVER)&#10;            if (checkboxSydney.isChecked) newSelection.add(SOURCE_SYDNEY)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(SOURCE_NYC)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit { putString(KEY_TELEPORT_METHOD, method) }&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val initialCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(initialCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = getString(R.string.home_coords_hint)&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), getString(R.string.home_coords_saved, coords), Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        getString(R.string.home_coords_invalid),&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Use latest saved value if available&#10;                    val previous = homeCoordinatesManager.getHomeCoordinatesString()&#10;                    if (previous.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(previous)) {&#10;                        homeCoordinates.setText(previous)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = getString(R.string.overlay_size_dp, currentSize)&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = getString(R.string.overlay_size_dp, progress)&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = getString(R.string.overlay_size_dp, defaultSize)&#10;&#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; getString(R.string.overlay_button_drag_handle)&#10;            &quot;close_button&quot; -&gt; getString(R.string.overlay_button_close)&#10;            &quot;right_button&quot; -&gt; getString(R.string.overlay_button_next)&#10;            &quot;left_button&quot; -&gt; getString(R.string.overlay_button_previous)&#10;            &quot;home_button&quot; -&gt; getString(R.string.overlay_button_home)&#10;            &quot;refresh_button&quot; -&gt; getString(R.string.overlay_button_refresh)&#10;            &quot;switch_modes&quot; -&gt; getString(R.string.overlay_button_switch_mode)&#10;            &quot;filter_tab&quot; -&gt; getString(R.string.overlay_button_filters)&#10;            &quot;favorites_tab&quot; -&gt; getString(R.string.overlay_button_favorites)&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.settings_share_subject))&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, getString(R.string.settings_share_chooser_title)))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_export_failed, e.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        cancelButton.setOnClickListener { dialog.dismiss() }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), getString(R.string.settings_import_input_empty), Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit { putString(KEY_FAVORITES, gson.toJson(importData.favorites)) }&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters (non-null in ExportData)&#10;            val rocketFilters = importData.savedRocketFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${rocketFilters.size} rocket filters to import&quot;)&#10;&#10;            // Clear existing filters first&#10;            val existingFilterNames = filterPreferences.listFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;            for (name in existingFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_ROCKET)&#10;            }&#10;&#10;            // Import the filters&#10;            for ((name, characters) in rocketFilters) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledCharacters(characters)&#10;                    filterPreferences.saveCurrentAsFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active rocket filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;            if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                rocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeRocketFilter, FILTER_TYPE_ROCKET)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Import saved quest filters (non-null in ExportData)&#10;            val questFilters = importData.savedQuestFilters&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Found ${questFilters.size} quest filters to import&quot;)&#10;&#10;            // Clear existing quest filters first&#10;            val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;            for (name in existingQuestFilterNames) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                filterPreferences.deleteFilter(name, FILTER_TYPE_QUEST)&#10;            }&#10;&#10;            // Import the quest filters&#10;            for ((name, questIds) in questFilters) {&#10;                val questStrings = questIds.toSet() // already Set&lt;String&gt;&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;                try {&#10;                    filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                    val forms: Set&lt;String&gt; = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                    filterPreferences.saveEnabledSpindaForms(forms)&#10;                    filterPreferences.saveCurrentQuestFilter(name)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Set active quest filter if it exists in the imported data&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;            if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                questFilters.containsKey(importData.activeQuestFilter)) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                try {&#10;                    filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                    // If active, also load it&#10;                    filterPreferences.loadFilter(importData.activeQuestFilter, FILTER_TYPE_QUEST)&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            // Update UI checkboxes and overlay customization&#10;            checkboxNYC.isChecked = importData.dataSources.contains(SOURCE_NYC)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(SOURCE_LONDON)&#10;            checkboxSG.isChecked = importData.dataSources.contains(SOURCE_SINGAPORE)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(SOURCE_VANCOUVER)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(SOURCE_SYDNEY)&#10;&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_success), Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Toast.makeText(requireContext(), getString(R.string.settings_import_failed, ex.message ?: &quot;Unknown error&quot;), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;QuestsViewModel&quot;, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(tag, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                val responses = deferredList.map { it.await() }&#10;&#10;                // Filter successful responses&#10;                val successfulResponses = responses.mapNotNull { (source, result) -&gt;&#10;                    result.getOrNull()?.let { response -&gt;&#10;                        Pair(source, response)&#10;                    }&#10;                }&#10;&#10;                // If no successful responses, handle the error state&#10;                if (successfulResponses.isEmpty()) {&#10;                    Log.w(tag, &quot;No successful API responses received&quot;)&#10;                    _raidsLiveData.postValue(emptyList())&#10;                    _raidsCountLiveData.postValue(0)&#10;                    _filterSizeLiveData.postValue(0)&#10;                    _error.postValue(&quot;Unable to fetch raids. Please check your connection.&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Process successful responses&#10;                val combinedRaids = successfulResponses.flatMap { (source, response) -&gt;&#10;                    response.body()?.raids?.map { raid -&gt;&#10;                        raid.copy(source = source)&#10;                    } ?: emptyList()&#10;                }.toMutableList()&#10;&#10;                // Filter raids (you might want to add filtering preferences similar to HomeViewModel)&#10;                val filteredRaids = combinedRaids&#10;                    .filter { raid -&gt;&#10;                        // Add any filtering logic here&#10;                        // For now, we'll include all raids&#10;                        true&#10;                    }&#10;                    .sortedBy { it.raid_start }&#10;                    .reversed()&#10;&#10;                // Update LiveData&#10;                _raidsLiveData.postValue(filteredRaids)&#10;                _raidsCountLiveData.postValue(filteredRaids.size)&#10;                _filterSizeLiveData.postValue(filteredRaids.size)&#10;&#10;                Log.d(tag, &quot;Successfully fetched raids from ${successfulResponses.size} sources. Total raids: ${filteredRaids.size}&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                e(tag, &quot;Error in fetchRaids&quot;, e)&#10;                _raidsLiveData.postValue(emptyList())&#10;                _raidsCountLiveData.postValue(0)&#10;                _filterSizeLiveData.postValue(0)&#10;                _error.postValue(&quot;An unexpected error occurred&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getRaids(): List&lt;Raid&gt;? {&#10;        return _raidsLiveData.value&#10;    }&#10;&#10;    // Method to handle raid deletion (if needed)&#10;    fun deleteRaid(raid: Raid) {&#10;        _raidsLiveData.value = _raidsLiveData.value?.toMutableList()?.apply { remove(raid) }&#10;        _raidsCountLiveData.value = _raidsLiveData.value?.size ?: 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmTitle&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import Hotspots&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Message --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmMessage&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;This will import all hotspot locations to your favorites. Do you want to continue?&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmTitle&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Cancel Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/cancelConfirmButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Cancel&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/confirmImportButton&quot; /&gt;&#10;&#10;    &lt;!-- Confirm Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/confirmImportButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/cancelConfirmButton&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:background=&quot;?android:attr/selectableItemBackground&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle for reordering --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/drag_icon&quot;&#10;        android:layout_width=&quot;24dp&quot;&#10;        android:layout_height=&quot;24dp&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        android:contentDescription=&quot;Drag to reorder&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Icon Preview --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/button_icon&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:contentDescription=&quot;Button icon&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/drag_icon&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Name --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/button_name&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textColor=&quot;?android:attr/textColorPrimary&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/button_icon&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/visibility_switch&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Visibility Switch --&gt;&#10;    &lt;androidx.appcompat.widget.SwitchCompat&#10;        android:id=&quot;@+id/visibility_switch&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;320dp&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:background=&quot;@android:color/background_dark&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/drag_handle&quot;&#10;        android:layout_width=&quot;48dp&quot;&#10;        android:layout_height=&quot;48dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Drag handle&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/title&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:text=&quot;Customize Overlay&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/drag_handle&quot; /&gt;&#10;&#10;    &lt;!-- Close Button --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/close_customization_button&quot;&#10;        android:layout_width=&quot;36dp&quot;&#10;        android:layout_height=&quot;36dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Close&quot;&#10;        android:src=&quot;@drawable/close_24px&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/title&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;!-- Button Size Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Size:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_value&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;48dp&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;SeekBar&#10;        android:id=&quot;@+id/size_seekbar&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:max=&quot;64&quot;&#10;        android:min=&quot;32&quot;&#10;        android:progress=&quot;48&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;!-- Button Visibility Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/visibility_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Visibility:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_seekbar&quot; /&gt;&#10;&#10;    &lt;!-- RecyclerView for button customization --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/buttons_recycler_view&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:maxHeight=&quot;300dp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/visibility_label&quot; /&gt;&#10;&#10;    &lt;!-- Reset Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/reset_button&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Reset to Defaults&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/buttons_recycler_view&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Gamma&lt;/string&gt;&#10;    &lt;string name=&quot;edit_favorite&quot;&gt;Edit Favorite\n&lt;/string&gt;&#10;    &lt;string name=&quot;discord_link&quot;&gt;&lt;![CDATA[&lt;a href=&quot;https://discord.gg/VP4mRsvXec&quot;&gt;Join our discord&lt;/a&gt;]]&gt;&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_icon&quot;&gt;Overlay icon\n&lt;/string&gt;&#10;    &lt;string name=&quot;accessibility_service_description&quot;&gt;Enables  overlay features&lt;/string&gt;&#10;    &lt;string name=&quot;refresh_quest_filters&quot;&gt;Refresh Quest Filters&lt;/string&gt;&#10;    &lt;string name=&quot;save_rocket_filter&quot;&gt;Save Rocket Filter&lt;/string&gt;&#10;    &lt;string name=&quot;save_quest_filter&quot;&gt;Save Quest Filter&lt;/string&gt;&#10;    &lt;string name=&quot;open_journal&quot;&gt;Open Journal&lt;/string&gt;&#10;    &lt;string name=&quot;no_rocket_filters_message&quot;&gt;No rocket filters enabled. Please go to the filter tab to select characters.&lt;/string&gt;&#10;    &lt;string name=&quot;no_invasions_available_message&quot;&gt;No invasions available. Please check your filters or change the data source in Settings.&lt;/string&gt;&#10;    &lt;string name=&quot;battles_last_24h&quot;&gt;Battled in last 24h: %1$d&lt;/string&gt;&#10;    &lt;string name=&quot;enable_overlay_permissions&quot;&gt;Enable Overlay Permissions&lt;/string&gt;&#10;    &lt;string name=&quot;enable_overlay&quot;&gt;Enable Overlay&lt;/string&gt;&#10;    &lt;string name=&quot;no_quest_filters_message&quot;&gt;No quest filters enabled. Please go to the filter tab to filter quests.&lt;/string&gt;&#10;    &lt;string name=&quot;no_quests_available_message&quot;&gt;No quests available. Please check your filters or change the data source in the Settings.&lt;/string&gt;&#10;    &lt;string name=&quot;total_quests&quot;&gt;Total Quests: %1$d&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Gamma&lt;/string&gt;&#10;    &lt;string name=&quot;edit_favorite&quot;&gt;Edit Favorite\n&lt;/string&gt;&#10;    &lt;string name=&quot;discord_link&quot;&gt;&lt;![CDATA[&lt;a href=&quot;https://discord.gg/VP4mRsvXec&quot;&gt;Join our discord&lt;/a&gt;]]&gt;&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_icon&quot;&gt;Overlay icon\n&lt;/string&gt;&#10;    &lt;string name=&quot;accessibility_service_description&quot;&gt;Enables  overlay features&lt;/string&gt;&#10;    &lt;string name=&quot;refresh_quest_filters&quot;&gt;Refresh Quest Filters&lt;/string&gt;&#10;    &lt;string name=&quot;save_rocket_filter&quot;&gt;Save Rocket Filter&lt;/string&gt;&#10;    &lt;string name=&quot;save_quest_filter&quot;&gt;Save Quest Filter&lt;/string&gt;&#10;    &lt;string name=&quot;open_journal&quot;&gt;Open Journal&lt;/string&gt;&#10;    &lt;string name=&quot;no_rocket_filters_message&quot;&gt;No rocket filters enabled. Please go to the filter tab to select characters.&lt;/string&gt;&#10;    &lt;string name=&quot;no_invasions_available_message&quot;&gt;No invasions available. Please check your filters or change the data source in Settings.&lt;/string&gt;&#10;    &lt;string name=&quot;battles_last_24h&quot;&gt;Battled in last 24h: %1$d&lt;/string&gt;&#10;    &lt;string name=&quot;enable_overlay_permissions&quot;&gt;Enable Overlay Permissions&lt;/string&gt;&#10;    &lt;string name=&quot;enable_overlay&quot;&gt;Enable Overlay&lt;/string&gt;&#10;    &lt;string name=&quot;no_quest_filters_message&quot;&gt;No quest filters enabled. Please go to the filter tab to filter quests.&lt;/string&gt;&#10;    &lt;string name=&quot;no_quests_available_message&quot;&gt;No quests available. Please check your filters or change the data source in the Settings.&lt;/string&gt;&#10;    &lt;string name=&quot;total_quests&quot;&gt;Total Quests: %1$d&lt;/string&gt;&#10;    &lt;string name=&quot;settings_share_subject&quot;&gt;Exported Settings&lt;/string&gt;&#10;    &lt;string name=&quot;settings_share_chooser_title&quot;&gt;Share Settings JSON&lt;/string&gt;&#10;    &lt;string name=&quot;settings_export_failed&quot;&gt;Failed to export settings: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;settings_import_input_empty&quot;&gt;Input cannot be empty&lt;/string&gt;&#10;    &lt;string name=&quot;settings_import_success&quot;&gt;Settings imported successfully&lt;/string&gt;&#10;    &lt;string name=&quot;settings_import_failed&quot;&gt;Failed to import settings: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;home_coords_hint&quot;&gt;Enter coords (e.g. 40.121, -32.121)&lt;/string&gt;&#10;    &lt;string name=&quot;home_coords_saved&quot;&gt;Coordinates saved: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;home_coords_invalid&quot;&gt;Invalid coordinates format. Use: Lat, Long (e.g., 40.7128, -74.0060)&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_size_dp&quot;&gt;%1$ddp&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_drag_handle&quot;&gt;Drag Handle&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_close&quot;&gt;Close&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_next&quot;&gt;Next&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_previous&quot;&gt;Previous&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_home&quot;&gt;Home&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_refresh&quot;&gt;Refresh&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_switch_mode&quot;&gt;Switch Mode&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_filters&quot;&gt;Filters&lt;/string&gt;&#10;    &lt;string name=&quot;overlay_button_favorites&quot;&gt;Favorites&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>