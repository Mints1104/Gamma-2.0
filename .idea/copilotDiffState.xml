<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/data/ExportData.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Float,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.data&#10;&#10;data class ExportData(&#10;    val dataSources: Set&lt;String&gt;,&#10;    val enabledCharacters: Set&lt;Int&gt;,&#10;    val favorites: List&lt;FavoriteLocation&gt;,&#10;    val deletedEntries: Set&lt;DeletedEntry&gt;,&#10;    val enabledQuests: Set&lt;String&gt;,&#10;    val homeCoordinates: String,&#10;    val savedRocketFilters: Map&lt;String, Set&lt;Int&gt;&gt;,&#10;    val savedQuestFilters: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val savedQuestSpindaForms: Map&lt;String, Set&lt;String&gt;&gt;,&#10;    val activeRocketFilter: String,&#10;    val activeQuestFilter: String,&#10;    val overlayButtonSize: Int,&#10;    val overlayButtonOrder: List&lt;String&gt;,&#10;    val overlayButtonVisibility: Map&lt;String, Boolean&gt;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/DragTouchListener.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import android.view.View&#10;import android.view.WindowManager&#10;&#10;class DragTouchListener(&#10;    private val params: WindowManager.LayoutParams,&#10;    private val windowManager: WindowManager,&#10;    private val rootView: View&#10;) : View.OnTouchListener {&#10;    private val rootView: View&#10;    private var initialY = 0&#10;    private var downRawX = 0f&#10;    private var downRawY = 0f&#10;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;                val newY = initialY + deltaY&#10;&#10;                // 2) get screen &amp; overlay dimensions&#10;                val dm = rootView.resources.displayMetrics&#10;                val maxX = dm.widthPixels  - rootView.width&#10;                val maxY = dm.heightPixels - rootView.height&#10;&#10;                // 3) clamp to [0..max]&#10;                params.x = newX.coerceIn(0, maxX)&#10;                return true&#10;            }&#10;        }&#10;                Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#10;                // 1) calculate desired new position&#10;        return false&#10;    }&#10;                val newX = initialX + deltaX&#10;                val newY = initialY + deltaY&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#13;&#10;&#13;&#10;import android.os.Handler&#13;&#10;import android.os.Looper&#13;&#10;import android.util.Log&#13;&#10;import android.view.MotionEvent&#13;&#10;import android.view.View&#13;&#10;import android.view.WindowManager&#13;&#10;&#13;&#10;class DragTouchListener(&#13;&#10;    private val params: WindowManager.LayoutParams,&#13;&#10;    private val windowManager: WindowManager,&#13;&#10;    private val rootView: View,&#13;&#10;    private val onLongPress: (() -&gt; Unit)? = null&#13;&#10;) : View.OnTouchListener {&#13;&#10;&#13;&#10;    private var initialX = 0&#13;&#10;    private var initialY = 0&#13;&#10;    private var downRawX = 0f&#13;&#10;    private var downRawY = 0f&#13;&#10;    private var hasMoved = false&#13;&#10;&#13;&#10;    private val longPressHandler = Handler(Looper.getMainLooper())&#13;&#10;    private val longPressRunnable = Runnable {&#13;&#10;        if (!hasMoved) {&#13;&#10;            Log.d(&quot;DragTouch&quot;, &quot;Long press detected!&quot;)&#13;&#10;            onLongPress?.invoke()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        private const val LONG_PRESS_TIMEOUT = 500L // 500ms for long press&#13;&#10;        private const val MOVE_THRESHOLD = 10 // pixels&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onTouch(view: View, event: MotionEvent): Boolean {&#13;&#10;        when (event.action) {&#13;&#10;            MotionEvent.ACTION_DOWN -&gt; {&#13;&#10;                Log.d(&quot;DragTouch&quot;, &quot;DOWN at (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                initialX = params.x&#13;&#10;                initialY = params.y&#13;&#10;                downRawX = event.rawX&#13;&#10;                downRawY = event.rawY&#13;&#10;                hasMoved = false&#13;&#10;&#13;&#10;                // Start long press detection&#13;&#10;                longPressHandler.postDelayed(longPressRunnable, LONG_PRESS_TIMEOUT)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_MOVE -&gt; {&#13;&#10;                val deltaX = (event.rawX - downRawX).toInt()&#13;&#10;                val deltaY = (event.rawY - downRawY).toInt()&#13;&#10;&#13;&#10;                // Check if user has moved beyond threshold&#13;&#10;                if (Math.abs(deltaX) &gt; MOVE_THRESHOLD || Math.abs(deltaY) &gt; MOVE_THRESHOLD) {&#13;&#10;                    hasMoved = true&#13;&#10;                    longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;&#13;&#10;                    Log.d(&quot;DragTouch&quot;, &quot;MOVE to (${event.rawX}, ${event.rawY})&quot;)&#13;&#10;                    // Calculate desired new position&#13;&#10;                    val newX = initialX + deltaX&#13;&#10;                    val newY = initialY + deltaY&#13;&#10;&#13;&#10;                    // Get screen &amp; overlay dimensions&#13;&#10;                    val dm = rootView.resources.displayMetrics&#13;&#10;                    val maxX = dm.widthPixels - rootView.width&#13;&#10;                    val maxY = dm.heightPixels - rootView.height&#13;&#10;&#13;&#10;                    // Clamp to [0..max]&#13;&#10;                    params.x = newX.coerceIn(0, maxX)&#13;&#10;                    params.y = newY.coerceIn(0, maxY)&#13;&#10;&#13;&#10;                    // Apply update&#13;&#10;                    windowManager.updateViewLayout(rootView, params)&#13;&#10;                }&#13;&#10;                return true&#13;&#10;            }&#13;&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#13;&#10;                // Cancel long press if finger is lifted&#13;&#10;                longPressHandler.removeCallbacks(longPressRunnable)&#13;&#10;                return true&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return false&#13;&#10;    }&#13;&#10;&#13;&#10;    /** Expose current overlay X (left) */&#13;&#10;    fun getCurrentParamsX(): Int = params.x&#13;&#10;&#13;&#10;    /** Expose current overlay Y (top) */&#13;&#10;    fun getCurrentParamsY(): Int = params.y&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/helpers/ItemTouchHelperCallback.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.helpers&#10;&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;interface ItemTouchHelperAdapter {&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean&#10;}&#10;&#10;class ItemTouchHelperCallback(&#10;    private val adapter: ItemTouchHelperAdapter&#10;) : ItemTouchHelper.Callback() {&#10;&#10;    override fun isLongPressDragEnabled(): Boolean = false&#10;&#10;    override fun isItemViewSwipeEnabled(): Boolean = false&#10;&#10;    override fun getMovementFlags(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder&#10;    ): Int {&#10;        val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN&#10;        return makeMovementFlags(dragFlags, 0)&#10;    }&#10;&#10;    override fun onMove(&#10;        recyclerView: RecyclerView,&#10;        viewHolder: RecyclerView.ViewHolder,&#10;        target: RecyclerView.ViewHolder&#10;    ): Boolean {&#10;        return adapter.onItemMove(viewHolder.adapterPosition, target.adapterPosition)&#10;    }&#10;&#10;    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;        // Not implemented&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/recyclerviews/OverlayCustomizationAdapter.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        // Don't allow moving drag_handle from first position&#10;        if (fromPosition == 0 || toPosition == 0) return false&#10;&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // Disable dragging for drag_handle (should always be first)&#10;            // Only make the DRAG ICON grey, not the button preview icon&#10;            dragIcon.alpha = if (position == 0) 0.3f else 1.0f&#10;&#10;            // Keep button icon at full opacity&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN &amp;&amp; position != 0) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.recyclerviews&#10;&#10;import android.view.LayoutInflater&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.widget.SwitchCompat&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import java.util.Collections&#10;&#10;data class OverlayButtonItem(&#10;    val id: String,&#10;    val name: String,&#10;    val iconResId: Int,&#10;    var isVisible: Boolean,&#10;    val isRequired: Boolean = false // Some buttons like drag_handle and close_button should always be visible&#10;)&#10;&#10;class OverlayCustomizationAdapter(&#10;    private val items: MutableList&lt;OverlayButtonItem&gt;,&#10;    private val onItemChanged: (List&lt;OverlayButtonItem&gt;) -&gt; Unit,&#10;    private val onStartDrag: (RecyclerView.ViewHolder) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;OverlayCustomizationAdapter.ButtonViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_overlay_button_customization, parent, false)&#10;        return ButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ButtonViewHolder, position: Int) {&#10;        holder.bind(items[position], position)&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;        Collections.swap(items, fromPosition, toPosition)&#10;        notifyItemMoved(fromPosition, toPosition)&#10;        onItemChanged(items)&#10;        return true&#10;    }&#10;&#10;    fun updateItems(newItems: List&lt;OverlayButtonItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    inner class ButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val dragIcon: ImageView = itemView.findViewById(R.id.drag_icon)&#10;        private val buttonIcon: ImageView = itemView.findViewById(R.id.button_icon)&#10;        private val buttonName: TextView = itemView.findViewById(R.id.button_name)&#10;        private val visibilitySwitch: SwitchCompat = itemView.findViewById(R.id.visibility_switch)&#10;&#10;        fun bind(item: OverlayButtonItem, position: Int) {&#10;            buttonIcon.setImageResource(item.iconResId)&#10;            buttonName.text = item.name&#10;            visibilitySwitch.isChecked = item.isVisible&#10;&#10;            // Disable switch for required buttons&#10;            visibilitySwitch.isEnabled = !item.isRequired&#10;&#10;            // All items can now be dragged&#10;            dragIcon.alpha = 1.0f&#10;            buttonIcon.alpha = 1.0f&#10;&#10;            visibilitySwitch.setOnCheckedChangeListener { _, isChecked -&gt;&#10;                item.isVisible = isChecked&#10;                onItemChanged(items)&#10;            }&#10;&#10;            dragIcon.setOnTouchListener { _, event -&gt;&#10;                if (event.action == MotionEvent.ACTION_DOWN) {&#10;                    onStartDrag(this)&#10;                    true&#10;                } else {&#10;                    false&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/services/OverlayService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/services/OverlayService.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.services&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.graphics.PixelFormat&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import android.view.ContextThemeWrapper&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE&#10;import android.view.WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL&#10;import android.view.WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH&#10;import android.view.WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;import android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;import android.view.WindowManager.LayoutParams.WRAP_CONTENT&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.PopupMenu&#10;import android.widget.SeekBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.edit&#10;import androidx.core.net.toUri&#10;import androidx.lifecycle.Observer&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentInvasionData&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoritesManager&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.Invasion&#10;import com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;import com.mints.projectgammatwo.helpers.DragTouchListener&#10;import com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter&#10;import com.mints.projectgammatwo.helpers.ItemTouchHelperCallback&#10;import com.mints.projectgammatwo.recyclerviews.FiltersRecyclerView&#10;import com.mints.projectgammatwo.recyclerviews.OverlayFavoritesAdapter&#10;import com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter&#10;import com.mints.projectgammatwo.recyclerviews.OverlayButtonItem&#10;import com.mints.projectgammatwo.viewmodels.HomeViewModel&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;enum class FilterSortOrder {&#10;    DEFAULT,&#10;    NAME&#10;}&#10;&#10;private const val PREF_FILTER_SORT_ORDER = &quot;filter_sort_order&quot;&#10;&#10;class OverlayService : Service() {&#10;    private lateinit var windowManager: WindowManager&#10;    private var overlayView: View? = null&#10;    private var currentIndex = 0&#10;    private val TAG = &quot;OverlayService&quot;&#10;    private var viewModel: HomeViewModel? = null&#10;    private var invasionsObserver: Observer&lt;List&lt;Invasion&gt;&gt;? = null&#10;    private var errorObserver: Observer&lt;String&gt;? = null&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;    private var favoritesOverlayView: View? = null&#10;    private var filterOverlayView: View? = null&#10;    private var isFavoritesVisible = false&#10;    private var isFilterVisible = false&#10;    private lateinit var favoritesAdapter: OverlayFavoritesAdapter&#10;    private lateinit var filtersAdapter: FiltersRecyclerView&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedInvasionsRepository: DeletedInvasionsRepository&#10;    private var currentMode = &quot;invasions&quot; // Default mode&#10;    private var currentSortOrder = FilterSortOrder.DEFAULT&#10;    private var currentX = 0&#10;    private var currentY = 100&#10;    private lateinit var dragTouchListener: DragTouchListener&#10;    private var currentFavoritesSortOrder: FilterSortOrder = FilterSortOrder.DEFAULT&#10;    private val PREF_FAVORITES_SORT_ORDER = &quot;favorites_sort_order&quot;&#10;    private lateinit var customizationManager: OverlayCustomizationManager&#10;    private var customizationOverlayView: View? = null&#10;    private var isCustomizationVisible = false&#10;    private lateinit var customizationAdapter: OverlayCustomizationAdapter&#10;    private var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;OverlayService&quot;&#10;        private const val NOTIFICATION_ID = 1001&#10;        private const val CHANNEL_ID = &quot;overlay_service_channel&quot;&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? {&#10;        return null // Not a bound service&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;Service onCreate&quot;)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Overlay Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            )&#10;            channel.description = &quot;Running the Pokemon GO invasion overlay&quot;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(this)&#10;        filterPreferences = FilterPreferences(this)&#10;        deletedInvasionsRepository = DeletedInvasionsRepository(this)&#10;        customizationManager = OverlayCustomizationManager(this)&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Invasion Overlay&quot;)&#10;            .setContentText(&quot;Overlay service is running&quot;)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        if (favorites.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Favorites loaded: ${favorites.size} items&quot;)&#10;        } else {&#10;            Log.d(TAG, &quot;No favorites found&quot;)&#10;        }&#10;&#10;        // Save overlay running state&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putBoolean(&quot;overlay_running&quot;, true).apply()&#10;    }&#10;&#10;    // Android 15 compatibility: Handle foreground service timeout&#10;    override fun onTimeout(startId: Int, fgsType: Int) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.VANILLA_ICE_CREAM) {&#10;            Log.w(TAG, &quot;Foreground service timeout reached for startId: $startId, fgsType: $fgsType&quot;)&#10;            // Clean up resources and stop the service&#10;            try {&#10;                cleanupOverlays()&#10;                stopSelf()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error during timeout cleanup: ${e.message}&quot;)&#10;                stopSelf() // Ensure we stop even if cleanup fails&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun cleanupOverlays() {&#10;        try {&#10;            overlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                overlayView = null&#10;            }&#10;            favoritesOverlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                favoritesOverlayView = null&#10;            }&#10;            filterOverlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                filterOverlayView = null&#10;            }&#10;            cleanupObservers()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during overlay cleanup: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Android 15 compatibility: Check if overlay is visible before starting foreground service&#10;    private fun isOverlayVisible(): Boolean {&#10;        return overlayView?.let { view -&gt;&#10;            view.windowVisibility == View.VISIBLE &amp;&amp; view.visibility == View.VISIBLE&#10;        } ?: false&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val mode = intent?.getStringExtra(&quot;mode&quot;).toString()&#10;        Log.d(TAG, &quot;Service onStartCommand with mode: $mode&quot;)&#10;&#10;        // Save the current mode&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putString(&quot;overlay_mode&quot;, mode).apply()&#10;&#10;        // Android 15 compatibility: Ensure overlay is visible for SYSTEM_ALERT_WINDOW compliance&#10;        if (overlayView == null) {&#10;            addOverlay(mode)&#10;            Log.d(TAG, &quot;Overlay re-added on onStartCommand with mode: $mode&quot;)&#10;        } else {&#10;            updateOverlayBasedOnMode(mode)&#10;            Log.d(TAG, &quot;Overlay updated in onStartCommand with mode: $mode&quot;)&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private fun addOverlay(mode: String) {&#10;        if (overlayView != null) return&#10;        overlayView = LayoutInflater.from(this).inflate(R.layout.overlay_layout, null)&#10;        val params = WindowManager.LayoutParams().apply {&#10;            width = WRAP_CONTENT&#10;            height = WRAP_CONTENT&#10;            type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                TYPE_APPLICATION_OVERLAY&#10;            else&#10;                TYPE_SYSTEM_ALERT&#10;            flags = FLAG_NOT_TOUCH_MODAL or FLAG_NOT_FOCUSABLE or FLAG_WATCH_OUTSIDE_TOUCH&#10;            format = PixelFormat.TRANSLUCENT&#10;            gravity = Gravity.TOP or Gravity.START&#10;            x = currentX&#10;            y = currentY&#10;        }&#10;        try {&#10;            windowManager.addView(overlayView, params)&#10;            Log.d(TAG, &quot;Overlay added successfully with mode: $mode&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error adding overlay: ${e.message}&quot;)&#10;            return&#10;        }&#10;        setupButtons(mode, params)&#10;        if (mode == &quot;quests&quot;) {&#10;            if (CurrentQuestData.currentQuests.isEmpty())&#10;                fetchQuests()&#10;        } else {&#10;            val invasions = CurrentInvasionData.currentInvasions&#10;            if (invasions.isEmpty())&#10;                fetchInvasions()&#10;        }&#10;    }&#10;&#10;    private fun setupButtons(mode: String, params: WindowManager.LayoutParams) {&#10;        val dragHandle = overlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;        val closeBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.close_button)&#10;        val rightBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.right_button)&#10;        val leftBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.left_button)&#10;        val homeBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.home_button)&#10;        val refreshBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.refresh_button)&#10;        val switchModesBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.switch_modes)&#10;        val favoritesButton = overlayView?.findViewById&lt;ImageButton&gt;(R.id.favorites_tab)&#10;        val filtersButton = overlayView?.findViewById&lt;ImageButton&gt;(R.id.filter_tab)&#10;&#10;        // Create DragTouchListener without long-press callback (no longer needed)&#10;        dragTouchListener = DragTouchListener(params, windowManager, overlayView!!)&#10;&#10;        switchModesBtn?.setImageResource(if (mode == &quot;quests&quot;) R.drawable.binoculars else R.drawable.team_rocket_logo)&#10;        if (dragHandle == null || closeBtn == null || rightBtn == null || leftBtn == null&#10;            || homeBtn == null || refreshBtn == null ||&#10;            switchModesBtn == null || favoritesButton == null || filtersButton == null) {&#10;            Log.e(TAG, &quot;One or more buttons not found in layout&quot;)&#10;            return&#10;        }&#10;&#10;        dragHandle.setOnTouchListener(dragTouchListener)&#10;&#10;        // Apply saved customization settings&#10;        applyCustomizationToOverlay()&#10;&#10;        closeBtn.setOnClickListener {&#10;            Log.d(TAG, &quot;Close button clicked&quot;)&#10;            showOverlayToast(&quot;Closing overlay&quot;)&#10;            try {&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;&#10;                stopForeground(STOP_FOREGROUND_REMOVE)&#10;                val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;                notificationManager.cancel(NOTIFICATION_ID)&#10;&#10;                stopSelf()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error removing view: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        homeBtn.setOnClickListener {&#10;            val coordinates = homeCoordinatesManager.getHomeCoordinates()&#10;            if(coordinates != null) {&#10;                val(latitude, longitude) = coordinates&#10;                launchHome(latitude,longitude)&#10;            } else {&#10;                Log.d(TAG, &quot;Home coordinates not set&quot;)&#10;                showOverlayToast(&quot;Home coordinates not set&quot;)&#10;            }&#10;        }&#10;&#10;        refreshBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                Log.d(TAG, &quot;Refresh button clicked in quests mode&quot;)&#10;                showOverlayToast(&quot;Refreshing quests...&quot;)&#10;                fetchQuests()&#10;            } else {&#10;                Log.d(TAG, &quot;Refresh button clicked in invasions mode&quot;)&#10;                showOverlayToast(&quot;Refreshing invasions...&quot;)&#10;                fetchInvasions()&#10;            }&#10;        }&#10;&#10;        switchModesBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                Log.d(TAG, &quot;Switching to invasions mode&quot;)&#10;                showOverlayToast(&quot;Switching to invasions mode&quot;)&#10;                currentX = dragTouchListener.getCurrentParamsX()&#10;                currentY = dragTouchListener.getCurrentParamsY()&#10;                currentMode = &quot;invasions&quot;&#10;&#10;                cleanupObservers()&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;                addOverlay(&quot;invasions&quot;)&#10;            } else {&#10;                showOverlayToast(&quot;Switching to quests mode&quot;)&#10;                Log.d(TAG, &quot;Switching to quests mode&quot;)&#10;                currentX = dragTouchListener.getCurrentParamsX()&#10;                currentY = dragTouchListener.getCurrentParamsY()&#10;                currentMode = &quot;quests&quot;&#10;&#10;                cleanupObservers()&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;                addOverlay(&quot;quests&quot;)&#10;            }&#10;        }&#10;&#10;        filtersButton.setOnClickListener {&#10;            showFiltersOverlay()&#10;        }&#10;&#10;        favoritesButton?.setOnClickListener {&#10;            showFavoritesOverlay()&#10;        }&#10;&#10;        rightBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                val currentQuests = CurrentQuestData.currentQuests&#10;                if (currentQuests.isEmpty()) {&#10;                    Log.d(TAG, &quot;No quests available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No quests available, fetching...&quot;)&#10;                    fetchQuests()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = (currentIndex + 1) % currentQuests.size&#10;                Log.d(TAG, &quot;Navigating to quest at index $currentIndex: ${currentQuests[currentIndex].lat}, ${currentQuests[currentIndex].lng}&quot;)&#10;                showOverlayToast( &quot;Teleporting to ${currentQuests[currentIndex].rewardsString}&quot;)&#10;                launchQuest(currentQuests[currentIndex])&#10;            } else {&#10;                val currentInvasions = CurrentInvasionData.currentInvasions&#10;                if (currentInvasions.isEmpty()) {&#10;                    Log.d(TAG, &quot;No invasions available, attempting to fetch...&quot;)&#10;                    fetchInvasions()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = (currentIndex + 1) % currentInvasions.size&#10;                Log.d(TAG, &quot;Navigating to invasion at index $currentIndex: ${currentInvasions[currentIndex].lat}, ${currentInvasions[currentIndex].lng}&quot;)&#10;                deletedInvasionsRepository.addDeletedInvasion(currentInvasions[currentIndex])&#10;                showOverlayToast(&quot;Teleporting to ${currentInvasions[currentIndex].characterName} \n Daily Limit: ${deletedInvasionsRepository.getDeletionCountLast24Hours()}/900&quot;)&#10;                launchMap(currentInvasions[currentIndex])&#10;            }&#10;        }&#10;&#10;        leftBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                val currentQuests = CurrentQuestData.currentQuests&#10;                if (currentQuests.isEmpty()) {&#10;                    Log.d(TAG, &quot;No quests available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No quests available, fetching...&quot;)&#10;                    fetchQuests()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = if (currentIndex - 1 &lt; 0) currentQuests.size - 1 else currentIndex - 1&#10;                showOverlayToast(&quot;Teleporting to ${currentQuests[currentIndex].name}&quot;)&#10;                launchQuest(currentQuests[currentIndex])&#10;            } else {&#10;                val currentInvasions = CurrentInvasionData.currentInvasions&#10;                if (currentInvasions.isEmpty()) {&#10;                    Log.d(TAG, &quot;No invasions available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No invasions available, fetching...&quot;)&#10;                    fetchInvasions()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = if (currentIndex - 1 &lt; 0) currentInvasions.size - 1 else currentIndex - 1&#10;                showOverlayToast(&quot;Teleporting to ${currentInvasions[currentIndex].characterName}&quot;)&#10;                launchMap(currentInvasions[currentIndex])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateOverlayBasedOnMode(mode: String) {&#10;        if (mode == &quot;quests&quot;) {&#10;            showOverlayToast(&quot;Updated: Quests mode&quot;)&#10;        } else {&#10;            showOverlayToast(&quot;Updated: Invasions mode&quot;)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayMessage(message: String) {&#10;        val statusText = overlayView?.findViewById&lt;TextView&gt;(R.id.status_text)&#10;        if (statusText != null) {&#10;            statusText.text = message&#10;            statusText.visibility = View.VISIBLE&#10;            Handler(Looper.getMainLooper()).postDelayed({&#10;                statusText.visibility = View.GONE&#10;            }, 3000)&#10;        } else {&#10;            Log.e(TAG, &quot;Status text view not found, falling back to toast&quot;)&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun fetchInvasions() {&#10;        Log.d(TAG, &quot;Fetching invasions...&quot;)&#10;        cleanupObservers()&#10;        viewModel = HomeViewModel(application)&#10;        invasionsObserver = Observer { invasions -&gt;&#10;            Log.d(TAG, &quot;Received ${invasions.size} invasions&quot;)&#10;            CurrentInvasionData.currentInvasions = invasions.toMutableList()&#10;            if (invasions.isNotEmpty()) {&#10;                showOverlayToast(&quot;Found ${invasions.size} invasions&quot;)&#10;                currentIndex = 0&#10;            } else {&#10;                showOverlayToast(&quot;No invasions found&quot;)&#10;            }&#10;            updateOverlayBasedOnMode(&quot;invasions&quot;)&#10;        }&#10;        errorObserver = Observer { errorMsg -&gt;&#10;            Log.e(TAG, &quot;Error fetching invasions: $errorMsg&quot;)&#10;            showOverlayToast(&quot;Error: $errorMsg&quot;)&#10;        }&#10;        viewModel?.invasions?.observeForever(invasionsObserver!!)&#10;        viewModel?.error?.observeForever(errorObserver!!)&#10;        viewModel?.fetchInvasions()&#10;    }&#10;&#10;    private fun fetchQuests() {&#10;        Log.d(TAG, &quot;Fetching quests...&quot;)&#10;&#10;        val questsViewModel = QuestsViewModel(application)&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    private fun launchHome(lat: Double, lng: Double) {&#10;        Log.d(TAG, &quot;Launching home with coords: $lat, $lng&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=$lat,$lng&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun launchMap(inv: Invasion) {&#10;        Log.d(TAG, &quot;Launching map with coords: ${inv.lat}, ${inv.lng}&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=${inv.lat},${inv.lng}&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun launchQuest(quest: com.mints.projectgammatwo.data.Quests.Quest) {&#10;        Log.d(TAG, &quot;Launching quest map with coords: ${quest.lat}, ${quest.lng}&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=${quest.lat},${quest.lng}&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun cleanupObservers() {&#10;        invasionsObserver?.let { observer -&gt;&#10;            viewModel?.invasions?.removeObserver(observer)&#10;        }&#10;        errorObserver?.let { observer -&gt;&#10;            viewModel?.error?.removeObserver(observer)&#10;        }&#10;        invasionsObserver = null&#10;        errorObserver = null&#10;        viewModel = null&#10;    }&#10;&#10;    private fun showOverlayToast(message: String) {&#10;        val toastOverlayView = LayoutInflater.from(this).inflate(R.layout.overlay_toast, null)&#10;        val toastText = toastOverlayView.findViewById&lt;TextView&gt;(R.id.toast_text)&#10;        toastText.text = message&#10;&#10;        val params = WindowManager.LayoutParams().apply {&#10;            width = WRAP_CONTENT&#10;            height = WRAP_CONTENT&#10;            type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                TYPE_APPLICATION_OVERLAY&#10;            else&#10;                TYPE_SYSTEM_ALERT&#10;            flags = FLAG_NOT_FOCUSABLE or&#10;                    FLAG_NOT_TOUCH_MODAL&#10;            format = PixelFormat.TRANSLUCENT&#10;            gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL&#10;            y = 100  // Distance from bottom&#10;        }&#10;&#10;        try {&#10;            windowManager.addView(toastOverlayView, params)&#10;            Handler(Looper.getMainLooper()).postDelayed({&#10;                try {&#10;                    windowManager.removeView(toastOverlayView)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error removing toast overlay: ${e.message}&quot;)&#10;                }&#10;            }, 1500)  // Show for 3 seconds&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error showing toast overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.d(TAG, &quot;Service onDestroy started&quot;)&#10;&#10;        // Properly stop foreground service&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {&#10;            stopForeground(STOP_FOREGROUND_REMOVE)&#10;        } else {&#10;            stopForeground(true)&#10;        }&#10;&#10;        // Cancel notification explicitly&#10;        val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.cancel(NOTIFICATION_ID)&#10;&#10;        cleanupObservers()&#10;        try {&#10;            if (overlayView != null) {&#10;                windowManager.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error on destroy: ${e.message}&quot;)&#10;        }&#10;        &#10;        // Clear overlay running state&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putBoolean(&quot;overlay_running&quot;, false).apply()&#10;        &#10;        Log.d(TAG, &quot;Service destroyed completely&quot;)&#10;    }&#10;&#10;    private fun setupFavoritesOverlay() {&#10;        // Inflate the favorites overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;&#10;        favoritesOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.favorites_overlay_layout, null)&#10;        // Set up RecyclerView&#10;        val recyclerView = favoritesOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.favorites_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize adapter&#10;        favoritesAdapter = OverlayFavoritesAdapter(&#10;            onTeleportFavorite = { favorite -&gt;&#10;                // Teleport to location&#10;                hideFilterOverlay()&#10;                val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;                showOverlayToast(&quot;Teleporting to ${favorite.name}&quot;)&#10;                Intent(Intent.ACTION_VIEW, url.toUri())&#10;                    .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;                    .also(::startActivity)&#10;            }&#10;        )&#10;&#10;        recyclerView?.adapter = favoritesAdapter&#10;&#10;        // Set up close button&#10;        favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_favorites_button)?.setOnClickListener {&#10;            hideFavoritesOverlay()&#10;        }&#10;&#10;        // Load favorites&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        favoritesAdapter.submitList(favorites)&#10;    }&#10;&#10;    private fun setupFiltersOverlay() {&#10;        // Inflate the filter overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;        filterOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.item_filters_overlay, null)&#10;&#10;        // Set up RecyclerView&#10;        val recyclerView = filterOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.filters_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize the adapter with a filter selection callback&#10;        filtersAdapter = FiltersRecyclerView { filterName -&gt;&#10;            Log.d(TAG, &quot;Filter selected: $filterName&quot;)&#10;            showOverlayToast(&quot;Applying filter: $filterName&quot;)&#10;            applyFilter(filterName)&#10;        }&#10;&#10;        recyclerView?.adapter = filtersAdapter&#10;&#10;        // Set up close button&#10;        filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_filter_button)?.setOnClickListener {&#10;            hideFiltersOverlay()&#10;        }&#10;    }&#10;&#10;    private fun setupOverflowMenu() {&#10;        val overflowButton = filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.overflow_menu_button)&#10;&#10;        overflowButton?.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(this, view)&#10;            popupMenu.menuInflater.inflate(R.menu.menu_filters_sort, popupMenu.menu)&#10;&#10;            // Check the currently active sort method&#10;            when (currentSortOrder) {&#10;                FilterSortOrder.DEFAULT -&gt; popupMenu.menu.findItem(R.id.sort_default).isChecked = true&#10;                FilterSortOrder.NAME -&gt; popupMenu.menu.findItem(R.id.sort_by_name).isChecked = true&#10;            }&#10;&#10;            popupMenu.setOnMenuItemClickListener { item -&gt;&#10;                when (item.itemId) {&#10;                    R.id.sort_default -&gt; {&#10;                        if (currentSortOrder != FilterSortOrder.DEFAULT) {&#10;                            currentSortOrder = FilterSortOrder.DEFAULT&#10;                            saveSortOrderPreference(FilterSortOrder.DEFAULT)&#10;                            loadFiltersByMode() // Reload filters with new sort order&#10;                        }&#10;                        true&#10;                    }&#10;                    R.id.sort_by_name -&gt; {&#10;                        if (currentSortOrder != FilterSortOrder.NAME) {&#10;                            currentSortOrder = FilterSortOrder.NAME&#10;                            saveSortOrderPreference(FilterSortOrder.NAME)&#10;                            loadFiltersByMode() // Reload filters with new sort order&#10;                        }&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;&#10;            popupMenu.show()&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: FilterSortOrder) {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        sharedPrefs.edit { putString(PREF_FILTER_SORT_ORDER, sortOrder.name) }&#10;    }&#10;&#10;    private fun loadSortOrderPreference() {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        val savedSortOrder = sharedPrefs.getString(PREF_FILTER_SORT_ORDER, FilterSortOrder.DEFAULT.name)&#10;        currentSortOrder = try {&#10;            FilterSortOrder.valueOf(savedSortOrder ?: FilterSortOrder.DEFAULT.name)&#10;        } catch (e: IllegalArgumentException) {&#10;            FilterSortOrder.DEFAULT&#10;        }&#10;    }&#10;&#10;&#10;    private fun showFiltersOverlay() {&#10;        if (filterOverlayView == null) {&#10;            setupFiltersOverlay()&#10;        }&#10;&#10;        // Load saved sort order preferences&#10;        loadSortOrderPreference()&#10;&#10;        // Setup the overflow menu&#10;        setupOverflowMenu()&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add filters overlay to window manager if not already added&#10;        if (filterOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;&#10;            val dragHandle = filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, filterOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(filterOverlayView, params)&#10;                isFilterVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing filters overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            // Just make it visible if already added&#10;            filterOverlayView?.visibility = View.VISIBLE&#10;            isFilterVisible = true&#10;        }&#10;&#10;        // Load the appropriate filter list based on current mode&#10;        loadFiltersByMode()&#10;    }&#10;&#10;    private fun loadFiltersByMode() {&#10;        val filterNames = if (currentMode == &quot;quests&quot;) {&#10;            // Load quest filter names&#10;            filterPreferences.listQuestFilterNames()&#10;        } else {&#10;            // Load invasion/rocket filter names&#10;            filterPreferences.listFilterNames()&#10;        }&#10;&#10;        // Apply sorting based on current sort order preference&#10;        val sortedFilters = when (currentSortOrder) {&#10;            FilterSortOrder.DEFAULT -&gt; filterNames.toMutableList()  // Convert to MutableList&#10;            FilterSortOrder.NAME -&gt; filterNames.sortedBy { it.lowercase() }.toMutableList()  // Sort and convert to MutableList&#10;        }&#10;&#10;        // Update the adapter with the filter names&#10;        filtersAdapter.submitList(sortedFilters)&#10;    }&#10;&#10;    private fun applyFilter(filterName: String) {&#10;        val filterType = if (currentMode == &quot;quests&quot;) &quot;Quest&quot; else &quot;Rocket&quot;&#10;&#10;        // Apply the filter using the FilterPreferences&#10;        filterPreferences.loadFilter(filterName, filterType)&#10;&#10;        // Show a toast message&#10;        showOverlayToast(&quot;Applied filter: $filterName&quot;)&#10;&#10;        // Hide the filter overlay&#10;        hideFiltersOverlay()&#10;&#10;        // Refresh data based on selected filter&#10;        if (currentMode == &quot;quests&quot;) {&#10;            fetchQuests()&#10;        } else {&#10;            fetchInvasions()&#10;        }&#10;    }&#10;&#10;    private fun hideFiltersOverlay() {&#10;        filterOverlayView?.visibility = View.GONE&#10;        isFilterVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun showFavoritesOverlay() {&#10;        if (favoritesOverlayView == null) {&#10;            setupFavoritesOverlay()&#10;        }&#10;&#10;        // Load saved sort order preferences&#10;        loadFavoritesSortOrderPreference()&#10;&#10;        // Setup the overflow menu&#10;        setupFavoritesOverflowMenu()&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add favorites overlay to window manager if not already added&#10;        if (favoritesOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;            val dragHandle = favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, favoritesOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(favoritesOverlayView, params)&#10;                isFavoritesVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing favorites overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            // Just make it visible if already added&#10;            favoritesOverlayView?.visibility = View.VISIBLE&#10;            isFavoritesVisible = true&#10;        }&#10;&#10;        // Load favorites with the appropriate sort order&#10;        loadFavoritesWithSort()&#10;    }&#10;&#10;    private fun setupFavoritesOverflowMenu() {&#10;        val overflowButton = favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.overflow_menu_button)&#10;&#10;        overflowButton?.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(this, view)&#10;            popupMenu.menuInflater.inflate(R.menu.overlay_favorites_menu, popupMenu.menu)&#10;&#10;            // Check the currently active sort method&#10;            when (currentFavoritesSortOrder) {&#10;                FilterSortOrder.DEFAULT -&gt; popupMenu.menu.findItem(R.id.sort_default).isChecked = true&#10;                FilterSortOrder.NAME -&gt; popupMenu.menu.findItem(R.id.sort_by_name).isChecked = true&#10;            }&#10;&#10;            popupMenu.setOnMenuItemClickListener { item -&gt;&#10;                when (item.itemId) {&#10;                    R.id.sort_default -&gt; {&#10;                        if (currentFavoritesSortOrder != FilterSortOrder.DEFAULT) {&#10;                            currentFavoritesSortOrder = FilterSortOrder.DEFAULT&#10;                            saveFavoritesSortOrderPreference(FilterSortOrder.DEFAULT)&#10;                            sortFavsByDefault()&#10;                        }&#10;                        true&#10;                    }&#10;                    R.id.sort_by_name -&gt; {&#10;                        if (currentFavoritesSortOrder != FilterSortOrder.NAME) {&#10;                            currentFavoritesSortOrder = FilterSortOrder.NAME&#10;                            saveFavoritesSortOrderPreference(FilterSortOrder.NAME)&#10;                            sortFavsByName()&#10;                        }&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;&#10;            popupMenu.show()&#10;        }&#10;    }&#10;&#10;    private fun saveFavoritesSortOrderPreference(sortOrder: FilterSortOrder) {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        sharedPrefs.edit { putString(PREF_FAVORITES_SORT_ORDER, sortOrder.name) }&#10;    }&#10;&#10;    private fun loadFavoritesSortOrderPreference() {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        val savedSortOrder = sharedPrefs.getString(PREF_FAVORITES_SORT_ORDER, FilterSortOrder.DEFAULT.name)&#10;        currentFavoritesSortOrder = try {&#10;            FilterSortOrder.valueOf(savedSortOrder ?: FilterSortOrder.DEFAULT.name)&#10;        } catch (e: IllegalArgumentException) {&#10;            FilterSortOrder.DEFAULT&#10;        }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        val sortedList = favorites.sortedBy { it.name }&#10;        favoritesAdapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        favoritesAdapter.submitList(favorites)&#10;    }&#10;&#10;    private fun loadFavoritesWithSort() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;&#10;        // Apply sorting based on current sort order preference&#10;        val sortedFavorites = when (currentFavoritesSortOrder) {&#10;            FilterSortOrder.DEFAULT -&gt; favorites&#10;            FilterSortOrder.NAME -&gt; favorites.sortedBy { it.name }&#10;        }&#10;&#10;        favoritesAdapter.submitList(sortedFavorites)&#10;    }&#10;&#10;    private fun hideFavoritesOverlay() {&#10;        favoritesOverlayView?.visibility = View.GONE&#10;        isFavoritesVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun setupCustomizationOverlay() {&#10;        // Inflate the customization overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;        customizationOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.overlay_customization_layout, null)&#10;&#10;        // Set up RecyclerView&#10;        val recyclerView = customizationOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize adapter with drag-to-reorder support&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        val buttonItems = buttonOrder.map { buttonId -&gt;&#10;            OverlayButtonItem(&#10;                id = buttonId,&#10;                name = getButtonDisplayName(buttonId),&#10;                iconResId = getButtonIcon(buttonId),&#10;                isVisible = buttonVisibility[buttonId] ?: true,&#10;                isRequired = buttonId == &quot;drag_handle&quot; || buttonId == &quot;close_button&quot;&#10;            )&#10;        }.toMutableList()&#10;&#10;        customizationAdapter = OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Save the new order and visibility&#10;                val newOrder = updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;&#10;                // Apply changes to main overlay&#10;                applyCustomizationToOverlay()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView?.adapter = customizationAdapter&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop&#10;        val callback = ItemTouchHelperCallback(object : ItemTouchHelperAdapter {&#10;            override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                return customizationAdapter.onItemMove(fromPosition, toPosition)&#10;            }&#10;        })&#10;        itemTouchHelper = ItemTouchHelper(callback)&#10;        itemTouchHelper?.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up size seekbar&#10;        val sizeSeekbar = customizationOverlayView?.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = customizationOverlayView?.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar?.progress = currentSize&#10;        sizeValue?.text = &quot;${currentSize}dp&quot;&#10;&#10;        sizeSeekbar?.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue?.text = &quot;${progress}dp&quot;&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                applyCustomizationToOverlay()&#10;                showOverlayToast(&quot;Button size updated&quot;)&#10;            }&#10;        })&#10;&#10;        // Set up reset button&#10;        customizationOverlayView?.findViewById&lt;Button&gt;(R.id.reset_button)?.setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            showOverlayToast(&quot;Reset to defaults&quot;)&#10;&#10;            // Reload the customization UI&#10;            hideCustomizationOverlay()&#10;            setupCustomizationOverlay()&#10;            showCustomizationOverlay()&#10;&#10;            // Apply to main overlay&#10;            applyCustomizationToOverlay()&#10;        }&#10;&#10;        // Set up close button&#10;        customizationOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_customization_button)?.setOnClickListener {&#10;            hideCustomizationOverlay()&#10;        }&#10;    }&#10;&#10;    private fun showCustomizationOverlay() {&#10;        if (customizationOverlayView == null) {&#10;            setupCustomizationOverlay()&#10;        }&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add customization overlay to window manager if not already added&#10;        if (customizationOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;&#10;            val dragHandle = customizationOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, customizationOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(customizationOverlayView, params)&#10;                isCustomizationVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing customization overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            customizationOverlayView?.visibility = View.VISIBLE&#10;            isCustomizationVisible = true&#10;        }&#10;    }&#10;&#10;    private fun hideCustomizationOverlay() {&#10;        customizationOverlayView?.visibility = View.GONE&#10;        isCustomizationVisible = false&#10;&#10;    private fun hideFilterOverlay() {&#10;        filterOverlayView?.visibility = View.GONE&#10;        isFilterVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun setupCustomizationOverlay() {&#10;        // Inflate the customization overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;        customizationOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.overlay_customization_layout, null)&#10;&#10;        // Set up RecyclerView&#10;        val recyclerView = customizationOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize adapter with drag-to-reorder support&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        val buttonItems = buttonOrder.map { buttonId -&gt;&#10;            OverlayButtonItem(&#10;                id = buttonId,&#10;                name = getButtonDisplayName(buttonId),&#10;                iconResId = getButtonIcon(buttonId),&#10;                isVisible = buttonVisibility[buttonId] ?: true,&#10;                isRequired = buttonId == &quot;drag_handle&quot; || buttonId == &quot;close_button&quot;&#10;            )&#10;        }.toMutableList()&#10;&#10;        customizationAdapter = OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Save the new order and visibility&#10;                val newOrder = updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;&#10;                // Apply changes to main overlay&#10;                applyCustomizationToOverlay()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView?.adapter = customizationAdapter&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop&#10;        val callback = ItemTouchHelperCallback(object : ItemTouchHelperAdapter {&#10;            override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                return customizationAdapter.onItemMove(fromPosition, toPosition)&#10;            }&#10;        })&#10;        itemTouchHelper = ItemTouchHelper(callback)&#10;        itemTouchHelper?.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up size seekbar&#10;        val sizeSeekbar = customizationOverlayView?.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = customizationOverlayView?.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar?.progress = currentSize&#10;        sizeValue?.text = &quot;${currentSize}dp&quot;&#10;&#10;        sizeSeekbar?.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue?.text = &quot;${progress}dp&quot;&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                applyCustomizationToOverlay()&#10;                showOverlayToast(&quot;Button size updated&quot;)&#10;            }&#10;        })&#10;&#10;        // Set up reset button&#10;        customizationOverlayView?.findViewById&lt;Button&gt;(R.id.reset_button)?.setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            showOverlayToast(&quot;Reset to defaults&quot;)&#10;&#10;            // Reload the customization UI&#10;            hideCustomizationOverlay()&#10;            setupCustomizationOverlay()&#10;            showCustomizationOverlay()&#10;&#10;            // Apply to main overlay&#10;            applyCustomizationToOverlay()&#10;        }&#10;&#10;        // Set up close button&#10;        customizationOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_customization_button)?.setOnClickListener {&#10;            hideCustomizationOverlay()&#10;        }&#10;    }&#10;&#10;    private fun showCustomizationOverlay() {&#10;        if (customizationOverlayView == null) {&#10;            setupCustomizationOverlay()&#10;        }&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add customization overlay to window manager if not already added&#10;        if (customizationOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;&#10;            val dragHandle = customizationOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, customizationOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(customizationOverlayView, params)&#10;                isCustomizationVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing customization overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            customizationOverlayView?.visibility = View.VISIBLE&#10;            isCustomizationVisible = true&#10;        }&#10;    }&#10;&#10;    private fun hideCustomizationOverlay() {&#10;        customizationOverlayView?.visibility = View.GONE&#10;        isCustomizationVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun applyCustomizationToOverlay() {&#10;        overlayView ?: return&#10;&#10;        val buttonSize = customizationManager.getButtonSize()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;&#10;        // Convert dp to pixels&#10;        val buttonSizePx = (buttonSize * resources.displayMetrics.density).toInt()&#10;&#10;        // Apply size and visibility to all buttons&#10;        val buttonMap = mapOf(&#10;            &quot;drag_handle&quot; to R.id.drag_handle,&#10;            &quot;close_button&quot; to R.id.close_button,&#10;            &quot;right_button&quot; to R.id.right_button,&#10;            &quot;left_button&quot; to R.id.left_button,&#10;            &quot;home_button&quot; to R.id.home_button,&#10;            &quot;refresh_button&quot; to R.id.refresh_button,&#10;            &quot;switch_modes&quot; to R.id.switch_modes,&#10;            &quot;filter_tab&quot; to R.id.filter_tab,&#10;            &quot;favorites_tab&quot; to R.id.favorites_tab&#10;        )&#10;&#10;        // Reorder buttons vertically based on saved order&#10;        var topMargin = 0&#10;        buttonOrder.forEach { buttonId -&gt;&#10;            val buttonViewId = buttonMap[buttonId]&#10;            if (buttonViewId != null) {&#10;                val button = overlayView?.findViewById&lt;ImageButton&gt;(buttonViewId)&#10;                button?.let {&#10;                    // Set size&#10;                    val layoutParams = it.layoutParams as android.widget.FrameLayout.LayoutParams&#10;                    layoutParams.width = buttonSizePx&#10;                    layoutParams.height = buttonSizePx&#10;                    layoutParams.topMargin = topMargin&#10;                    it.layoutParams = layoutParams&#10;&#10;                    // Set visibility&#10;                    val isVisible = buttonVisibility[buttonId] ?: true&#10;                    it.visibility = if (isVisible) View.VISIBLE else View.GONE&#10;&#10;                    // Increment top margin for next button (only if visible)&#10;                    if (isVisible) {&#10;                        topMargin += buttonSizePx + (2 * resources.displayMetrics.density).toInt() // 2dp spacing&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; &quot;Drag Handle&quot;&#10;            &quot;close_button&quot; -&gt; &quot;Close&quot;&#10;            &quot;right_button&quot; -&gt; &quot;Next&quot;&#10;            &quot;left_button&quot; -&gt; &quot;Previous&quot;&#10;            &quot;home_button&quot; -&gt; &quot;Home&quot;&#10;            &quot;refresh_button&quot; -&gt; &quot;Refresh&quot;&#10;            &quot;switch_modes&quot; -&gt; &quot;Switch Mode&quot;&#10;            &quot;filter_tab&quot; -&gt; &quot;Filters&quot;&#10;            &quot;favorites_tab&quot; -&gt; &quot;Favorites&quot;&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.services&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.graphics.PixelFormat&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import android.view.ContextThemeWrapper&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE&#10;import android.view.WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL&#10;import android.view.WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH&#10;import android.view.WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;import android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;import android.view.WindowManager.LayoutParams.WRAP_CONTENT&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.PopupMenu&#10;import android.widget.SeekBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.edit&#10;import androidx.core.net.toUri&#10;import androidx.lifecycle.Observer&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentInvasionData&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoritesManager&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.Invasion&#10;import com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;import com.mints.projectgammatwo.helpers.DragTouchListener&#10;import com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter&#10;import com.mints.projectgammatwo.helpers.ItemTouchHelperCallback&#10;import com.mints.projectgammatwo.recyclerviews.FiltersRecyclerView&#10;import com.mints.projectgammatwo.recyclerviews.OverlayFavoritesAdapter&#10;import com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter&#10;import com.mints.projectgammatwo.recyclerviews.OverlayButtonItem&#10;import com.mints.projectgammatwo.viewmodels.HomeViewModel&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;enum class FilterSortOrder {&#10;    DEFAULT,&#10;    NAME&#10;}&#10;&#10;private const val PREF_FILTER_SORT_ORDER = &quot;filter_sort_order&quot;&#10;&#10;class OverlayService : Service() {&#10;    private lateinit var windowManager: WindowManager&#10;    private var overlayView: View? = null&#10;    private var currentIndex = 0&#10;    private val TAG = &quot;OverlayService&quot;&#10;    private var viewModel: HomeViewModel? = null&#10;    private var invasionsObserver: Observer&lt;List&lt;Invasion&gt;&gt;? = null&#10;    private var errorObserver: Observer&lt;String&gt;? = null&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;    private var favoritesOverlayView: View? = null&#10;    private var filterOverlayView: View? = null&#10;    private var isFavoritesVisible = false&#10;    private var isFilterVisible = false&#10;    private lateinit var favoritesAdapter: OverlayFavoritesAdapter&#10;    private lateinit var filtersAdapter: FiltersRecyclerView&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedInvasionsRepository: DeletedInvasionsRepository&#10;    private var currentMode = &quot;invasions&quot; // Default mode&#10;    private var currentSortOrder = FilterSortOrder.DEFAULT&#10;    private var currentX = 0&#10;    private var currentY = 100&#10;    private lateinit var dragTouchListener: DragTouchListener&#10;    private var currentFavoritesSortOrder: FilterSortOrder = FilterSortOrder.DEFAULT&#10;    private val PREF_FAVORITES_SORT_ORDER = &quot;favorites_sort_order&quot;&#10;    private lateinit var customizationManager: OverlayCustomizationManager&#10;    private var customizationOverlayView: View? = null&#10;    private var isCustomizationVisible = false&#10;    private lateinit var customizationAdapter: OverlayCustomizationAdapter&#10;    private var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;OverlayService&quot;&#10;        private const val NOTIFICATION_ID = 1001&#10;        private const val CHANNEL_ID = &quot;overlay_service_channel&quot;&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? {&#10;        return null // Not a bound service&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;Service onCreate&quot;)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Overlay Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            )&#10;            channel.description = &quot;Running the Pokemon GO invasion overlay&quot;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(this)&#10;        filterPreferences = FilterPreferences(this)&#10;        deletedInvasionsRepository = DeletedInvasionsRepository(this)&#10;        customizationManager = OverlayCustomizationManager(this)&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Invasion Overlay&quot;)&#10;            .setContentText(&quot;Overlay service is running&quot;)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        if (favorites.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Favorites loaded: ${favorites.size} items&quot;)&#10;        } else {&#10;            Log.d(TAG, &quot;No favorites found&quot;)&#10;        }&#10;&#10;        // Save overlay running state&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putBoolean(&quot;overlay_running&quot;, true).apply()&#10;    }&#10;&#10;    // Android 15 compatibility: Handle foreground service timeout&#10;    override fun onTimeout(startId: Int, fgsType: Int) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.VANILLA_ICE_CREAM) {&#10;            Log.w(TAG, &quot;Foreground service timeout reached for startId: $startId, fgsType: $fgsType&quot;)&#10;            // Clean up resources and stop the service&#10;            try {&#10;                cleanupOverlays()&#10;                stopSelf()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error during timeout cleanup: ${e.message}&quot;)&#10;                stopSelf() // Ensure we stop even if cleanup fails&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun cleanupOverlays() {&#10;        try {&#10;            overlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                overlayView = null&#10;            }&#10;            favoritesOverlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                favoritesOverlayView = null&#10;            }&#10;            filterOverlayView?.let {&#10;                if (it.windowVisibility == View.VISIBLE) {&#10;                    windowManager.removeView(it)&#10;                }&#10;                filterOverlayView = null&#10;            }&#10;            cleanupObservers()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during overlay cleanup: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Android 15 compatibility: Check if overlay is visible before starting foreground service&#10;    private fun isOverlayVisible(): Boolean {&#10;        return overlayView?.let { view -&gt;&#10;            view.windowVisibility == View.VISIBLE &amp;&amp; view.visibility == View.VISIBLE&#10;        } ?: false&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val mode = intent?.getStringExtra(&quot;mode&quot;).toString()&#10;        Log.d(TAG, &quot;Service onStartCommand with mode: $mode&quot;)&#10;&#10;        // Save the current mode&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putString(&quot;overlay_mode&quot;, mode).apply()&#10;&#10;        // Android 15 compatibility: Ensure overlay is visible for SYSTEM_ALERT_WINDOW compliance&#10;        if (overlayView == null) {&#10;            addOverlay(mode)&#10;            Log.d(TAG, &quot;Overlay re-added on onStartCommand with mode: $mode&quot;)&#10;        } else {&#10;            updateOverlayBasedOnMode(mode)&#10;            Log.d(TAG, &quot;Overlay updated in onStartCommand with mode: $mode&quot;)&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private fun addOverlay(mode: String) {&#10;        if (overlayView != null) return&#10;        overlayView = LayoutInflater.from(this).inflate(R.layout.overlay_layout, null)&#10;        val params = WindowManager.LayoutParams().apply {&#10;            width = WRAP_CONTENT&#10;            height = WRAP_CONTENT&#10;            type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                TYPE_APPLICATION_OVERLAY&#10;            else&#10;                TYPE_SYSTEM_ALERT&#10;            flags = FLAG_NOT_TOUCH_MODAL or FLAG_NOT_FOCUSABLE or FLAG_WATCH_OUTSIDE_TOUCH&#10;            format = PixelFormat.TRANSLUCENT&#10;            gravity = Gravity.TOP or Gravity.START&#10;            x = currentX&#10;            y = currentY&#10;        }&#10;        try {&#10;            windowManager.addView(overlayView, params)&#10;            Log.d(TAG, &quot;Overlay added successfully with mode: $mode&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error adding overlay: ${e.message}&quot;)&#10;            return&#10;        }&#10;        setupButtons(mode, params)&#10;        if (mode == &quot;quests&quot;) {&#10;            if (CurrentQuestData.currentQuests.isEmpty())&#10;                fetchQuests()&#10;        } else {&#10;            val invasions = CurrentInvasionData.currentInvasions&#10;            if (invasions.isEmpty())&#10;                fetchInvasions()&#10;        }&#10;    }&#10;&#10;    private fun setupButtons(mode: String, params: WindowManager.LayoutParams) {&#10;        val dragHandle = overlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;        val closeBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.close_button)&#10;        val rightBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.right_button)&#10;        val leftBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.left_button)&#10;        val homeBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.home_button)&#10;        val refreshBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.refresh_button)&#10;        val switchModesBtn = overlayView?.findViewById&lt;ImageButton&gt;(R.id.switch_modes)&#10;        val favoritesButton = overlayView?.findViewById&lt;ImageButton&gt;(R.id.favorites_tab)&#10;        val filtersButton = overlayView?.findViewById&lt;ImageButton&gt;(R.id.filter_tab)&#10;&#10;        // Create DragTouchListener without long-press callback (no longer needed)&#10;        dragTouchListener = DragTouchListener(params, windowManager, overlayView!!)&#10;&#10;        switchModesBtn?.setImageResource(if (mode == &quot;quests&quot;) R.drawable.binoculars else R.drawable.team_rocket_logo)&#10;        if (dragHandle == null || closeBtn == null || rightBtn == null || leftBtn == null&#10;            || homeBtn == null || refreshBtn == null ||&#10;            switchModesBtn == null || favoritesButton == null || filtersButton == null) {&#10;            Log.e(TAG, &quot;One or more buttons not found in layout&quot;)&#10;            return&#10;        }&#10;&#10;        dragHandle.setOnTouchListener(dragTouchListener)&#10;&#10;        // Apply saved customization settings&#10;        applyCustomizationToOverlay()&#10;&#10;        closeBtn.setOnClickListener {&#10;            Log.d(TAG, &quot;Close button clicked&quot;)&#10;            showOverlayToast(&quot;Closing overlay&quot;)&#10;            try {&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;&#10;                stopForeground(STOP_FOREGROUND_REMOVE)&#10;                val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;                notificationManager.cancel(NOTIFICATION_ID)&#10;&#10;                stopSelf()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error removing view: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        homeBtn.setOnClickListener {&#10;            val coordinates = homeCoordinatesManager.getHomeCoordinates()&#10;            if(coordinates != null) {&#10;                val(latitude, longitude) = coordinates&#10;                launchHome(latitude,longitude)&#10;            } else {&#10;                Log.d(TAG, &quot;Home coordinates not set&quot;)&#10;                showOverlayToast(&quot;Home coordinates not set&quot;)&#10;            }&#10;        }&#10;&#10;        refreshBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                Log.d(TAG, &quot;Refresh button clicked in quests mode&quot;)&#10;                showOverlayToast(&quot;Refreshing quests...&quot;)&#10;                fetchQuests()&#10;            } else {&#10;                Log.d(TAG, &quot;Refresh button clicked in invasions mode&quot;)&#10;                showOverlayToast(&quot;Refreshing invasions...&quot;)&#10;                fetchInvasions()&#10;            }&#10;        }&#10;&#10;        switchModesBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                Log.d(TAG, &quot;Switching to invasions mode&quot;)&#10;                showOverlayToast(&quot;Switching to invasions mode&quot;)&#10;                currentX = dragTouchListener.getCurrentParamsX()&#10;                currentY = dragTouchListener.getCurrentParamsY()&#10;                currentMode = &quot;invasions&quot;&#10;&#10;                cleanupObservers()&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;                addOverlay(&quot;invasions&quot;)&#10;            } else {&#10;                showOverlayToast(&quot;Switching to quests mode&quot;)&#10;                Log.d(TAG, &quot;Switching to quests mode&quot;)&#10;                currentX = dragTouchListener.getCurrentParamsX()&#10;                currentY = dragTouchListener.getCurrentParamsY()&#10;                currentMode = &quot;quests&quot;&#10;&#10;                cleanupObservers()&#10;                if (overlayView != null) {&#10;                    windowManager.removeView(overlayView)&#10;                    overlayView = null&#10;                }&#10;                addOverlay(&quot;quests&quot;)&#10;            }&#10;        }&#10;&#10;        filtersButton.setOnClickListener {&#10;            showFiltersOverlay()&#10;        }&#10;&#10;        favoritesButton?.setOnClickListener {&#10;            showFavoritesOverlay()&#10;        }&#10;&#10;        rightBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                val currentQuests = CurrentQuestData.currentQuests&#10;                if (currentQuests.isEmpty()) {&#10;                    Log.d(TAG, &quot;No quests available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No quests available, fetching...&quot;)&#10;                    fetchQuests()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = (currentIndex + 1) % currentQuests.size&#10;                Log.d(TAG, &quot;Navigating to quest at index $currentIndex: ${currentQuests[currentIndex].lat}, ${currentQuests[currentIndex].lng}&quot;)&#10;                showOverlayToast( &quot;Teleporting to ${currentQuests[currentIndex].rewardsString}&quot;)&#10;                launchQuest(currentQuests[currentIndex])&#10;            } else {&#10;                val currentInvasions = CurrentInvasionData.currentInvasions&#10;                if (currentInvasions.isEmpty()) {&#10;                    Log.d(TAG, &quot;No invasions available, attempting to fetch...&quot;)&#10;                    fetchInvasions()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = (currentIndex + 1) % currentInvasions.size&#10;                Log.d(TAG, &quot;Navigating to invasion at index $currentIndex: ${currentInvasions[currentIndex].lat}, ${currentInvasions[currentIndex].lng}&quot;)&#10;                deletedInvasionsRepository.addDeletedInvasion(currentInvasions[currentIndex])&#10;                showOverlayToast(&quot;Teleporting to ${currentInvasions[currentIndex].characterName} \n Daily Limit: ${deletedInvasionsRepository.getDeletionCountLast24Hours()}/900&quot;)&#10;                launchMap(currentInvasions[currentIndex])&#10;            }&#10;        }&#10;&#10;        leftBtn.setOnClickListener {&#10;            if (mode == &quot;quests&quot;) {&#10;                val currentQuests = CurrentQuestData.currentQuests&#10;                if (currentQuests.isEmpty()) {&#10;                    Log.d(TAG, &quot;No quests available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No quests available, fetching...&quot;)&#10;                    fetchQuests()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = if (currentIndex - 1 &lt; 0) currentQuests.size - 1 else currentIndex - 1&#10;                showOverlayToast(&quot;Teleporting to ${currentQuests[currentIndex].name}&quot;)&#10;                launchQuest(currentQuests[currentIndex])&#10;            } else {&#10;                val currentInvasions = CurrentInvasionData.currentInvasions&#10;                if (currentInvasions.isEmpty()) {&#10;                    Log.d(TAG, &quot;No invasions available, attempting to fetch...&quot;)&#10;                    showOverlayToast(&quot;No invasions available, fetching...&quot;)&#10;                    fetchInvasions()&#10;                    return@setOnClickListener&#10;                }&#10;                currentIndex = if (currentIndex - 1 &lt; 0) currentInvasions.size - 1 else currentIndex - 1&#10;                showOverlayToast(&quot;Teleporting to ${currentInvasions[currentIndex].characterName}&quot;)&#10;                launchMap(currentInvasions[currentIndex])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateOverlayBasedOnMode(mode: String) {&#10;        if (mode == &quot;quests&quot;) {&#10;            showOverlayToast(&quot;Updated: Quests mode&quot;)&#10;        } else {&#10;            showOverlayToast(&quot;Updated: Invasions mode&quot;)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayMessage(message: String) {&#10;        val statusText = overlayView?.findViewById&lt;TextView&gt;(R.id.status_text)&#10;        if (statusText != null) {&#10;            statusText.text = message&#10;            statusText.visibility = View.VISIBLE&#10;            Handler(Looper.getMainLooper()).postDelayed({&#10;                statusText.visibility = View.GONE&#10;            }, 3000)&#10;        } else {&#10;            Log.e(TAG, &quot;Status text view not found, falling back to toast&quot;)&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun fetchInvasions() {&#10;        Log.d(TAG, &quot;Fetching invasions...&quot;)&#10;        cleanupObservers()&#10;        viewModel = HomeViewModel(application)&#10;        invasionsObserver = Observer { invasions -&gt;&#10;            Log.d(TAG, &quot;Received ${invasions.size} invasions&quot;)&#10;            CurrentInvasionData.currentInvasions = invasions.toMutableList()&#10;            if (invasions.isNotEmpty()) {&#10;                showOverlayToast(&quot;Found ${invasions.size} invasions&quot;)&#10;                currentIndex = 0&#10;            } else {&#10;                showOverlayToast(&quot;No invasions found&quot;)&#10;            }&#10;            updateOverlayBasedOnMode(&quot;invasions&quot;)&#10;        }&#10;        errorObserver = Observer { errorMsg -&gt;&#10;            Log.e(TAG, &quot;Error fetching invasions: $errorMsg&quot;)&#10;            showOverlayToast(&quot;Error: $errorMsg&quot;)&#10;        }&#10;        viewModel?.invasions?.observeForever(invasionsObserver!!)&#10;        viewModel?.error?.observeForever(errorObserver!!)&#10;        viewModel?.fetchInvasions()&#10;    }&#10;&#10;    private fun fetchQuests() {&#10;        Log.d(TAG, &quot;Fetching quests...&quot;)&#10;&#10;        val questsViewModel = QuestsViewModel(application)&#10;        questsViewModel.fetchQuests()&#10;    }&#10;&#10;    private fun launchHome(lat: Double, lng: Double) {&#10;        Log.d(TAG, &quot;Launching home with coords: $lat, $lng&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=$lat,$lng&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun launchMap(inv: Invasion) {&#10;        Log.d(TAG, &quot;Launching map with coords: ${inv.lat}, ${inv.lng}&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=${inv.lat},${inv.lng}&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun launchQuest(quest: com.mints.projectgammatwo.data.Quests.Quest) {&#10;        Log.d(TAG, &quot;Launching quest map with coords: ${quest.lat}, ${quest.lng}&quot;)&#10;        val url = &quot;https://ipogo.app/?coords=${quest.lat},${quest.lng}&quot;&#10;        Intent(Intent.ACTION_VIEW, url.toUri())&#10;            .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;            .also(::startActivity)&#10;    }&#10;&#10;    private fun cleanupObservers() {&#10;        invasionsObserver?.let { observer -&gt;&#10;            viewModel?.invasions?.removeObserver(observer)&#10;        }&#10;        errorObserver?.let { observer -&gt;&#10;            viewModel?.error?.removeObserver(observer)&#10;        }&#10;        invasionsObserver = null&#10;        errorObserver = null&#10;        viewModel = null&#10;    }&#10;&#10;    private fun showOverlayToast(message: String) {&#10;        val toastOverlayView = LayoutInflater.from(this).inflate(R.layout.overlay_toast, null)&#10;        val toastText = toastOverlayView.findViewById&lt;TextView&gt;(R.id.toast_text)&#10;        toastText.text = message&#10;&#10;        val params = WindowManager.LayoutParams().apply {&#10;            width = WRAP_CONTENT&#10;            height = WRAP_CONTENT&#10;            type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                TYPE_APPLICATION_OVERLAY&#10;            else&#10;                TYPE_SYSTEM_ALERT&#10;            flags = FLAG_NOT_FOCUSABLE or&#10;                    FLAG_NOT_TOUCH_MODAL&#10;            format = PixelFormat.TRANSLUCENT&#10;            gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL&#10;            y = 100  // Distance from bottom&#10;        }&#10;&#10;        try {&#10;            windowManager.addView(toastOverlayView, params)&#10;            Handler(Looper.getMainLooper()).postDelayed({&#10;                try {&#10;                    windowManager.removeView(toastOverlayView)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error removing toast overlay: ${e.message}&quot;)&#10;                }&#10;            }, 1500)  // Show for 3 seconds&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error showing toast overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.d(TAG, &quot;Service onDestroy started&quot;)&#10;&#10;        // Properly stop foreground service&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {&#10;            stopForeground(STOP_FOREGROUND_REMOVE)&#10;        } else {&#10;            stopForeground(true)&#10;        }&#10;&#10;        // Cancel notification explicitly&#10;        val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.cancel(NOTIFICATION_ID)&#10;&#10;        cleanupObservers()&#10;        try {&#10;            if (overlayView != null) {&#10;                windowManager.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error on destroy: ${e.message}&quot;)&#10;        }&#10;        &#10;        // Clear overlay running state&#10;        val sharedPrefs = getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        sharedPrefs.edit().putBoolean(&quot;overlay_running&quot;, false).apply()&#10;        &#10;        Log.d(TAG, &quot;Service destroyed completely&quot;)&#10;    }&#10;&#10;    private fun setupFavoritesOverlay() {&#10;        // Inflate the favorites overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;&#10;        favoritesOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.favorites_overlay_layout, null)&#10;        // Set up RecyclerView&#10;        val recyclerView = favoritesOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.favorites_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize adapter&#10;        favoritesAdapter = OverlayFavoritesAdapter(&#10;            onTeleportFavorite = { favorite -&gt;&#10;                // Teleport to location&#10;                hideFilterOverlay()&#10;                val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;                showOverlayToast(&quot;Teleporting to ${favorite.name}&quot;)&#10;                Intent(Intent.ACTION_VIEW, url.toUri())&#10;                    .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;                    .also(::startActivity)&#10;            }&#10;        )&#10;&#10;        recyclerView?.adapter = favoritesAdapter&#10;&#10;        // Set up close button&#10;        favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_favorites_button)?.setOnClickListener {&#10;            hideFavoritesOverlay()&#10;        }&#10;&#10;        // Load favorites&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        favoritesAdapter.submitList(favorites)&#10;    }&#10;&#10;    private fun setupFiltersOverlay() {&#10;        // Inflate the filter overlay layout&#10;        val contextThemeWrapper = ContextThemeWrapper(this, R.style.Theme_ProjectGamma2)&#10;        filterOverlayView = LayoutInflater.from(contextThemeWrapper)&#10;            .inflate(R.layout.item_filters_overlay, null)&#10;&#10;        // Set up RecyclerView&#10;        val recyclerView = filterOverlayView?.findViewById&lt;RecyclerView&gt;(R.id.filters_recycler_view)&#10;        recyclerView?.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Initialize the adapter with a filter selection callback&#10;        filtersAdapter = FiltersRecyclerView { filterName -&gt;&#10;            Log.d(TAG, &quot;Filter selected: $filterName&quot;)&#10;            showOverlayToast(&quot;Applying filter: $filterName&quot;)&#10;            applyFilter(filterName)&#10;        }&#10;&#10;        recyclerView?.adapter = filtersAdapter&#10;&#10;        // Set up close button&#10;        filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.close_filter_button)?.setOnClickListener {&#10;            hideFiltersOverlay()&#10;        }&#10;    }&#10;&#10;    private fun setupOverflowMenu() {&#10;        val overflowButton = filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.overflow_menu_button)&#10;&#10;        overflowButton?.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(this, view)&#10;            popupMenu.menuInflater.inflate(R.menu.menu_filters_sort, popupMenu.menu)&#10;&#10;            // Check the currently active sort method&#10;            when (currentSortOrder) {&#10;                FilterSortOrder.DEFAULT -&gt; popupMenu.menu.findItem(R.id.sort_default).isChecked = true&#10;                FilterSortOrder.NAME -&gt; popupMenu.menu.findItem(R.id.sort_by_name).isChecked = true&#10;            }&#10;&#10;            popupMenu.setOnMenuItemClickListener { item -&gt;&#10;                when (item.itemId) {&#10;                    R.id.sort_default -&gt; {&#10;                        if (currentSortOrder != FilterSortOrder.DEFAULT) {&#10;                            currentSortOrder = FilterSortOrder.DEFAULT&#10;                            saveSortOrderPreference(FilterSortOrder.DEFAULT)&#10;                            loadFiltersByMode() // Reload filters with new sort order&#10;                        }&#10;                        true&#10;                    }&#10;                    R.id.sort_by_name -&gt; {&#10;                        if (currentSortOrder != FilterSortOrder.NAME) {&#10;                            currentSortOrder = FilterSortOrder.NAME&#10;                            saveSortOrderPreference(FilterSortOrder.NAME)&#10;                            loadFiltersByMode() // Reload filters with new sort order&#10;                        }&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;&#10;            popupMenu.show()&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: FilterSortOrder) {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        sharedPrefs.edit { putString(PREF_FILTER_SORT_ORDER, sortOrder.name) }&#10;    }&#10;&#10;    private fun loadSortOrderPreference() {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        val savedSortOrder = sharedPrefs.getString(PREF_FILTER_SORT_ORDER, FilterSortOrder.DEFAULT.name)&#10;        currentSortOrder = try {&#10;            FilterSortOrder.valueOf(savedSortOrder ?: FilterSortOrder.DEFAULT.name)&#10;        } catch (e: IllegalArgumentException) {&#10;            FilterSortOrder.DEFAULT&#10;        }&#10;    }&#10;&#10;&#10;    private fun showFiltersOverlay() {&#10;        if (filterOverlayView == null) {&#10;            setupFiltersOverlay()&#10;        }&#10;&#10;        // Load saved sort order preferences&#10;        loadSortOrderPreference()&#10;&#10;        // Setup the overflow menu&#10;        setupOverflowMenu()&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add filters overlay to window manager if not already added&#10;        if (filterOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;&#10;            val dragHandle = filterOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, filterOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(filterOverlayView, params)&#10;                isFilterVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing filters overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            // Just make it visible if already added&#10;            filterOverlayView?.visibility = View.VISIBLE&#10;            isFilterVisible = true&#10;        }&#10;&#10;        // Load the appropriate filter list based on current mode&#10;        loadFiltersByMode()&#10;    }&#10;&#10;    private fun loadFiltersByMode() {&#10;        val filterNames = if (currentMode == &quot;quests&quot;) {&#10;            // Load quest filter names&#10;            filterPreferences.listQuestFilterNames()&#10;        } else {&#10;            // Load invasion/rocket filter names&#10;            filterPreferences.listFilterNames()&#10;        }&#10;&#10;        // Apply sorting based on current sort order preference&#10;        val sortedFilters = when (currentSortOrder) {&#10;            FilterSortOrder.DEFAULT -&gt; filterNames.toMutableList()  // Convert to MutableList&#10;            FilterSortOrder.NAME -&gt; filterNames.sortedBy { it.lowercase() }.toMutableList()  // Sort and convert to MutableList&#10;        }&#10;&#10;        // Update the adapter with the filter names&#10;        filtersAdapter.submitList(sortedFilters)&#10;    }&#10;&#10;    private fun applyFilter(filterName: String) {&#10;        val filterType = if (currentMode == &quot;quests&quot;) &quot;Quest&quot; else &quot;Rocket&quot;&#10;&#10;        // Apply the filter using the FilterPreferences&#10;        filterPreferences.loadFilter(filterName, filterType)&#10;&#10;        // Show a toast message&#10;        showOverlayToast(&quot;Applied filter: $filterName&quot;)&#10;&#10;        // Hide the filter overlay&#10;        hideFiltersOverlay()&#10;&#10;        // Refresh data based on selected filter&#10;        if (currentMode == &quot;quests&quot;) {&#10;            fetchQuests()&#10;        } else {&#10;            fetchInvasions()&#10;        }&#10;    }&#10;&#10;    private fun hideFiltersOverlay() {&#10;        filterOverlayView?.visibility = View.GONE&#10;        isFilterVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun showFavoritesOverlay() {&#10;        if (favoritesOverlayView == null) {&#10;            setupFavoritesOverlay()&#10;        }&#10;&#10;        // Load saved sort order preferences&#10;        loadFavoritesSortOrderPreference()&#10;&#10;        // Setup the overflow menu&#10;        setupFavoritesOverflowMenu()&#10;&#10;        // Hide main overlay first&#10;        overlayView?.visibility = View.GONE&#10;&#10;        // Add favorites overlay to window manager if not already added&#10;        if (favoritesOverlayView?.parent == null) {&#10;            val params = WindowManager.LayoutParams().apply {&#10;                width = WRAP_CONTENT&#10;                height = WRAP_CONTENT&#10;                type = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#10;                    TYPE_APPLICATION_OVERLAY&#10;                else&#10;                    TYPE_SYSTEM_ALERT&#10;                flags = FLAG_NOT_FOCUSABLE&#10;                format = PixelFormat.TRANSLUCENT&#10;                gravity = Gravity.CENTER&#10;            }&#10;            val dragHandle = favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.drag_handle)&#10;            dragHandle?.setOnTouchListener(DragTouchListener(params, windowManager, favoritesOverlayView!!))&#10;&#10;            try {&#10;                windowManager.addView(favoritesOverlayView, params)&#10;                isFavoritesVisible = true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error showing favorites overlay: ${e.message}&quot;)&#10;            }&#10;        } else {&#10;            // Just make it visible if already added&#10;            favoritesOverlayView?.visibility = View.VISIBLE&#10;            isFavoritesVisible = true&#10;        }&#10;&#10;        // Load favorites with the appropriate sort order&#10;        loadFavoritesWithSort()&#10;    }&#10;&#10;    private fun setupFavoritesOverflowMenu() {&#10;        val overflowButton = favoritesOverlayView?.findViewById&lt;ImageButton&gt;(R.id.overflow_menu_button)&#10;&#10;        overflowButton?.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(this, view)&#10;            popupMenu.menuInflater.inflate(R.menu.overlay_favorites_menu, popupMenu.menu)&#10;&#10;            // Check the currently active sort method&#10;            when (currentFavoritesSortOrder) {&#10;                FilterSortOrder.DEFAULT -&gt; popupMenu.menu.findItem(R.id.sort_default).isChecked = true&#10;                FilterSortOrder.NAME -&gt; popupMenu.menu.findItem(R.id.sort_by_name).isChecked = true&#10;            }&#10;&#10;            popupMenu.setOnMenuItemClickListener { item -&gt;&#10;                when (item.itemId) {&#10;                    R.id.sort_default -&gt; {&#10;                        if (currentFavoritesSortOrder != FilterSortOrder.DEFAULT) {&#10;                            currentFavoritesSortOrder = FilterSortOrder.DEFAULT&#10;                            saveFavoritesSortOrderPreference(FilterSortOrder.DEFAULT)&#10;                            sortFavsByDefault()&#10;                        }&#10;                        true&#10;                    }&#10;                    R.id.sort_by_name -&gt; {&#10;                        if (currentFavoritesSortOrder != FilterSortOrder.NAME) {&#10;                            currentFavoritesSortOrder = FilterSortOrder.NAME&#10;                            saveFavoritesSortOrderPreference(FilterSortOrder.NAME)&#10;                            sortFavsByName()&#10;                        }&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;&#10;            popupMenu.show()&#10;        }&#10;    }&#10;&#10;    private fun saveFavoritesSortOrderPreference(sortOrder: FilterSortOrder) {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        sharedPrefs.edit { putString(PREF_FAVORITES_SORT_ORDER, sortOrder.name) }&#10;    }&#10;&#10;    private fun loadFavoritesSortOrderPreference() {&#10;        val sharedPrefs = getSharedPreferences(&quot;app_preferences&quot;, MODE_PRIVATE)&#10;        val savedSortOrder = sharedPrefs.getString(PREF_FAVORITES_SORT_ORDER, FilterSortOrder.DEFAULT.name)&#10;        currentFavoritesSortOrder = try {&#10;            FilterSortOrder.valueOf(savedSortOrder ?: FilterSortOrder.DEFAULT.name)&#10;        } catch (e: IllegalArgumentException) {&#10;            FilterSortOrder.DEFAULT&#10;        }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        val sortedList = favorites.sortedBy { it.name }&#10;        favoritesAdapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;        favoritesAdapter.submitList(favorites)&#10;    }&#10;&#10;    private fun loadFavoritesWithSort() {&#10;        val favorites = FavoritesManager.getFavorites(this)&#10;&#10;        // Apply sorting based on current sort order preference&#10;        val sortedFavorites = when (currentFavoritesSortOrder) {&#10;            FilterSortOrder.DEFAULT -&gt; favorites&#10;            FilterSortOrder.NAME -&gt; favorites.sortedBy { it.name }&#10;        }&#10;&#10;        favoritesAdapter.submitList(sortedFavorites)&#10;    }&#10;&#10;    private fun hideFavoritesOverlay() {&#10;        favoritesOverlayView?.visibility = View.GONE&#10;        isFavoritesVisible = false&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun hideFilterOverlay() {&#10;        filterOverlayView?.visibility = View.GONE&#10;        isFilterVisible = false&#10;&#10;&#10;        // Show main overlay again&#10;        overlayView?.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun applyCustomizationToOverlay() {&#10;        overlayView ?: return&#10;&#10;        val buttonSize = customizationManager.getButtonSize()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;&#10;        // Convert dp to pixels&#10;        val buttonSizePx = (buttonSize * resources.displayMetrics.density).toInt()&#10;&#10;        // Apply size and visibility to all buttons&#10;        val buttonMap = mapOf(&#10;            &quot;drag_handle&quot; to R.id.drag_handle,&#10;            &quot;close_button&quot; to R.id.close_button,&#10;            &quot;right_button&quot; to R.id.right_button,&#10;            &quot;left_button&quot; to R.id.left_button,&#10;            &quot;home_button&quot; to R.id.home_button,&#10;            &quot;refresh_button&quot; to R.id.refresh_button,&#10;            &quot;switch_modes&quot; to R.id.switch_modes,&#10;            &quot;filter_tab&quot; to R.id.filter_tab,&#10;            &quot;favorites_tab&quot; to R.id.favorites_tab&#10;        )&#10;&#10;        // Reorder buttons vertically based on saved order&#10;        var topMargin = 0&#10;        buttonOrder.forEach { buttonId -&gt;&#10;            val buttonViewId = buttonMap[buttonId]&#10;            if (buttonViewId != null) {&#10;                val button = overlayView?.findViewById&lt;ImageButton&gt;(buttonViewId)&#10;                button?.let {&#10;                    // Set size&#10;                    val layoutParams = it.layoutParams as android.widget.FrameLayout.LayoutParams&#10;                    layoutParams.width = buttonSizePx&#10;                    layoutParams.height = buttonSizePx&#10;                    layoutParams.topMargin = topMargin&#10;                    it.layoutParams = layoutParams&#10;&#10;                    // Set visibility&#10;                    val isVisible = buttonVisibility[buttonId] ?: true&#10;                    it.visibility = if (isVisible) View.VISIBLE else View.GONE&#10;&#10;                    // Increment top margin for next button (only if visible)&#10;                    if (isVisible) {&#10;                        topMargin += buttonSizePx + (2 * resources.displayMetrics.density).toInt() // 2dp spacing&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; &quot;Drag Handle&quot;&#10;            &quot;close_button&quot; -&gt; &quot;Close&quot;&#10;            &quot;right_button&quot; -&gt; &quot;Next&quot;&#10;            &quot;left_button&quot; -&gt; &quot;Previous&quot;&#10;            &quot;home_button&quot; -&gt; &quot;Home&quot;&#10;            &quot;refresh_button&quot; -&gt; &quot;Refresh&quot;&#10;            &quot;switch_modes&quot; -&gt; &quot;Switch Mode&quot;&#10;            &quot;filter_tab&quot; -&gt; &quot;Filters&quot;&#10;            &quot;favorites_tab&quot; -&gt; &quot;Favorites&quot;&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FavoritesFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FavoritesFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.ClipData&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.view.*&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.coordinatorlayout.widget.CoordinatorLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.recyclerviews.FavoritesAdapter&#10;import java.util.Collections&#10;import androidx.core.content.edit&#10;&#10;private const val PREFS_NAME = &quot;FavoritesPrefs&quot;&#10;private const val SORT_ORDER_KEY = &quot;sort_order&quot;&#10;private const val SORT_ORDER_NAME = &quot;name&quot;&#10;private const val SORT_ORDER_DEFAULT = &quot;default&quot;&#10;&#10;&#10;class FavoritesFragment : Fragment(), FavoriteDialogFragment.FavoriteDialogListener {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: FavoritesAdapter&#10;    private lateinit var addFavoriteFab: View&#10;    private var favoritesList = mutableListOf&lt;FavoriteLocation&gt;()&#10;    private val gson = Gson()&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val FAVORITES_SORTED = &quot;favorites_sorted&quot;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val view = inflater.inflate(R.layout.fragment_favorites, container, false)&#10;        recyclerView = view.findViewById(R.id.favoritesRecyclerView)&#10;        addFavoriteFab = view.findViewById(R.id.addFavoriteFab)&#10;        return view&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        adapter = FavoritesAdapter(&#10;            onDeleteFavorite = { favorite -&gt; deleteFavorite(favorite) },&#10;            onEditFavorite = { favorite, position -&gt; showEditFavoriteDialog(favorite, position) },&#10;            onCopyFavorite = { favorite -&gt; copyFavorite(favorite) },&#10;            onTeleportFavorite = { favorite -&gt; teleportToFavorite(favorite) }&#10;        )&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        loadFavorites()&#10;&#10;&#10;&#10;        addFavoriteFab.setOnClickListener {&#10;            showAddFavoriteDialog()&#10;        }&#10;        val itemTouchHelper = ItemTouchHelper(itemTouchHelperCallback)&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;    }&#10;&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.favorites_menu, menu)&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.menu_import_favorites -&gt; {&#10;                showImportFavoritesDialog()&#10;                true&#10;            }&#10;            R.id.action_sortByName -&gt; {&#10;                saveSortOrderPreference(SORT_ORDER_NAME)&#10;                sortFavsByName()&#10;                true&#10;            }&#10;&#10;            R.id.action_sortByDefault -&gt; {&#10;                sortFavsByDefault()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: String) {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { putString(SORT_ORDER_KEY, sortOrder) }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val sortedList = favoritesList.toMutableList().apply {&#10;            sortBy { it.name }&#10;        }&#10;        adapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        loadFavorites()&#10;    }&#10;&#10;&#10;&#10;    private fun loadSortOrderPreference(): String {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return prefs.getString(SORT_ORDER_KEY, SORT_ORDER_DEFAULT) ?: SORT_ORDER_DEFAULT&#10;    }&#10;&#10;    private fun applySavedSortOrder() {&#10;        when (loadSortOrderPreference()) {&#10;            SORT_ORDER_NAME -&gt; sortFavsByName()&#10;            SORT_ORDER_DEFAULT -&gt; sortFavsByDefault()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing favorites via JSON.&#10;     */&#10;    private fun showImportFavoritesDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_favorites, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importFavorites(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports favorites from the provided JSON string.&#10;     */&#10;    private fun importFavorites(jsonString: String) {&#10;        try {&#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            // Merge imported favorites with the current list, avoiding duplicates.&#10;            for (fav in importedFavorites) {&#10;                if (!favoritesList.any { it.lat == fav.lat &amp;&amp; it.lng == fav.lng &amp;&amp; it.name == fav.name }) {&#10;                    favoritesList.add(fav)&#10;                }&#10;            }&#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            Toast.makeText(requireContext(), &quot;Favorites imported&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import favorites&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    private fun loadFavorites() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        val json = prefs.getString(KEY_FAVORITES, &quot;[]&quot;) ?: &quot;[]&quot;&#10;        val type = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val listType = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val loadedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(json, listType)&#10;&#10;        val orderJson = prefs.getString(&quot;favorites_order&quot;, &quot;[]&quot;)&#10;        val orderType = TypeToken&#10;            .getParameterized(List::class.java, String::class.java)&#10;            .type&#10;        val originalOrder: List&lt;String&gt; = gson.fromJson(orderJson, orderType)&#10;&#10;        // Reorder the loadedFavorites to match the original order&#10;        favoritesList = if (originalOrder.isNotEmpty()) {&#10;            loadedFavorites.sortedBy { originalOrder.indexOf(it.name) }.toMutableList()&#10;        } else {&#10;            loadedFavorites.toMutableList()&#10;        }&#10;&#10;        adapter.submitList(favoritesList.toList())&#10;    }&#10;&#10;&#10;    private fun saveFavorites() {&#10;        val ctx = context ?: return&#10;        val prefs = ctx&#10;            .getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val editor = prefs.edit()&#10;        editor.putString(KEY_FAVORITES, gson.toJson(favoritesList))&#10;        editor.putString(&quot;favorites_order&quot;, gson.toJson(favoritesList.map { it.name }))&#10;        editor.apply()&#10;    }&#10;&#10;&#10;&#10;    private fun saveSortingOrder() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_SORTED, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(KEY_FAVORITES, gson.toJson(favoritesList)).apply()&#10;&#10;    }&#10;&#10;    private fun deleteFavorite(favorite: FavoriteLocation) {&#10;        val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;        val deletedIndex = favoritesList.indexOf(favorite).takeIf { it != -1 } ?: return&#10;        favoritesList.removeAt(deletedIndex)&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;        Snackbar.make(rootView, &quot;Deleted: ${favorite.name}&quot;, Snackbar.LENGTH_LONG)&#10;            .setAction(&quot;UNDO&quot;) {&#10;                favoritesList.add(deletedIndex, favorite)&#10;                adapter.submitList(favoritesList.toList())&#10;                saveFavorites()&#10;            }&#10;            .show()&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    private fun copyFavorite(favorite: FavoriteLocation) {&#10;        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager&#10;        val clip = ClipData.newPlainText(&quot;Favorite Coordinates&quot;, &quot;${favorite.lat}, ${favorite.lng}&quot;)&#10;        clipboard.setPrimaryClip(clip)&#10;        Toast.makeText(requireContext(), &quot;Coordinates copied to clipboard&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;&#10;    /**&#10;     * Teleports to the favorite location based on the user's teleport method preference.&#10;     * If &quot;ipogo&quot; is selected, it opens an ipogo URL; if &quot;joystick&quot; is selected, it sends an intent.&#10;     */&#10;    private fun teleportToFavorite(favorite: FavoriteLocation) {&#10;        val context = requireContext()&#10;        val teleportPrefs = context.getSharedPreferences(&quot;teleport_prefs&quot;, Context.MODE_PRIVATE)&#10;        val method = teleportPrefs.getString(&quot;teleport_method&quot;, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;&#10;        if (method == &quot;ipogo&quot;) {&#10;            val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;            startActivity(intent)&#10;            return&#10;        }&#10;&#10;        val baseIntent = Intent().apply {&#10;            action = &quot;theappninjas.gpsjoystick.TELEPORT&quot;&#10;            putExtra(&quot;lat&quot;, favorite.lat.toFloat())&#10;            putExtra(&quot;lng&quot;, favorite.lng.toFloat())&#10;        }&#10;        val knownComponents = listOf(&#10;            ComponentName(&#10;                &quot;com.theappninjas.fakegpsjoystick&quot;,&#10;                &quot;com.theappninjas.fakegpsjoystick.service.OverlayService&quot;&#10;            ),&#10;            ComponentName(&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw&quot;,&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw.service.OverlayService&quot;&#10;            )&#10;        )&#10;&#10;        var serviceStarted = false&#10;        for (component in knownComponents) {&#10;            val intent = Intent(baseIntent).apply {&#10;                this.component = component&#10;            }&#10;            try {&#10;                val compName = context.startService(intent)&#10;                if (compName != null) {&#10;                    serviceStarted = true&#10;                    break&#10;                }&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            val dynamicIntent = Intent(baseIntent).apply { component = null }&#10;            val pm = context.packageManager&#10;            val services = pm.queryIntentServices(dynamicIntent, 0)&#10;            if (services.isNotEmpty()) {&#10;                val serviceInfo = services.first().serviceInfo&#10;                dynamicIntent.component = ComponentName(serviceInfo.packageName, serviceInfo.name)&#10;                try {&#10;                    val compName = context.startService(dynamicIntent)&#10;                    serviceStarted = (compName != null)&#10;                } catch (e: Exception) {&#10;                }&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            Toast.makeText(context, &quot;Error: Joystick not found&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    /**&#10;     * Opens the dialog to add a new favorite.&#10;     */&#10;    private fun showAddFavoriteDialog() {&#10;        val dialog = FavoriteDialogFragment.newInstance(null, -1)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;    /**&#10;     * Opens the dialog to edit an existing favorite.&#10;     */&#10;    private fun showEditFavoriteDialog(favorite: FavoriteLocation, position: Int) {&#10;        val dialog = FavoriteDialogFragment.newInstance(favorite, position)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;&#10;    override fun onFavoriteSaved(favorite: FavoriteLocation, position: Int) {&#10;        if (position == -1) {&#10;            favoritesList.add(favorite)&#10;            Toast.makeText(requireContext(), &quot;Favorite added&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            favoritesList[position] = favorite&#10;            Toast.makeText(requireContext(), &quot;Favorite updated&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;    }&#10;&#10;&#10;    private val itemTouchHelperCallback = object : ItemTouchHelper.SimpleCallback(&#10;        ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0&#10;    ) {&#10;        override fun onMove(&#10;            recyclerView: RecyclerView,&#10;            viewHolder: RecyclerView.ViewHolder,&#10;            target: RecyclerView.ViewHolder&#10;        ): Boolean {&#10;            // Use adapterPosition everywhere&#10;            val from = viewHolder.adapterPosition&#10;            val to   = target.adapterPosition&#10;            if (from == RecyclerView.NO_POSITION || to == RecyclerView.NO_POSITION) return false&#10;&#10;            // Make a mutable copy, swap, and resubmit&#10;            // Update BOTH the favorites list AND the adapter&#10;            Collections.swap(favoritesList, from, to)&#10;            adapter.submitList(favoritesList.toList())&#10;            return true&#10;        }&#10;&#10;&#10;        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;            // No swipe action.&#10;        }&#10;&#10;        override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {&#10;            super.clearView(recyclerView, viewHolder)&#10;            saveFavorites()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.ClipData&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.view.*&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.coordinatorlayout.widget.CoordinatorLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.recyclerviews.FavoritesAdapter&#10;import java.util.Collections&#10;import androidx.core.content.edit&#10;&#10;private const val PREFS_NAME = &quot;FavoritesPrefs&quot;&#10;private const val SORT_ORDER_KEY = &quot;sort_order&quot;&#10;private const val SORT_ORDER_NAME = &quot;name&quot;&#10;private const val SORT_ORDER_DEFAULT = &quot;default&quot;&#10;&#10;&#10;class FavoritesFragment : Fragment(), FavoriteDialogFragment.FavoriteDialogListener {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: FavoritesAdapter&#10;    private lateinit var addFavoriteFab: View&#10;    private var favoritesList = mutableListOf&lt;FavoriteLocation&gt;()&#10;    private val gson = Gson()&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val FAVORITES_SORTED = &quot;favorites_sorted&quot;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val view = inflater.inflate(R.layout.fragment_favorites, container, false)&#10;        recyclerView = view.findViewById(R.id.favoritesRecyclerView)&#10;        addFavoriteFab = view.findViewById(R.id.addFavoriteFab)&#10;        return view&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        adapter = FavoritesAdapter(&#10;            onDeleteFavorite = { favorite -&gt; deleteFavorite(favorite) },&#10;            onEditFavorite = { favorite, position -&gt; showEditFavoriteDialog(favorite, position) },&#10;            onCopyFavorite = { favorite -&gt; copyFavorite(favorite) },&#10;            onTeleportFavorite = { favorite -&gt; teleportToFavorite(favorite) }&#10;        )&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        loadFavorites()&#10;&#10;&#10;&#10;        addFavoriteFab.setOnClickListener {&#10;            showAddFavoriteDialog()&#10;        }&#10;        val itemTouchHelper = ItemTouchHelper(itemTouchHelperCallback)&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;    }&#10;&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.favorites_menu, menu)&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.menu_import_favorites -&gt; {&#10;                showImportFavoritesDialog()&#10;                true&#10;            }&#10;            R.id.menu_import_hotspots -&gt; {&#10;                showImportHotspotsDialog()&#10;                true&#10;            }&#10;            R.id.action_sortByName -&gt; {&#10;                saveSortOrderPreference(SORT_ORDER_NAME)&#10;                sortFavsByName()&#10;                true&#10;            }&#10;&#10;            R.id.action_sortByDefault -&gt; {&#10;                sortFavsByDefault()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun saveSortOrderPreference(sortOrder: String) {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit { putString(SORT_ORDER_KEY, sortOrder) }&#10;    }&#10;&#10;    private fun sortFavsByName() {&#10;        val sortedList = favoritesList.toMutableList().apply {&#10;            sortBy { it.name }&#10;        }&#10;        adapter.submitList(sortedList)&#10;    }&#10;&#10;    private fun sortFavsByDefault() {&#10;        loadFavorites()&#10;    }&#10;&#10;&#10;&#10;    private fun loadSortOrderPreference(): String {&#10;        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return prefs.getString(SORT_ORDER_KEY, SORT_ORDER_DEFAULT) ?: SORT_ORDER_DEFAULT&#10;    }&#10;&#10;    private fun applySavedSortOrder() {&#10;        when (loadSortOrderPreference()) {&#10;            SORT_ORDER_NAME -&gt; sortFavsByName()&#10;            SORT_ORDER_DEFAULT -&gt; sortFavsByDefault()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing favorites via JSON.&#10;     */&#10;    private fun showImportFavoritesDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_favorites, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importFavorites(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Displays a confirmation dialog for importing hotspots.&#10;     */&#10;    private fun showImportHotspotsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_confirm_import_hotspots, null)&#10;&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelConfirmButton)&#10;        val confirmButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmImportButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        confirmButton.setOnClickListener {&#10;            importHotspots()&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports hotspots from the hotspots.txt file in the res folder.&#10;     */&#10;    private fun importHotspots() {&#10;        try {&#10;            val inputStream = resources.openRawResource(R.raw.hotspots)&#10;            val jsonString = inputStream.bufferedReader().use { it.readText() }&#10;            &#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedHotspots: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            &#10;            // Store the current list before making changes&#10;            val previousList = favoritesList.toList()&#10;            val addedLocations = mutableListOf&lt;FavoriteLocation&gt;()&#10;            &#10;            // Merge imported hotspots with the current list, avoiding duplicates&#10;            for (hotspot in importedHotspots) {&#10;                if (!favoritesList.any { it.lat == hotspot.lat &amp;&amp; it.lng == hotspot.lng &amp;&amp; it.name == hotspot.name }) {&#10;                    favoritesList.add(hotspot)&#10;                    addedLocations.add(hotspot)&#10;                }&#10;            }&#10;            &#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            &#10;            // Show snackbar with undo option&#10;            val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;            val message = if (addedLocations.isNotEmpty()) {&#10;                &quot;Imported ${addedLocations.size} hotspot(s)&quot;&#10;            } else {&#10;                &quot;No new hotspots to import&quot;&#10;            }&#10;            &#10;            Snackbar.make(rootView, message, Snackbar.LENGTH_LONG)&#10;                .setAction(&quot;UNDO&quot;) {&#10;                    // Restore the previous list&#10;                    favoritesList.clear()&#10;                    favoritesList.addAll(previousList)&#10;                    adapter.submitList(favoritesList.toList())&#10;                    saveFavorites()&#10;                    Toast.makeText(requireContext(), &quot;Import undone&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                .show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import hotspots: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Imports favorites from the provided JSON string.&#10;     */&#10;    private fun importFavorites(jsonString: String) {&#10;        try {&#10;            val importType = TypeToken&#10;                .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;                .type&#10;            val importedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(jsonString, importType)&#10;            // Merge imported favorites with the current list, avoiding duplicates.&#10;            for (fav in importedFavorites) {&#10;                if (!favoritesList.any { it.lat == fav.lat &amp;&amp; it.lng == fav.lng &amp;&amp; it.name == fav.name }) {&#10;                    favoritesList.add(fav)&#10;                }&#10;            }&#10;            adapter.submitList(favoritesList.toList())&#10;            saveFavorites()&#10;            Toast.makeText(requireContext(), &quot;Favorites imported&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import favorites&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;    private fun loadFavorites() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        val json = prefs.getString(KEY_FAVORITES, &quot;[]&quot;) ?: &quot;[]&quot;&#10;        val type = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val listType = TypeToken&#10;            .getParameterized(List::class.java, FavoriteLocation::class.java)&#10;            .type&#10;        val loadedFavorites: List&lt;FavoriteLocation&gt; = gson.fromJson(json, listType)&#10;&#10;        val orderJson = prefs.getString(&quot;favorites_order&quot;, &quot;[]&quot;)&#10;        val orderType = TypeToken&#10;            .getParameterized(List::class.java, String::class.java)&#10;            .type&#10;        val originalOrder: List&lt;String&gt; = gson.fromJson(orderJson, orderType)&#10;&#10;        // Reorder the loadedFavorites to match the original order&#10;        favoritesList = if (originalOrder.isNotEmpty()) {&#10;            loadedFavorites.sortedBy { originalOrder.indexOf(it.name) }.toMutableList()&#10;        } else {&#10;            loadedFavorites.toMutableList()&#10;        }&#10;&#10;        adapter.submitList(favoritesList.toList())&#10;    }&#10;&#10;&#10;    private fun saveFavorites() {&#10;        val ctx = context ?: return&#10;        val prefs = ctx&#10;            .getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val editor = prefs.edit()&#10;        editor.putString(KEY_FAVORITES, gson.toJson(favoritesList))&#10;        editor.putString(&quot;favorites_order&quot;, gson.toJson(favoritesList.map { it.name }))&#10;        editor.apply()&#10;    }&#10;&#10;&#10;&#10;    private fun saveSortingOrder() {&#10;        val prefs = requireContext().getSharedPreferences(FAVORITES_SORTED, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(KEY_FAVORITES, gson.toJson(favoritesList)).apply()&#10;&#10;    }&#10;&#10;    private fun deleteFavorite(favorite: FavoriteLocation) {&#10;        val rootView = requireActivity().findViewById&lt;View&gt;(android.R.id.content)&#10;        val deletedIndex = favoritesList.indexOf(favorite).takeIf { it != -1 } ?: return&#10;        favoritesList.removeAt(deletedIndex)&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;        Snackbar.make(rootView, &quot;Deleted: ${favorite.name}&quot;, Snackbar.LENGTH_LONG)&#10;            .setAction(&quot;UNDO&quot;) {&#10;                favoritesList.add(deletedIndex, favorite)&#10;                adapter.submitList(favoritesList.toList())&#10;                saveFavorites()&#10;            }&#10;            .show()&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    private fun copyFavorite(favorite: FavoriteLocation) {&#10;        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager&#10;        val clip = ClipData.newPlainText(&quot;Favorite Coordinates&quot;, &quot;${favorite.lat}, ${favorite.lng}&quot;)&#10;        clipboard.setPrimaryClip(clip)&#10;        Toast.makeText(requireContext(), &quot;Coordinates copied to clipboard&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;&#10;    /**&#10;     * Teleports to the favorite location based on the user's teleport method preference.&#10;     * If &quot;ipogo&quot; is selected, it opens an ipogo URL; if &quot;joystick&quot; is selected, it sends an intent.&#10;     */&#10;    private fun teleportToFavorite(favorite: FavoriteLocation) {&#10;        val context = requireContext()&#10;        val teleportPrefs = context.getSharedPreferences(&quot;teleport_prefs&quot;, Context.MODE_PRIVATE)&#10;        val method = teleportPrefs.getString(&quot;teleport_method&quot;, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;&#10;        if (method == &quot;ipogo&quot;) {&#10;            val url = &quot;https://ipogo.app/?coords=${favorite.lat},${favorite.lng}&quot;&#10;            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;            startActivity(intent)&#10;            return&#10;        }&#10;&#10;        val baseIntent = Intent().apply {&#10;            action = &quot;theappninjas.gpsjoystick.TELEPORT&quot;&#10;            putExtra(&quot;lat&quot;, favorite.lat.toFloat())&#10;            putExtra(&quot;lng&quot;, favorite.lng.toFloat())&#10;        }&#10;        val knownComponents = listOf(&#10;            ComponentName(&#10;                &quot;com.theappninjas.fakegpsjoystick&quot;,&#10;                &quot;com.theappninjas.fakegpsjoystick.service.OverlayService&quot;&#10;            ),&#10;            ComponentName(&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw&quot;,&#10;                &quot;com.thekkgqtaoxz.ymaaammipjyfatw.service.OverlayService&quot;&#10;            )&#10;        )&#10;&#10;        var serviceStarted = false&#10;        for (component in knownComponents) {&#10;            val intent = Intent(baseIntent).apply {&#10;                this.component = component&#10;            }&#10;            try {&#10;                val compName = context.startService(intent)&#10;                if (compName != null) {&#10;                    serviceStarted = true&#10;                    break&#10;                }&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            val dynamicIntent = Intent(baseIntent).apply { component = null }&#10;            val pm = context.packageManager&#10;            val services = pm.queryIntentServices(dynamicIntent, 0)&#10;            if (services.isNotEmpty()) {&#10;                val serviceInfo = services.first().serviceInfo&#10;                dynamicIntent.component = ComponentName(serviceInfo.packageName, serviceInfo.name)&#10;                try {&#10;                    val compName = context.startService(dynamicIntent)&#10;                    serviceStarted = (compName != null)&#10;                } catch (e: Exception) {&#10;                }&#10;            }&#10;        }&#10;&#10;        if (!serviceStarted) {&#10;            Toast.makeText(context, &quot;Error: Joystick not found&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;    /**&#10;     * Opens the dialog to add a new favorite.&#10;     */&#10;    private fun showAddFavoriteDialog() {&#10;        val dialog = FavoriteDialogFragment.newInstance(null, -1)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;    /**&#10;     * Opens the dialog to edit an existing favorite.&#10;     */&#10;    private fun showEditFavoriteDialog(favorite: FavoriteLocation, position: Int) {&#10;        val dialog = FavoriteDialogFragment.newInstance(favorite, position)&#10;        dialog.setTargetFragment(this, 0)&#10;        dialog.show(parentFragmentManager, &quot;FavoriteDialogFragment&quot;)&#10;    }&#10;&#10;&#10;    override fun onFavoriteSaved(favorite: FavoriteLocation, position: Int) {&#10;        if (position == -1) {&#10;            favoritesList.add(favorite)&#10;            Toast.makeText(requireContext(), &quot;Favorite added&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            favoritesList[position] = favorite&#10;            Toast.makeText(requireContext(), &quot;Favorite updated&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;        adapter.submitList(favoritesList.toList())&#10;        saveFavorites()&#10;    }&#10;&#10;&#10;    private val itemTouchHelperCallback = object : ItemTouchHelper.SimpleCallback(&#10;        ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0&#10;    ) {&#10;        override fun onMove(&#10;            recyclerView: RecyclerView,&#10;            viewHolder: RecyclerView.ViewHolder,&#10;            target: RecyclerView.ViewHolder&#10;        ): Boolean {&#10;            // Use adapterPosition everywhere&#10;            val from = viewHolder.adapterPosition&#10;            val to   = target.adapterPosition&#10;            if (from == RecyclerView.NO_POSITION || to == RecyclerView.NO_POSITION) return false&#10;&#10;            // Make a mutable copy, swap, and resubmit&#10;            // Update BOTH the favorites list AND the adapter&#10;            Collections.swap(favoritesList, from, to)&#10;            adapter.submitList(favoritesList.toList())&#10;            return true&#10;        }&#10;&#10;&#10;        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {&#10;            // No swipe action.&#10;        }&#10;&#10;        override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {&#10;            super.clearView(recyclerView, viewHolder)&#10;            saveFavorites()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/FilterFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;&#10;        saveRocketItem?.isVisible = (currentFilterType == &quot;Rocket&quot;)&#10;        saveQuestItem?.isVisible  = (currentFilterType == &quot;Quest&quot;)&#10;    }&#10;&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_save_rocket -&gt; {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;Pokémon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;Pokémon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;Pokémon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;Pokémon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;Pokémon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;Pokémon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if it’s one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;Pokémon Encounter&quot;, &quot;Mega Energy&quot;, &quot;Pokémon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;Pokémon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;Pokémon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;Pokémon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire “Spinda” block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main “Spinda” checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main “Spinda” checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;▶&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specific‐form checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;▼&quot; else &quot;▶&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.LayoutInflater&#10;import android.view.Menu&#10;import android.view.MenuInflater&#10;import android.view.MenuItem&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.CompoundButton&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.setPadding&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.gson.Gson&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.CurrentQuestData&#10;import com.mints.projectgammatwo.data.DataMappings&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;// Removed PokemonRepository as it's unused in this fragment&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.viewmodels.QuestsViewModel&#10;&#10;class FilterFragment : Fragment() {&#10;&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private val enabledRocketFilters = mutableSetOf&lt;Int&gt;()&#10;    private lateinit var questsViewModel: QuestsViewModel&#10;    private var currentFilterType = &quot;Rocket&quot;&#10;    private lateinit var questPrefs: SharedPreferences&#10;    private val enabledQuestFilters = mutableSetOf&lt;String&gt;()&#10;    private lateinit var questLayout: LinearLayout&#10;    private lateinit var rocketLayoutGlobal: LinearLayout&#10;    private lateinit var currentFilterTextView: TextView&#10;    private var originalSettingsOfLoadedRocketFilter: Set&lt;Int&gt;? = null&#10;    private var originalSettingsOfLoadedQuestFilter: Set&lt;String&gt;? = null&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setHasOptionsMenu(true)&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_list, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        questPrefs = requireContext().getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;        currentFilterTextView = view.findViewById(R.id.currentFilterText)&#10;        rocketLayoutGlobal = view.findViewById(R.id.rocketFiltersLayout)&#10;        questLayout = view.findViewById(R.id.questFiltersLayout)&#10;        enabledRocketFilters.clear()&#10;        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;&#10;        enabledQuestFilters.clear()&#10;        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;        questsViewModel = ViewModelProvider(this)[QuestsViewModel::class.java]&#10;        questsViewModel.fetchSpindaFormsFromApi()&#10;&#10;        questsViewModel.spindaFormsLiveData.observe(viewLifecycleOwner) { spindaFormsMap -&gt;&#10;            Log.d(&quot;FilterFragment&quot;, &quot;spindaFormsLiveData emitted: ${spindaFormsMap.keys}&quot;)&#10;            DataMappings.initializePokemonData(requireContext()) {&#10;                if (!isAdded) return@initializePokemonData&#10;                Log.d(&quot;App&quot;, &quot;Pokemon data loaded with ${DataMappings.pokemonEncounterMapNew.size} entries&quot;)&#10;&#10;                setupQuestFilters(questLayout)&#10;            }&#10;&#10;        }&#10;&#10;        val testList = CurrentQuestData.currentQuests&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Current quests size: ${testList.size}&quot;)&#10;&#10;        val spindaQuests = testList.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        val spindaType1 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;01&quot;)&#10;&#10;        }&#10;        val spindaType2 = spindaQuests.filter { quest -&gt;&#10;            quest.rewardsString.contains(&quot;02&quot;)&#10;        }&#10;&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (01) quests: ${spindaType1.size}&quot;)&#10;        Log.d(&quot;FilterFragment&quot;, &quot;Spinda (02) quests: ${spindaType2.size}&quot;)&#10;&#10;&#10;        getAvailableSpindaForms()&#10;        questsViewModel.questsLiveData.observe(viewLifecycleOwner) { quests -&gt;&#10;            getAvailableSpindaForms()&#10;        }&#10;&#10;        val radioGroup = view.findViewById&lt;RadioGroup&gt;(R.id.filterTypeRadioGroup)&#10;&#10;        radioGroup.post {&#10;            val isQuestVisible = questLayout.visibility == View.VISIBLE&#10;            val isRocketVisible = rocketLayoutGlobal.visibility == View.VISIBLE&#10;&#10;            when {&#10;                isQuestVisible -&gt; {&#10;                    radioGroup.check(R.id.rbQuest)&#10;                    updateCurrentQuestFilter()&#10;                    currentFilterType = &quot;Quest&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;                }&#10;                isRocketVisible -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    updateCurrentRocketFilter()&#10;                }&#10;                else -&gt; {&#10;                    radioGroup.check(R.id.rbRocket)&#10;                    rocketLayoutGlobal.visibility = View.VISIBLE&#10;                    questLayout.visibility = View.GONE&#10;                    updateCurrentRocketFilter()&#10;                    currentFilterType = &quot;Rocket&quot;&#10;                    Log.d(&quot;Test&quot;,&quot;Current filter type: $currentFilterType&quot;)&#10;&#10;                }&#10;            }&#10;            activity?.invalidateOptionsMenu()&#10;&#10;&#10;            radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                when (checkedId) {&#10;                    R.id.rbRocket -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.VISIBLE&#10;                        questLayout.visibility = View.GONE&#10;                        currentFilterType = &quot;Rocket&quot;&#10;                        updateCurrentRocketFilter()&#10;                    }&#10;                    R.id.rbQuest -&gt; {&#10;                        rocketLayoutGlobal.visibility = View.GONE&#10;                        questLayout.visibility = View.VISIBLE&#10;                        currentFilterType = &quot;Quest&quot;&#10;&#10;                        updateCurrentQuestFilter()&#10;                    }&#10;                }&#10;                activity?.invalidateOptionsMenu()&#10;            }&#10;        }&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;        val initialActiveRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        if (initialActiveRocketFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedRocketFilter == null) {&#10;                originalSettingsOfLoadedRocketFilter = HashSet(filterPreferences.getEnabledCharacters())&#10;            }&#10;        }&#10;&#10;        val initialActiveQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        if (initialActiveQuestFilter.isNotEmpty()) {&#10;            if (originalSettingsOfLoadedQuestFilter == null) {&#10;                originalSettingsOfLoadedQuestFilter = HashSet(filterPreferences.getEnabledQuestFilters())&#10;            }&#10;        }&#10;&#10;        setupRocketFilters(rocketLayoutGlobal)&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {&#10;        inflater.inflate(R.menu.filter_nav_menu, menu)&#10;&#10;&#10;        super.onCreateOptionsMenu(menu, inflater)&#10;    }&#10;&#10;    override fun onPrepareOptionsMenu(menu: Menu) {&#10;        super.onPrepareOptionsMenu(menu)&#10;        val saveRocketItem = menu.findItem(R.id.action_save_rocket)&#10;        val saveQuestItem  = menu.findItem(R.id.action_save_quest)&#10;        val refreshFiltersItem = menu.findItem(R.id.action_refresh_filters)&#10;&#10;        saveRocketItem?.isVisible = (currentFilterType == &quot;Rocket&quot;)&#10;        saveQuestItem?.isVisible  = (currentFilterType == &quot;Quest&quot;)&#10;        refreshFiltersItem?.isVisible = (currentFilterType == &quot;Quest&quot;)&#10;    }&#10;&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_save_rocket -&gt; {&#10;                showSaveFilterDialog(true)&#10;                true&#10;            }&#10;            R.id.action_save_quest -&gt; {&#10;                showSaveFilterDialog(false)&#10;                true&#10;            }&#10;            R.id.action_refresh_filters -&gt; {&#10;                questsViewModel.fetchQuests()&#10;                if (::questLayout.isInitialized) {&#10;                    setupQuestFilters(questLayout)&#10;                }&#10;                if (::rocketLayoutGlobal.isInitialized) {&#10;                    setupRocketFilters(rocketLayoutGlobal)&#10;                }&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun showSaveFilterDialog(isRocket: Boolean) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_save_filter, null)&#10;&#10;        val titleTextView = dialogView.findViewById&lt;TextView&gt;(R.id.saveFilterTitle)&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editFilterName)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelFilterButton)&#10;        val saveButton = dialogView.findViewById&lt;Button&gt;(R.id.saveFilterButton)&#10;&#10;        // Set the dynamic title&#10;        val type = if(isRocket) &quot;rocket&quot; else &quot;quest&quot;&#10;        titleTextView.text = &quot;Enter a name for the new $type filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        saveButton.setOnClickListener {&#10;            val newFilterName = editText.text.toString().trim()&#10;            if (newFilterName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            if (isRocket) {&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                filterPreferences.saveCurrentAsFilter(newFilterName)&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;                val activeFilterNameToRevert = filterPreferences.getActiveRocketFilter()&#10;&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedRocketFilter != null) {&#10;                    enabledRocketFilters.clear()&#10;                    enabledRocketFilters.addAll(originalSettingsOfLoadedRocketFilter!!)&#10;                    filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                } else {&#10;                    filterPreferences.setActiveRocketFilter(newFilterName)&#10;                    originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                }&#10;                setupRocketFilters(rocketLayoutGlobal)&#10;&#10;            } else {&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                filterPreferences.saveCurrentQuestFilter(newFilterName)&#10;                Log.d(&quot;SaveFilter&quot;,&quot;Current enabled spinda forms: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                Toast.makeText(requireContext(), &quot;Filter '$newFilterName' saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                val activeFilterNameToRevert = filterPreferences.getActiveQuestFilter()&#10;                if (activeFilterNameToRevert.isNotEmpty() &amp;&amp; originalSettingsOfLoadedQuestFilter != null) {&#10;                    enabledQuestFilters.clear()&#10;                    enabledQuestFilters.addAll(originalSettingsOfLoadedQuestFilter!!)&#10;                    filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                } else {&#10;                    filterPreferences.setActiveQuestFilter(newFilterName)&#10;                    originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                }&#10;                setupQuestFilters(questLayout)&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;&#10;    private fun setupRocketFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Rocket&quot;)&#10;        addToggleAllButton(parent, &quot;Rocket&quot;)&#10;        addSectionHeader(parent, &quot;Rocket Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Rocket&quot;)&#10;&#10;        updateCurrentRocketFilter()&#10;&#10;        DataMappings.characterNamesMap.forEach { (id, name) -&gt;&#10;            addCheckBox(parent, name, id, enabledRocketFilters) { checked -&gt;&#10;                if (checked) enabledRocketFilters.add(id) else enabledRocketFilters.remove(id)&#10;&#10;                filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentRocketFilter() {&#10;&#10;        if(currentFilterType != &quot;Rocket&quot;) {&#10;            updateCurrentQuestFilter()&#10;        }&#10;        val currentFilterName = filterPreferences.getActiveRocketFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;    private fun updateCurrentQuestFilter() {&#10;&#10;        if(currentFilterType != &quot;Quest&quot;) {&#10;            updateCurrentRocketFilter()&#10;        }&#10;&#10;&#10;        val currentFilterName = filterPreferences.getActiveQuestFilter()&#10;        if (currentFilterName.isNotEmpty()) {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: $currentFilterName&quot;&#10;        } else {&#10;            currentFilterTextView.visibility = View.VISIBLE&#10;            currentFilterTextView.text = &quot;Current selected filter: Unsaved&quot;&#10;        }&#10;    }&#10;&#10;&#10;    private fun addResetButton(parent: LinearLayout, filterType: String) {&#10;        val resetButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Reset $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        enabledRocketFilters.clear()&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        enabledQuestFilters.clear()&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                        setupQuestFilters(parent)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(resetButton, 0)&#10;    }&#10;&#10;    private fun addSelectFilterButton(parent: LinearLayout, filterType: String) {&#10;        val selectButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Select $filterType Filter&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                showSelectFilterDialog(parent, filterType)&#10;            }&#10;        }&#10;        parent.addView(selectButton, 1)&#10;    }&#10;&#10;    private fun showSelectFilterDialog(parentLayoutForRefresh: LinearLayout, filterType: String) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_select_filter, null)&#10;&#10;        val title = dialogView.findViewById&lt;TextView&gt;(R.id.selectFilterTitle)&#10;        val listContainer = dialogView.findViewById&lt;LinearLayout&gt;(R.id.filterListContainer)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSelectButton)&#10;&#10;        title.text = &quot;Select $filterType Filter&quot;&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up cancel button&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        fun updateDialogContent() {&#10;            listContainer.removeAllViews()&#10;&#10;            val filterNames: Array&lt;String&gt; = if (filterType == &quot;Rocket&quot;) {&#10;                filterPreferences.listFilterNames().toTypedArray()&#10;            } else {&#10;                filterPreferences.listQuestFilterNames().toTypedArray()&#10;            }&#10;&#10;            if (filterNames.isEmpty()) {&#10;                val emptyView = TextView(requireContext()).apply {&#10;                    text = &quot;No saved filters available&quot;&#10;                    setPadding(16, 16, 16, 16)&#10;                    gravity = android.view.Gravity.CENTER&#10;                    textSize = 16f&#10;                    setTextColor(ContextCompat.getColor(requireContext(), android.R.color.darker_gray))&#10;                }&#10;                listContainer.addView(emptyView)&#10;                return&#10;            }&#10;&#10;            filterNames.forEach { filterName -&gt;&#10;                val itemView = inflater.inflate(R.layout.filter_list_item, listContainer, false)&#10;                val nameTextView = itemView.findViewById&lt;TextView&gt;(R.id.filterNameText)&#10;                val deleteButton = itemView.findViewById&lt;ImageButton&gt;(R.id.deleteFilterButton)&#10;                val selectButton = itemView.findViewById&lt;Button&gt;(R.id.selectFilterButton)&#10;&#10;                nameTextView.text = filterName&#10;&#10;                selectButton.setOnClickListener {&#10;                    if (filterType == &quot;Rocket&quot;) {&#10;                        filterPreferences.loadFilter(filterName, &quot;Rocket&quot;)&#10;                        enabledRocketFilters.clear()&#10;                        enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                        filterPreferences.getEnabledSpindaForms()&#10;                        Log.d(&quot;SelectingFilter&quot;,&quot;Spinda forms enabled: ${filterPreferences.getEnabledSpindaForms()}&quot;)&#10;&#10;                        originalSettingsOfLoadedRocketFilter = HashSet(enabledRocketFilters)&#10;                        setupRocketFilters(parentLayoutForRefresh)&#10;                    } else {&#10;                        filterPreferences.loadFilter(filterName, &quot;Quest&quot;)&#10;                        enabledQuestFilters.clear()&#10;                        enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;&#10;                        originalSettingsOfLoadedQuestFilter = HashSet(enabledQuestFilters)&#10;                        setupQuestFilters(parentLayoutForRefresh)&#10;                    }&#10;                    Toast.makeText(requireContext(), &quot;Filter '$filterName' applied&quot;, Toast.LENGTH_SHORT).show()&#10;                    dialog.dismiss()&#10;                }&#10;&#10;                deleteButton.setOnClickListener {&#10;                    showDeleteConfirmationDialog(filterName, filterType) {&#10;                        if (filterType == &quot;Rocket&quot;) {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(filterPreferences.getEnabledCharacters())&#10;                            originalSettingsOfLoadedRocketFilter = null&#10;                            setupRocketFilters(parentLayoutForRefresh)&#10;                        } else {&#10;                            enabledQuestFilters.clear()&#10;                            enabledQuestFilters.addAll(filterPreferences.getEnabledQuestFilters())&#10;                            originalSettingsOfLoadedQuestFilter = null&#10;                            setupQuestFilters(parentLayoutForRefresh)&#10;                        }&#10;                        updateDialogContent()&#10;                    }&#10;                }&#10;                listContainer.addView(itemView)&#10;            }&#10;        }&#10;&#10;        updateDialogContent()&#10;        dialog.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(&#10;        filterName: String,&#10;        filterType: String,&#10;        onDeleted: () -&gt; Unit&#10;    ) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_delete_filter, null)&#10;&#10;        val filterNameDisplay = dialogView.findViewById&lt;TextView&gt;(R.id.filterNameDisplay)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelDeleteButton)&#10;        val deleteButton = dialogView.findViewById&lt;Button&gt;(R.id.confirmDeleteButton)&#10;&#10;        filterNameDisplay.text = filterName&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        deleteButton.setOnClickListener {&#10;            val wasActiveRocket = filterType == &quot;Rocket&quot; &amp;&amp; filterName == filterPreferences.getActiveRocketFilter()&#10;            val wasActiveQuest = filterType == &quot;Quest&quot; &amp;&amp; filterName == filterPreferences.getActiveQuestFilter()&#10;&#10;            filterPreferences.deleteFilter(filterName, filterType)&#10;&#10;            if (wasActiveRocket) {&#10;                originalSettingsOfLoadedRocketFilter = null&#10;            }&#10;            if (wasActiveQuest) {&#10;                originalSettingsOfLoadedQuestFilter = null&#10;            }&#10;&#10;            Toast.makeText(requireContext(), &quot;Filter '$filterName' deleted&quot;, Toast.LENGTH_SHORT).show()&#10;            dialog.dismiss()&#10;            onDeleted()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun addToggleAllButton(parent: LinearLayout, filterType: String) {&#10;        val toggleButton = MaterialButton(requireContext()).apply {&#10;            text = &quot;Toggle All $filterType Filters&quot;&#10;            setPadding(16, 8, 16, 8)&#10;            setOnClickListener {&#10;                when (filterType) {&#10;                    &quot;Rocket&quot; -&gt; {&#10;                        val allSelected = DataMappings.characterNamesMap.keys.all { it in enabledRocketFilters }&#10;                        if (allSelected) {&#10;                            enabledRocketFilters.clear()&#10;                        } else {&#10;                            enabledRocketFilters.clear()&#10;                            enabledRocketFilters.addAll(DataMappings.characterNamesMap.keys)&#10;                        }&#10;                        filterPreferences.saveEnabledCharacters(enabledRocketFilters)&#10;                        setupRocketFilters(parent)&#10;                    }&#10;                    &quot;Quest&quot; -&gt; {&#10;                        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;                        if (filtersJson != null) {&#10;                            val filtersFromApi = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;                            val allPossibleQuestFilters = mutableSetOf&lt;String&gt;()&#10;                            listOfNotNull(&#10;                                filtersFromApi.t3 to &quot;Stardust&quot;,&#10;                                filtersFromApi.t4 to &quot;Pokémon Candy&quot;,&#10;                                filtersFromApi.t12 to &quot;Mega Energy&quot;,&#10;                                filtersFromApi.t7 to &quot;Pokémon Encounter&quot;,&#10;                                filtersFromApi.t2 to &quot;Item&quot;&#10;                            ).forEach { (list, section) -&gt;&#10;                                list.forEach { rawValue -&gt;&#10;                                    allPossibleQuestFilters.add(buildQuestFilterString(section, rawValue))&#10;                                }&#10;                            }&#10;&#10;                            if (allPossibleQuestFilters.isNotEmpty()) {&#10;                                val allCurrentlySelected = enabledQuestFilters.containsAll(allPossibleQuestFilters) &amp;&amp;&#10;                                        enabledQuestFilters.size == allPossibleQuestFilters.size&#10;&#10;                                if (allCurrentlySelected) {&#10;                                    enabledQuestFilters.clear()&#10;                                } else {&#10;                                    enabledQuestFilters.clear()&#10;                                    enabledQuestFilters.addAll(allPossibleQuestFilters)&#10;                                }&#10;                                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                                setupQuestFilters(parent)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        parent.addView(toggleButton, 0)&#10;    }&#10;&#10;    private fun setupQuestFilters(parent: LinearLayout) {&#10;        parent.removeAllViews()&#10;        addResetButton(parent, &quot;Quest&quot;)&#10;        addToggleAllButton(parent, &quot;Quest&quot;)&#10;        addSectionHeader(parent, &quot;Quest Filters&quot;)&#10;        addSelectFilterButton(parent, &quot;Quest&quot;)&#10;        if(currentFilterType == &quot;Quest&quot;) updateCurrentQuestFilter()&#10;&#10;        val filtersJson = questPrefs.getString(&quot;quest_api_filters&quot;, null)&#10;        if (filtersJson != null) {&#10;            val filters = Gson().fromJson(filtersJson, Quests.Filters::class.java)&#10;&#10;            val spindaFormsMap: Map&lt;String, Int&gt; = questsViewModel.spindaFormsLiveData.value ?: emptyMap()&#10;            Log.d(&quot;FilterFragment&quot;, &quot;All available Spinda forms (cached): ${spindaFormsMap.keys}&quot;)&#10;&#10;            addFilterSection(parent, &quot;Stardust&quot;, filters.t3)&#10;            addFilterSection(parent, &quot;Pokémon Candy&quot;, filters.t4)&#10;            addFilterSection(parent, &quot;Mega Energy&quot;, filters.t12)&#10;&#10;            addFilterSection(parent, &quot;Pokémon Encounter&quot;, filters.t7, spindaFormsMap)&#10;&#10;            addFilterSection(parent, &quot;Item&quot;, filters.t2)&#10;        } else {&#10;            questsViewModel.fetchQuests()&#10;            addSectionHeader(parent, &quot;Please open quests tab to update data (or data loading)&quot;)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private fun addSectionHeader(parent: LinearLayout, text: String) {&#10;        TextView(context).apply {&#10;            this.text = text&#10;            textSize = 18f&#10;            setPadding(16)&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: Int,&#10;        enabledSet: MutableSet&lt;Int&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun addQuestCheckBox(&#10;        parent: LinearLayout,&#10;        text: String,&#10;        id: String,&#10;        enabledSet: MutableSet&lt;String&gt;,&#10;        onCheckedChangeExternal: (Boolean) -&gt; Unit&#10;    ) {&#10;        CheckBox(context).apply {&#10;            this.text = text&#10;            isChecked = id in enabledSet&#10;            setPadding(32, 8, 16, 8)&#10;            setOnCheckedChangeListener { _, checked -&gt;&#10;                if (checked) {&#10;                    enabledSet.add(id)&#10;                } else {&#10;                    enabledSet.remove(id)&#10;                }&#10;                onCheckedChangeExternal(checked)&#10;            }&#10;            parent.addView(this)&#10;        }&#10;    }&#10;&#10;    private fun buildQuestFilterString(section: String, rawValue: String): String {&#10;        return when (section) {&#10;            &quot;Stardust&quot; -&gt; &quot;3,$rawValue,0&quot;&#10;            &quot;Mega Energy&quot; -&gt; &quot;12,0,$rawValue&quot;&#10;            &quot;Pokémon Encounter&quot; -&gt; &quot;7,0,$rawValue&quot;&#10;            &quot;Item&quot; -&gt; &quot;2,0,$rawValue&quot;&#10;            &quot;Pokémon Candy&quot; -&gt; &quot;4,0,$rawValue&quot;&#10;            else -&gt; rawValue&#10;        }&#10;    }&#10;&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16) // consistent 16dp padding around text&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            // Sort differently if it’s one of the special categories; else alphabetical&#10;            val sortedList = when (sectionName) {&#10;                &quot;Pokémon Encounter&quot;, &quot;Mega Energy&quot;, &quot;Pokémon Candy&quot; -&gt;&#10;                    filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;                else -&gt;&#10;                    filterList.sorted()&#10;            }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = when (sectionName) {&#10;                    &quot;Pokémon Encounter&quot; -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;ID: $rawValue&quot;&#10;                    &quot;Item&quot;              -&gt; DataMappings.itemMap[&quot;item$rawValue&quot;]&#10;                        ?: &quot;Item ID: $rawValue&quot;&#10;                    &quot;Mega Energy&quot;       -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Energy for ID: $rawValue&quot;&#10;                    &quot;Pokémon Candy&quot;     -&gt; DataMappings.pokemonEncounterMapNew[rawValue]&#10;                        ?: &quot;Candy for ID: $rawValue&quot;&#10;                    else                -&gt; rawValue&#10;                }&#10;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                // Only if it's **not** Spinda (ID 327) do we use a plain checkbox&#10;                if (!(sectionName == &quot;Pokémon Encounter&quot; &amp;&amp; rawValue == &quot;327&quot;)) {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    private fun addFilterSection(&#10;        parent: LinearLayout,&#10;        sectionName: String,&#10;        filterList: List&lt;String&gt;,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        addSectionHeader(parent, sectionName)&#10;&#10;        if (filterList.isEmpty()) {&#10;            TextView(context).apply {&#10;                text = &quot;None available for $sectionName&quot;&#10;                setPadding(16)&#10;                parent.addView(this)&#10;            }&#10;        } else {&#10;            val sortedList = filterList.sortedBy { DataMappings.pokemonEncounterMapNew[it] ?: it }&#10;&#10;            sortedList.forEach { rawValue -&gt;&#10;                val displayText = DataMappings.pokemonEncounterMapNew[rawValue] ?: &quot;ID: $rawValue&quot;&#10;                val compositeValue = buildQuestFilterString(sectionName, rawValue)&#10;&#10;                if (rawValue == &quot;327&quot;) {&#10;                    addSpindaFilterWithForms(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        spindaFormsMap&#10;                    )&#10;                } else {&#10;                    addQuestCheckBox(&#10;                        parent,&#10;                        displayText,&#10;                        compositeValue,&#10;                        enabledQuestFilters&#10;                    ) {&#10;                        filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;    private fun getAvailableSpindaForms(): Map&lt;String, Int&gt; {&#10;        val spindaForms = mutableMapOf&lt;String, Int&gt;()&#10;        val quests = CurrentQuestData.currentQuests ?: emptyList() // Ensure null safety&#10;        val spindaQuests = quests.filter { quest -&gt;&#10;            quest.rewardsIds.split(&quot;,&quot;).any { it == &quot;327&quot; }&#10;        }&#10;        spindaQuests.forEach { quest -&gt;&#10;            val formPattern = &quot;\\((\\d+)\\)&quot;.toRegex()&#10;            val matches = formPattern.findAll(quest.rewardsString)&#10;            matches.forEach { matchResult -&gt;&#10;                val formNumber = matchResult.groupValues[1]&#10;                val formKey = &quot;spinda_form_$formNumber&quot;&#10;                spindaForms[formKey] = spindaForms.getOrDefault(formKey, 0) + 1&#10;            }&#10;        }&#10;        Log.d(&quot;FilterFragment&quot;, &quot;getAvailableSpindaForms returning: ${spindaForms.keys}&quot;)&#10;        return spindaForms&#10;    }&#10;&#10;    private fun addSpindaFilterWithForms(&#10;        parent: LinearLayout,&#10;        displayText: String,&#10;        baseCompositeValue: String,&#10;        spindaFormsMap: Map&lt;String, Int&gt;&#10;    ) {&#10;        // Container for the entire “Spinda” block&#10;        val spindaContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // Top row: main “Spinda” checkbox + spacer + expand/collapse button&#10;        val topRow = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            gravity = Gravity.CENTER_VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        // We need to access formCheckboxes inside the main checkbox listener,&#10;        // so we declare the list before the main checkbox is defined.&#10;        val formCheckboxes = mutableListOf&lt;CheckBox&gt;()&#10;&#10;        // Main “Spinda” checkbox itself&#10;        val mainSpindaCheckbox = CheckBox(requireContext()).apply {&#10;            text = displayText&#10;            isChecked = baseCompositeValue in enabledQuestFilters&#10;            setPadding(32, 8, 16, 8)&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;&#10;            setOnCheckedChangeListener { _, isChecked -&gt;&#10;                if (isChecked) {&#10;                    enabledQuestFilters.add(baseCompositeValue)&#10;                    formCheckboxes.forEach { it.isChecked = true }&#10;&#10;                } else {&#10;                    //  If the main toggle is turned off...&#10;                    enabledQuestFilters.remove(baseCompositeValue)&#10;&#10;                    // ...uncheck all specific form checkboxes in the UI...&#10;                    formCheckboxes.forEach { it.isChecked = false }&#10;&#10;                    // ...and clear them from saved preferences in the backend.&#10;                    filterPreferences.clearEnabledSpindaForms()&#10;                }&#10;                filterPreferences.saveEnabledQuestFilters(enabledQuestFilters)&#10;&#10;                // Enable or disable all child checkboxes based on the parent's state.&#10;                formCheckboxes.forEach { it.isEnabled = isChecked }&#10;            }&#10;        }&#10;&#10;        // Spacer&#10;        val spacer = View(requireContext()).apply {&#10;            layoutParams = LinearLayout.LayoutParams(0, 0, 1f)&#10;        }&#10;&#10;        // Expand/Collapse button&#10;        val expandButton = MaterialButton(requireContext()).apply {&#10;            text = if (spindaFormsMap.isNotEmpty()) &quot;▶&quot; else &quot;&quot;&#10;            isEnabled = spindaFormsMap.isNotEmpty()&#10;            backgroundTintList = ColorStateList.valueOf(Color.TRANSPARENT)&#10;            val onSurface = TypedValue().also {&#10;                requireContext().theme.resolveAttribute(&#10;                    com.google.android.material.R.attr.colorOnSurface, it, true&#10;                )&#10;            }.data&#10;            setTextColor(onSurface)&#10;            elevation = 0f&#10;            minimumWidth = 0&#10;            minWidth = 0&#10;            setPadding(8.dpToPx(), 4.dpToPx(), 8.dpToPx(), 4.dpToPx())&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            )&#10;        }&#10;&#10;        topRow.addView(mainSpindaCheckbox)&#10;        topRow.addView(spacer)&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            topRow.addView(expandButton)&#10;        }&#10;&#10;        // Container for specific‐form checkboxes (hidden initially)&#10;        val formsContainer = LinearLayout(requireContext()).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            visibility = View.GONE&#10;            setPadding((32 + 16).dpToPx(), 0, 16.dpToPx(), 8.dpToPx())&#10;        }&#10;&#10;        // Populate one checkbox per formKey&#10;        if (spindaFormsMap.isNotEmpty()) {&#10;            val enabledSpecificForms = filterPreferences.getEnabledSpindaForms()&#10;            spindaFormsMap.keys.sorted().forEach { formKey -&gt;&#10;                val formNumber = formKey.removePrefix(&quot;spinda_form_&quot;)&#10;                val formLabel = &quot;Form #$formNumber&quot;&#10;&#10;                val formCheckbox = CheckBox(requireContext()).apply {&#10;                    text = formLabel&#10;                    isChecked = formKey in enabledSpecificForms&#10;&#10;                    //  Child checkboxes are only enabled if the main checkbox is checked.&#10;                    // This sets the initial state correctly on view creation.&#10;                    isEnabled = mainSpindaCheckbox.isChecked&#10;&#10;                    setPadding(0, 8.dpToPx(), 0, 8.dpToPx())&#10;                    layoutParams = LinearLayout.LayoutParams(&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                        ViewGroup.LayoutParams.WRAP_CONTENT&#10;                    )&#10;&#10;                    setOnCheckedChangeListener { _, isChecked -&gt;&#10;                        updateSpindaFormSelection(formKey, isChecked)&#10;                    }&#10;                }&#10;&#10;                formCheckboxes.add(formCheckbox)&#10;                formsContainer.addView(formCheckbox)&#10;            }&#10;&#10;            // Expand/Collapse logic&#10;            var isExpanded = false&#10;            expandButton.setOnClickListener {&#10;                isExpanded = !isExpanded&#10;                formsContainer.visibility = if (isExpanded) View.VISIBLE else View.GONE&#10;                expandButton.text = if (isExpanded) &quot;▼&quot; else &quot;▶&quot;&#10;            }&#10;        }&#10;&#10;        // Assemble into parent&#10;        spindaContainer.addView(topRow)&#10;        spindaContainer.addView(formsContainer)&#10;        parent.addView(spindaContainer)&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;    private fun Int.dpToPx(): Int {&#10;        return (this * requireContext().resources.displayMetrics.density).toInt()&#10;    }&#10;&#10;    private fun updateSpindaFormSelection(formKey: String, isChecked: Boolean) {&#10;        val currentForms = filterPreferences.getEnabledSpindaForms().toMutableSet()&#10;        if (isChecked) {&#10;            currentForms.add(formKey)&#10;        } else {&#10;            currentForms.remove(formKey)&#10;        }&#10;        filterPreferences.saveEnabledSpindaForms(currentForms)&#10;        Log.d(&quot;FilterFragmentSpinda&quot;, &quot;Updated specific Spinda forms: $currentForms&quot;)&#10;    }&#10;&#10;&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (::questLayout.isInitialized) {&#10;            setupQuestFilters(questLayout)&#10;        }&#10;        if (::rocketLayoutGlobal.isInitialized) {&#10;            setupRocketFilters(rocketLayoutGlobal)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/RaidsFragment.kt" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.helpers.OverlayServiceManager&#10;import com.mints.projectgammatwo.recyclerviews.RaidsAdapter&#10;import com.mints.projectgammatwo.viewmodels.RaidsViewModel&#10;import androidx.core.net.toUri&#10;&#10;class RaidsFragment : Fragment() {&#10;&#10;    private val viewModel: RaidsViewModel by viewModels()&#10;    private lateinit var adapter: RaidsAdapter&#10;    private lateinit var swipeRefresh: SwipeRefreshLayout&#10;    private lateinit var serviceManager: OverlayServiceManager&#10;    private lateinit var scrollToTopFab: FloatingActionButton&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var errorHandlerText: TextView&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_raids, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        serviceManager = OverlayServiceManager(requireContext())&#10;&#10;        recyclerView = view.findViewById(R.id.raidsRecyclerView)&#10;        swipeRefresh = view.findViewById(R.id.swipeRefresh)&#10;        scrollToTopFab = view.findViewById(R.id.scrollToTopFab)&#10;        errorHandlerText = view.findViewById(R.id.errorHandlerText)&#10;&#10;        adapter = RaidsAdapter { raid -&gt;&#10;            viewModel.deleteRaid(raid)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = LinearLayoutManager(context)&#10;&#10;        setupScrollToTop()&#10;&#10;        swipeRefresh.setOnRefreshListener {&#10;            viewModel.fetchRaids()&#10;        }&#10;&#10;        viewModel.raidsLiveData.observe(viewLifecycleOwner) { raids -&gt;&#10;            adapter.submitList(raids)&#10;            swipeRefresh.isRefreshing = false&#10;&#10;            if (raids.isEmpty()) {&#10;                errorHandlerText.visibility = View.VISIBLE&#10;                errorHandlerText.text = &quot;No raids available. Please check your data sources in Settings.&quot;&#10;            } else {&#10;                errorHandlerText.visibility = View.GONE&#10;            }&#10;&#10;            recyclerView.post {&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { errorMessage -&gt;&#10;            if (errorMessage.isNotEmpty()) {&#10;                Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                swipeRefresh.isRefreshing = false&#10;            }&#10;        }&#10;&#10;        val raidsCountTextView = view.findViewById&lt;TextView&gt;(R.id.raidsCountText)&#10;        viewModel.raidsCountLiveData.observe(viewLifecycleOwner) { count -&gt;&#10;            raidsCountTextView.text = &quot;Total Raids: $count&quot;&#10;        }&#10;&#10;        val startServiceButton = view.findViewById&lt;Button&gt;(R.id.startServiceButton)&#10;        startServiceButton.setOnClickListener {&#10;            handleStartServiceClick()&#10;        }&#10;&#10;        viewModel.fetchRaids()&#10;        updateServiceButtonState(startServiceButton)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        view?.findViewById&lt;Button&gt;(R.id.startServiceButton)?.let {&#10;            updateServiceButtonState(it)&#10;        }&#10;        checkAndUpdateFabVisibility()&#10;    }&#10;&#10;    private fun setupScrollToTop() {&#10;        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {&#10;            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {&#10;                super.onScrolled(recyclerView, dx, dy)&#10;                checkAndUpdateFabVisibility()&#10;            }&#10;        })&#10;&#10;        adapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeInserted(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                super.onItemRangeRemoved(positionStart, itemCount)&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;&#10;            override fun onChanged() {&#10;                super.onChanged()&#10;                recyclerView.post { checkAndUpdateFabVisibility() }&#10;            }&#10;        })&#10;&#10;        scrollToTopFab.setOnClickListener {&#10;            recyclerView.scrollToPosition(0)&#10;        }&#10;    }&#10;&#10;    private fun checkAndUpdateFabVisibility() {&#10;        val layoutManager = recyclerView.layoutManager as? LinearLayoutManager ?: return&#10;&#10;        if (adapter.itemCount == 0) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;No items, hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;            return&#10;        }&#10;&#10;        val firstVisibleItem = layoutManager.findFirstVisibleItemPosition()&#10;        Log.d(&#10;            &quot;FAB_DEBUG&quot;,&#10;            &quot;First visible item: $firstVisibleItem, Total items: ${adapter.itemCount}&quot;&#10;        )&#10;&#10;        if (firstVisibleItem != RecyclerView.NO_POSITION &amp;&amp; firstVisibleItem &gt; 2) {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Showing FAB&quot;)&#10;            scrollToTopFab.show()&#10;        } else {&#10;            Log.d(&quot;FAB_DEBUG&quot;, &quot;Hiding FAB&quot;)&#10;            scrollToTopFab.hide()&#10;        }&#10;    }&#10;&#10;    private fun handleStartServiceClick() {&#10;        if (Settings.canDrawOverlays(requireContext())) {&#10;            serviceManager.startOverlayService(&quot;raids&quot;)&#10;            return&#10;        }&#10;&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_overlay_permission, null)&#10;&#10;        val notNowButton = dialogView.findViewById&lt;Button&gt;(R.id.notNowButton)&#10;        val openSettingsButton = dialogView.findViewById&lt;Button&gt;(R.id.openSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        builder.setCancelable(false)&#10;        val dialog = builder.create()&#10;&#10;        notNowButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        openSettingsButton.setOnClickListener {&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                &quot;package:${requireContext().packageName}&quot;.toUri()&#10;            )&#10;            startActivity(intent)&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun updateServiceButtonState(button: Button) {&#10;        val overlayPermission = Settings.canDrawOverlays(requireContext())&#10;        Log.d(&quot;PermissionStatus&quot;, &quot;Overlay permission: $overlayPermission&quot;)&#10;&#10;        if (!overlayPermission) {&#10;            button.text = &quot;Enable Overlay Permissions&quot;&#10;        } else {&#10;            button.text = &quot;Enable Overlay&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/ui/SettingsFragment.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedEntry&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.QuestFilterPreferences&#10;import androidx.core.content.edit&#10;import com.mints.projectgammatwo.data.ExportData&#10;import kotlin.jvm.java&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;    private val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(&quot;NYC&quot;)&#10;        checkboxLondon.isChecked = selectedSources.contains(&quot;LONDON&quot;)&#10;        checkboxSG.isChecked = selectedSources.contains(&quot;Singapore&quot;)&#10;        checkboxVancouver.isChecked = selectedSources.contains(&quot;VANCOUVER&quot;)&#10;        checkboxSydney.isChecked = selectedSources.contains(&quot;SYDNEY&quot;)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(&quot;NYC&quot;)&#10;            if (checkboxLondon.isChecked) newSelection.add(&quot;LONDON&quot;)&#10;            if (checkboxSG.isChecked) newSelection.add(&quot;Singapore&quot;)&#10;            if (checkboxVancouver.isChecked) newSelection.add(&quot;VANCOUVER&quot;)&#10;            if (checkboxSydney.isChecked) newSelection.add(&quot;SYDNEY&quot;)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(&quot;NYC&quot;)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        // Teleport method: load saved method.&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit().putString(KEY_TELEPORT_METHOD, method).apply()&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val savedCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(savedCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = &quot;Enter coords (e.g. 40.121, -32.121)&quot;&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), &quot;Coordinates saved: $coords&quot;, Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        &quot;Invalid coordinates format. Use: Lat, Long (e.g., 40.7128, -74.0060)&quot;,&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Keep previous valid value if available&#10;                    if (savedCoords.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(savedCoords)) {&#10;                        homeCoordinates.setText(savedCoords)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = &quot;${currentSize}dp&quot;&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = &quot;${progress}dp&quot;&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = &quot;${defaultSize}dp&quot;&#10;            &#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; &quot;Drag Handle&quot;&#10;            &quot;close_button&quot; -&gt; &quot;Close&quot;&#10;            &quot;right_button&quot; -&gt; &quot;Next&quot;&#10;            &quot;left_button&quot; -&gt; &quot;Previous&quot;&#10;            &quot;home_button&quot; -&gt; &quot;Home&quot;&#10;            &quot;refresh_button&quot; -&gt; &quot;Refresh&quot;&#10;            &quot;switch_modes&quot; -&gt; &quot;Switch Mode&quot;&#10;            &quot;filter_tab&quot; -&gt; &quot;Filters&quot;&#10;            &quot;favorites_tab&quot; -&gt; &quot;Favorites&quot;&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        val deletedEntries = deletedRepo.getDeletedEntries()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Deleted entries count: ${deletedEntries.size}&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            // you used QUEST_SPINDA_PREFIX = &quot;spinda_&quot;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            deletedEntries = deletedEntries,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, &quot;Exported Settings&quot;)&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, &quot;Share Settings JSON&quot;))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), &quot;Failed to export settings: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit().putString(KEY_FAVORITES, gson.toJson(importData.favorites)).apply()&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.deletedEntries.size} deleted entries&quot;)&#10;            deletedRepo.setDeletedEntries(importData.deletedEntries)&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters if available&#10;            if (importData.savedRocketFilters != null) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Found ${importData.savedRocketFilters.size} rocket filters to import&quot;)&#10;&#10;                // Check if savedRocketFilters field exists but is null&#10;                if (importData.savedRocketFilters == null) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;savedRocketFilters exists in class but null in instance&quot;)&#10;                }&#10;&#10;                // Clear existing filters first&#10;                val existingFilterNames = filterPreferences.listFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;                for (name in existingFilterNames) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                    filterPreferences.deleteFilter(name, &quot;Rocket&quot;)&#10;                }&#10;&#10;                // Import the filters&#10;                for ((name, characters) in importData.savedRocketFilters) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                    try {&#10;                        filterPreferences.saveEnabledCharacters(characters)&#10;                        filterPreferences.saveCurrentAsFilter(name)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Set active rocket filter if it exists in the imported data&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;                if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                    importData.savedRocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                    try {&#10;                        filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                        // If active, also load it&#10;                        filterPreferences.loadFilter(importData.activeRocketFilter, &quot;Rocket&quot;)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Verify filters were imported&#10;                val verifyFilters = filterPreferences.listFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Verification - Imported rocket filters: $verifyFilters&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;No rocket filters to import (null)&quot;)&#10;            }&#10;&#10;            // Import saved quest filters if available&#10;            if (importData.savedQuestFilters != null) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Found ${importData.savedQuestFilters.size} quest filters to import&quot;)&#10;&#10;                // Clear existing quest filters first&#10;                val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;                for (name in existingQuestFilterNames) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                    filterPreferences.deleteFilter(name, &quot;Quest&quot;)&#10;                }&#10;&#10;                // Import the quest filters&#10;                for ((name, questIds) in importData.savedQuestFilters) {&#10;                    // Convert quest IDs to strings for storage&#10;                    val questStrings = questIds.map { it.toString() }.toSet()&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;&#10;                    try {&#10;&#10;                        filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                        filterPreferences.saveCurrentQuestFilter(name)&#10;                        val forms = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                        filterPreferences.saveEnabledSpindaForms(forms)&#10;                        val questStringss = questIds.toSet()&#10;                        filterPreferences.saveEnabledQuestFilters(questStringss)&#10;                        filterPreferences.saveCurrentQuestFilter(name)&#10;&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Set active quest filter if it exists in the imported data&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;                if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                    importData.savedQuestFilters.containsKey(importData.activeQuestFilter)) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                    try {&#10;                        filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                        // If active, also load it&#10;                        filterPreferences.loadFilter(importData.activeQuestFilter, &quot;Quest&quot;)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Verify filters were imported&#10;                val verifyQuestFilters = filterPreferences.listQuestFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Verification - Imported quest filters: $verifyQuestFilters&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;No quest filters to import (null)&quot;)&#10;            }&#10;&#10;            // Update UI checkboxes.&#10;            checkboxNYC.isChecked = importData.dataSources.contains(&quot;NYC&quot;)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(&quot;LONDON&quot;)&#10;            checkboxSG.isChecked = importData.dataSources.contains(&quot;Singapore&quot;)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(&quot;VANCOUVER&quot;)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(&quot;SYDNEY&quot;)&#10;&#10;            // Import overlay customization settings&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button size: ${importData.overlayButtonSize}&quot;)&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button order: ${importData.overlayButtonOrder}&quot;)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button visibility: ${importData.overlayButtonVisibility}&quot;)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Settings import completed successfully&quot;)&#10;            Toast.makeText(requireContext(), &quot;Settings imported successfully&quot;, Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Log.e(&quot;SettingsImport&quot;, &quot;JSON that caused failure: ${jsonString.take(200)}...&quot;)&#10;            ex.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import settings: ${ex.message}&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.ui&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.text.Spanned&#10;import android.text.method.LinkMovementMethod&#10;import android.util.Log&#10;import android.view.*&#10;import android.widget.*&#10;import androidx.core.text.HtmlCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.ItemTouchHelper&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import com.mints.projectgammatwo.R&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.DeletedEntry&#10;import com.mints.projectgammatwo.data.DeletedInvasionsRepository&#10;import com.mints.projectgammatwo.data.FavoriteLocation&#10;import com.mints.projectgammatwo.data.FilterPreferences&#10;import com.mints.projectgammatwo.data.HomeCoordinatesManager&#10;import com.mints.projectgammatwo.data.QuestFilterPreferences&#10;import androidx.core.content.edit&#10;import com.mints.projectgammatwo.data.ExportData&#10;import kotlin.jvm.java&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    private lateinit var checkboxNYC: CheckBox&#10;    private lateinit var checkboxLondon: CheckBox&#10;    private lateinit var checkboxSG: CheckBox&#10;    private lateinit var checkboxVancouver: CheckBox&#10;    private lateinit var checkboxSydney: CheckBox&#10;    private lateinit var btnExportSettings: Button&#10;    private lateinit var btnImportSettings: Button&#10;    private lateinit var radioGroupTeleport: RadioGroup&#10;    private lateinit var radioIpogo: RadioButton&#10;    private lateinit var radioJoystick: RadioButton&#10;&#10;    private lateinit var dataSourcePreferences: DataSourcePreferences&#10;    private lateinit var filterPreferences: FilterPreferences&#10;    private lateinit var deletedRepo: DeletedInvasionsRepository&#10;    private lateinit var discordTextView: TextView&#10;    private lateinit var homeCoordinates: EditText&#10;    private lateinit var homeCoordinatesManager: HomeCoordinatesManager&#10;&#10;    // Overlay customization views&#10;    private lateinit var btnCustomizeOverlay: Button&#10;    private lateinit var customizationManager: com.mints.projectgammatwo.data.OverlayCustomizationManager&#10;&#10;    private val gson = Gson()&#10;&#10;    private val FAVORITES_PREFS_NAME = &quot;favorites_prefs&quot;&#10;    private val KEY_FAVORITES = &quot;favorites_list&quot;&#10;    private val TELEPORT_PREFS_NAME = &quot;teleport_prefs&quot;&#10;    private val KEY_TELEPORT_METHOD = &quot;teleport_method&quot;&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_settings, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        dataSourcePreferences = DataSourcePreferences(requireContext())&#10;        filterPreferences = FilterPreferences(requireContext())&#10;        deletedRepo = DeletedInvasionsRepository(requireContext())&#10;        homeCoordinatesManager = HomeCoordinatesManager.getInstance(requireContext())&#10;        customizationManager = com.mints.projectgammatwo.data.OverlayCustomizationManager(requireContext())&#10;&#10;        checkboxNYC = view.findViewById(R.id.checkbox_nyc)&#10;        checkboxLondon = view.findViewById(R.id.checkbox_london)&#10;        checkboxSG = view.findViewById(R.id.checkbox_sg)&#10;        checkboxVancouver = view.findViewById(R.id.checkbox_vancouver)&#10;        checkboxSydney = view.findViewById(R.id.checkbox_sydney)&#10;        btnExportSettings = view.findViewById(R.id.btnExportSettings)&#10;        btnImportSettings = view.findViewById(R.id.btnImportSettings)&#10;        radioGroupTeleport = view.findViewById(R.id.radioGroupTeleport)&#10;        radioIpogo = view.findViewById(R.id.radio_ipogo)&#10;        radioJoystick = view.findViewById(R.id.radio_joystick)&#10;        discordTextView = view.findViewById(R.id.discordInvite)&#10;        homeCoordinates = view.findViewById(R.id.homeCoordinates)&#10;        btnCustomizeOverlay = view.findViewById(R.id.btnCustomizeOverlay)&#10;&#10;        setupDiscordText()&#10;        setupDataSourceCheckboxes()&#10;        setupExportImportButtons()&#10;        setupTeleportMethod()&#10;        setupHomeCoordinatesField()&#10;        setupOverlayCustomization()&#10;    }&#10;&#10;    private fun setupDiscordText() {&#10;        discordTextView.text = HtmlCompat.fromHtml(getString(R.string.discord_link), HtmlCompat.FROM_HTML_MODE_LEGACY)&#10;        discordTextView.movementMethod = LinkMovementMethod.getInstance()&#10;        discordTextView.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (hasFocus) {&#10;                v.clearFocus()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupDataSourceCheckboxes() {&#10;        // Load data source selections.&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        checkboxNYC.isChecked = selectedSources.contains(&quot;NYC&quot;)&#10;        checkboxLondon.isChecked = selectedSources.contains(&quot;LONDON&quot;)&#10;        checkboxSG.isChecked = selectedSources.contains(&quot;Singapore&quot;)&#10;        checkboxVancouver.isChecked = selectedSources.contains(&quot;VANCOUVER&quot;)&#10;        checkboxSydney.isChecked = selectedSources.contains(&quot;SYDNEY&quot;)&#10;&#10;        // Data source check listener.&#10;        val checkListener = View.OnClickListener {&#10;            val newSelection = mutableSetOf&lt;String&gt;()&#10;            if (checkboxNYC.isChecked) newSelection.add(&quot;NYC&quot;)&#10;            if (checkboxLondon.isChecked) newSelection.add(&quot;LONDON&quot;)&#10;            if (checkboxSG.isChecked) newSelection.add(&quot;Singapore&quot;)&#10;            if (checkboxVancouver.isChecked) newSelection.add(&quot;VANCOUVER&quot;)&#10;            if (checkboxSydney.isChecked) newSelection.add(&quot;SYDNEY&quot;)&#10;            if (newSelection.isEmpty()) {&#10;                newSelection.add(&quot;NYC&quot;)&#10;                checkboxNYC.isChecked = true&#10;            }&#10;            dataSourcePreferences.setSelectedSources(newSelection)&#10;        }&#10;        checkboxNYC.setOnClickListener(checkListener)&#10;        checkboxLondon.setOnClickListener(checkListener)&#10;        checkboxSG.setOnClickListener(checkListener)&#10;        checkboxVancouver.setOnClickListener(checkListener)&#10;        checkboxSydney.setOnClickListener(checkListener)&#10;    }&#10;&#10;    private fun setupExportImportButtons() {&#10;        // Export settings.&#10;        btnExportSettings.setOnClickListener {&#10;            exportSettings()&#10;        }&#10;&#10;        // Import settings.&#10;        btnImportSettings.setOnClickListener {&#10;            importSettingsDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupTeleportMethod() {&#10;        // Teleport method: load saved method.&#10;        val teleportPrefs = requireContext().getSharedPreferences(TELEPORT_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val savedMethod = teleportPrefs.getString(KEY_TELEPORT_METHOD, &quot;ipogo&quot;) ?: &quot;ipogo&quot;&#10;        if (savedMethod == &quot;ipogo&quot;) {&#10;            radioIpogo.isChecked = true&#10;        } else {&#10;            radioJoystick.isChecked = true&#10;        }&#10;        radioGroupTeleport.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            val method = if (checkedId == R.id.radio_ipogo) &quot;ipogo&quot; else &quot;joystick&quot;&#10;            teleportPrefs.edit().putString(KEY_TELEPORT_METHOD, method).apply()&#10;        }&#10;    }&#10;&#10;    private fun setupHomeCoordinatesField() {&#10;        // Load saved coordinates&#10;        val savedCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        homeCoordinates.setText(savedCoords)&#10;&#10;        // Set input hint&#10;        homeCoordinates.hint = &quot;Enter coords (e.g. 40.121, -32.121)&quot;&#10;&#10;        // Set input type for decimal numbers and comma&#10;        homeCoordinates.inputType = InputType.TYPE_CLASS_TEXT&#10;&#10;        // Apply input filter for validation&#10;        homeCoordinates.filters = arrayOf(CoordinatesInputFilter())&#10;&#10;        // Save coordinates when focus changes&#10;        homeCoordinates.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val coords = homeCoordinates.text.toString().trim()&#10;                if (homeCoordinatesManager.validateCoordinates(coords)) {&#10;                    homeCoordinatesManager.saveHomeCoordinates(coords)&#10;                    Toast.makeText(requireContext(), &quot;Coordinates saved: $coords&quot;, Toast.LENGTH_SHORT).show()&#10;                } else if (coords.isNotEmpty()) {&#10;                    Toast.makeText(&#10;                        requireContext(),&#10;                        &quot;Invalid coordinates format. Use: Lat, Long (e.g., 40.7128, -74.0060)&quot;,&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    // Keep previous valid value if available&#10;                    if (savedCoords.isNotEmpty() &amp;&amp; homeCoordinatesManager.validateCoordinates(savedCoords)) {&#10;                        homeCoordinates.setText(savedCoords)&#10;                    } else {&#10;                        homeCoordinates.text.clear()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupOverlayCustomization() {&#10;        btnCustomizeOverlay.setOnClickListener {&#10;            showOverlayCustomizationDialog()&#10;        }&#10;    }&#10;&#10;    private fun restartOverlayService() {&#10;        // Check if overlay service is running by checking shared preferences or a flag&#10;        val sharedPrefs = requireContext().getSharedPreferences(&quot;overlay_prefs&quot;, Context.MODE_PRIVATE)&#10;        val isOverlayRunning = sharedPrefs.getBoolean(&quot;overlay_running&quot;, false)&#10;        val currentMode = sharedPrefs.getString(&quot;overlay_mode&quot;, &quot;invasions&quot;) ?: &quot;invasions&quot;&#10;        &#10;        if (isOverlayRunning) {&#10;            // Stop the service&#10;            val stopIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;            requireContext().stopService(stopIntent)&#10;            &#10;            // Wait a bit before restarting&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                // Restart the service&#10;                val startIntent = Intent(requireContext(), com.mints.projectgammatwo.services.OverlayService::class.java)&#10;                startIntent.putExtra(&quot;mode&quot;, currentMode)&#10;                &#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    requireContext().startForegroundService(startIntent)&#10;                } else {&#10;                    requireContext().startService(startIntent)&#10;                }&#10;            }, 500)&#10;        }&#10;    }&#10;&#10;    private fun showOverlayCustomizationDialog() {&#10;        val dialogView = LayoutInflater.from(requireContext())&#10;            .inflate(R.layout.dialog_overlay_customization, null)&#10;&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;&#10;        // Set up button size slider&#10;        val sizeSeekbar = dialogView.findViewById&lt;SeekBar&gt;(R.id.size_seekbar)&#10;        val sizeValue = dialogView.findViewById&lt;TextView&gt;(R.id.size_value)&#10;        val currentSize = customizationManager.getButtonSize()&#10;&#10;        sizeSeekbar.progress = currentSize&#10;        sizeValue.text = &quot;${currentSize}dp&quot;&#10;&#10;        sizeSeekbar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                sizeValue.text = &quot;${progress}dp&quot;&#10;            }&#10;&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {&#10;                val newSize = seekBar?.progress ?: 48&#10;                customizationManager.saveButtonSize(newSize)&#10;                restartOverlayService()&#10;            }&#10;        })&#10;&#10;        // Set up RecyclerView for buttons&#10;        val recyclerView = dialogView.findViewById&lt;RecyclerView&gt;(R.id.buttons_recycler_view)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val buttonOrder = customizationManager.getButtonOrder()&#10;        val buttonVisibility = customizationManager.getButtonVisibility()&#10;&#10;        // Filter out drag_handle from the list since it can't be changed&#10;        val buttonItems = buttonOrder&#10;            .filter { it != &quot;drag_handle&quot; }&#10;            .map { buttonId -&gt;&#10;                com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                    id = buttonId,&#10;                    name = getButtonDisplayName(buttonId),&#10;                    iconResId = getButtonIcon(buttonId),&#10;                    isVisible = buttonVisibility[buttonId] ?: true,&#10;                    isRequired = buttonId == &quot;close_button&quot;&#10;                )&#10;            }.toMutableList()&#10;&#10;        // Set up ItemTouchHelper for drag-and-drop FIRST (before creating adapter)&#10;        var itemTouchHelper: ItemTouchHelper? = null&#10;&#10;        val adapter = com.mints.projectgammatwo.recyclerviews.OverlayCustomizationAdapter(&#10;            items = buttonItems,&#10;            onItemChanged = { updatedItems -&gt;&#10;                // Re-add drag_handle at the beginning when saving&#10;                val newOrder = listOf(&quot;drag_handle&quot;) + updatedItems.map { it.id }&#10;                val newVisibility = updatedItems.associate { it.id to it.isVisible }.toMutableMap()&#10;                newVisibility[&quot;drag_handle&quot;] = true // Always visible&#10;                customizationManager.saveButtonOrder(newOrder)&#10;                customizationManager.saveButtonVisibility(newVisibility)&#10;                restartOverlayService()&#10;            },&#10;            onStartDrag = { viewHolder -&gt;&#10;                itemTouchHelper?.startDrag(viewHolder)&#10;            }&#10;        )&#10;&#10;        recyclerView.adapter = adapter&#10;&#10;        // Force RecyclerView to properly layout its items&#10;        recyclerView.post {&#10;            adapter.notifyDataSetChanged()&#10;            recyclerView.requestLayout()&#10;        }&#10;&#10;        // Now initialize itemTouchHelper (all items can be dragged now)&#10;        itemTouchHelper = ItemTouchHelper(&#10;            com.mints.projectgammatwo.helpers.ItemTouchHelperCallback(object : com.mints.projectgammatwo.helpers.ItemTouchHelperAdapter {&#10;                override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {&#10;                    return adapter.onItemMove(fromPosition, toPosition)&#10;                }&#10;            })&#10;        )&#10;        itemTouchHelper.attachToRecyclerView(recyclerView)&#10;&#10;        // Set up reset button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.reset_button).setOnClickListener {&#10;            customizationManager.resetToDefaults()&#10;            &#10;            // Update the current dialog without dismissing it&#10;            val newButtonOrder = customizationManager.getButtonOrder()&#10;            val newButtonVisibility = customizationManager.getButtonVisibility()&#10;            &#10;            // Filter out drag_handle again&#10;            val newButtonItems = newButtonOrder&#10;                .filter { it != &quot;drag_handle&quot; }&#10;                .map { buttonId -&gt;&#10;                    com.mints.projectgammatwo.recyclerviews.OverlayButtonItem(&#10;                        id = buttonId,&#10;                        name = getButtonDisplayName(buttonId),&#10;                        iconResId = getButtonIcon(buttonId),&#10;                        isVisible = newButtonVisibility[buttonId] ?: true,&#10;                        isRequired = buttonId == &quot;close_button&quot;&#10;                    )&#10;                }&#10;            &#10;            adapter.updateItems(newButtonItems)&#10;            &#10;            // Update size slider&#10;            val defaultSize = customizationManager.getButtonSize()&#10;            sizeSeekbar.progress = defaultSize&#10;            sizeValue.text = &quot;${defaultSize}dp&quot;&#10;            &#10;            restartOverlayService()&#10;        }&#10;&#10;        // Set up close button&#10;        dialogView.findViewById&lt;Button&gt;(R.id.close_button).setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun getButtonDisplayName(buttonId: String): String {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; &quot;Drag Handle&quot;&#10;            &quot;close_button&quot; -&gt; &quot;Close&quot;&#10;            &quot;right_button&quot; -&gt; &quot;Next&quot;&#10;            &quot;left_button&quot; -&gt; &quot;Previous&quot;&#10;            &quot;home_button&quot; -&gt; &quot;Home&quot;&#10;            &quot;refresh_button&quot; -&gt; &quot;Refresh&quot;&#10;            &quot;switch_modes&quot; -&gt; &quot;Switch Mode&quot;&#10;            &quot;filter_tab&quot; -&gt; &quot;Filters&quot;&#10;            &quot;favorites_tab&quot; -&gt; &quot;Favorites&quot;&#10;            else -&gt; buttonId&#10;        }&#10;    }&#10;&#10;    private fun getButtonIcon(buttonId: String): Int {&#10;        return when (buttonId) {&#10;            &quot;drag_handle&quot; -&gt; R.drawable.ic_drag_handle_overlay&#10;            &quot;close_button&quot; -&gt; R.drawable.close_24px&#10;            &quot;right_button&quot; -&gt; R.drawable.arrow_right_24px&#10;            &quot;left_button&quot; -&gt; R.drawable.arrow_left_24px&#10;            &quot;home_button&quot; -&gt; R.drawable.home_24px&#10;            &quot;refresh_button&quot; -&gt; R.drawable.refresh_24px&#10;            &quot;switch_modes&quot; -&gt; R.drawable.team_rocket_logo&#10;            &quot;filter_tab&quot; -&gt; R.drawable.tune_24px&#10;            &quot;favorites_tab&quot; -&gt; R.drawable.ic_favorite&#10;            else -&gt; R.drawable.ic_launcher_foreground&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Custom input filter for coordinates validation&#10;     */&#10;    inner class CoordinatesInputFilter : InputFilter {&#10;        override fun filter(&#10;            source: CharSequence,&#10;            start: Int,&#10;            end: Int,&#10;            dest: Spanned,&#10;            dstart: Int,&#10;            dend: Int&#10;        ): CharSequence? {&#10;            val input = dest.toString().substring(0, dstart) +&#10;                    source.toString().substring(start, end) +&#10;                    dest.toString().substring(dend)&#10;&#10;            // Allow empty field for clearing&#10;            if (input.isEmpty()) return null&#10;&#10;            // Allow partial valid input for coordinates&#10;            // Valid chars: digits, minus sign, period, comma, space&#10;            val validChars = &quot;0123456789-., &quot;&#10;            for (i in start until end) {&#10;                if (!validChars.contains(source[i])) {&#10;                    return &quot;&quot;&#10;                }&#10;            }&#10;&#10;            return null&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Exports settings to a JSON string and launches a share intent.&#10;     */&#10;    private fun exportSettings() {&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Starting export process&quot;)&#10;        val dataSources = dataSourcePreferences.getSelectedSources()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Data sources: $dataSources&quot;)&#10;&#10;        val enabledCharacters = filterPreferences.getEnabledCharacters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled characters: $enabledCharacters&quot;)&#10;&#10;        val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;        val favoritesJson = favoritesPrefs.getString(KEY_FAVORITES, &quot;[]&quot;)&#10;        val favoritesType = object : TypeToken&lt;List&lt;FavoriteLocation&gt;&gt;() {}.type&#10;        val favorites: List&lt;FavoriteLocation&gt; = gson.fromJson(favoritesJson, favoritesType)&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Favorites count: ${favorites.size}&quot;)&#10;&#10;        val enabledQuests = filterPreferences.getEnabledQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Enabled quests: $enabledQuests&quot;)&#10;&#10;        val deletedEntries = deletedRepo.getDeletedEntries()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Deleted entries count: ${deletedEntries.size}&quot;)&#10;&#10;        // Get home coordinates from manager&#10;        val homeCoords = homeCoordinatesManager.getHomeCoordinatesString()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Home coordinates: $homeCoords&quot;)&#10;&#10;        // Get all saved rocket filters&#10;        val savedRocketFilters = filterPreferences.getAllSavedFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved rocket filters: ${savedRocketFilters.keys}&quot;)&#10;&#10;        // Get all saved quest filters&#10;        val savedQuestFilters = filterPreferences.getSavedQuestFilters()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Saved quest filters: ${savedQuestFilters.keys}&quot;)&#10;        val savedQuestSpindaForms = savedQuestFilters.keys.associateWith { name -&gt;&#10;            // you used QUEST_SPINDA_PREFIX = &quot;spinda_&quot;&#10;            requireContext()&#10;                .getSharedPreferences(&quot;quest_filters&quot;, Context.MODE_PRIVATE)&#10;                .getStringSet(&quot;spinda_$name&quot;, emptySet())!!&#10;        }&#10;&#10;        // Get active filter names&#10;        val activeRocketFilter = filterPreferences.getActiveRocketFilter()&#10;        val activeQuestFilter = filterPreferences.getActiveQuestFilter()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Active filters - Rocket: $activeRocketFilter, Quest: $activeQuestFilter&quot;)&#10;&#10;        // Get overlay customization settings&#10;        val overlayButtonSize = customizationManager.getButtonSize()&#10;        val overlayButtonOrder = customizationManager.getButtonOrder()&#10;        val overlayButtonVisibility = customizationManager.getButtonVisibility()&#10;        Log.d(&quot;SettingsExport&quot;, &quot;Overlay customization - Size: $overlayButtonSize, Order: $overlayButtonOrder&quot;)&#10;&#10;        val exportData = ExportData(&#10;            dataSources = dataSources,&#10;            enabledCharacters = enabledCharacters,&#10;            favorites = favorites,&#10;            deletedEntries = deletedEntries,&#10;            enabledQuests = enabledQuests,&#10;            homeCoordinates = homeCoords,&#10;            savedRocketFilters = savedRocketFilters,&#10;            savedQuestFilters = savedQuestFilters,&#10;            savedQuestSpindaForms = savedQuestSpindaForms,&#10;            activeRocketFilter = activeRocketFilter,&#10;            activeQuestFilter = activeQuestFilter,&#10;            overlayButtonSize = overlayButtonSize,&#10;            overlayButtonOrder = overlayButtonOrder,&#10;            overlayButtonVisibility = overlayButtonVisibility&#10;        )&#10;&#10;        try {&#10;            val exportJson = gson.toJson(exportData)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON created successfully, length: ${exportJson.length}&quot;)&#10;            Log.d(&quot;SettingsExport&quot;, &quot;JSON sample: ${exportJson.take(100)}...&quot;)&#10;&#10;            val shareIntent = Intent(Intent.ACTION_SEND).apply {&#10;                type = &quot;text/plain&quot;&#10;                putExtra(Intent.EXTRA_SUBJECT, &quot;Exported Settings&quot;)&#10;                putExtra(Intent.EXTRA_TEXT, exportJson)&#10;            }&#10;            Log.d(&quot;SettingsExport&quot;, &quot;Starting share intent&quot;)&#10;            startActivity(Intent.createChooser(shareIntent, &quot;Share Settings JSON&quot;))&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;SettingsExport&quot;, &quot;Error creating JSON: ${e.message}&quot;, e)&#10;            Toast.makeText(requireContext(), &quot;Failed to export settings: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays a dialog for importing settings from JSON.&#10;     */&#10;    private fun importSettingsDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        val inflater = requireActivity().layoutInflater&#10;        val dialogView = inflater.inflate(R.layout.dialog_import_settings, null)&#10;&#10;        val editText = dialogView.findViewById&lt;EditText&gt;(R.id.editImportSettingsJson)&#10;        val cancelButton = dialogView.findViewById&lt;Button&gt;(R.id.cancelSettingsImportButton)&#10;        val importButton = dialogView.findViewById&lt;Button&gt;(R.id.importSettingsButton)&#10;&#10;        builder.setView(dialogView)&#10;        val dialog = builder.create()&#10;&#10;        // Set up button click listeners&#10;        cancelButton.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;&#10;        importButton.setOnClickListener {&#10;            val jsonString = editText.text.toString()&#10;            if (jsonString.isBlank()) {&#10;                Toast.makeText(requireContext(), &quot;Input cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                importSettings(jsonString)&#10;                dialog.dismiss()&#10;            }&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Imports settings from the provided JSON string.&#10;     */&#10;    private fun importSettings(jsonString: String) {&#10;        try {&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Starting import process with JSON: ${jsonString.take(100)}...&quot;)&#10;&#10;            val importData = gson.fromJson(jsonString, ExportData::class.java)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Successfully parsed JSON into ExportData&quot;)&#10;&#10;            // Basic settings import&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing data sources: ${importData.dataSources}&quot;)&#10;            dataSourcePreferences.setSelectedSources(importData.dataSources)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled characters: ${importData.enabledCharacters}&quot;)&#10;            filterPreferences.saveEnabledCharacters(importData.enabledCharacters)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing enabled quests: ${importData.enabledQuests}&quot;)&#10;            filterPreferences.saveEnabledQuestFilters(importData.enabledQuests)&#10;&#10;            val favoritesPrefs = requireContext().getSharedPreferences(FAVORITES_PREFS_NAME, Context.MODE_PRIVATE)&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.favorites.size} favorites&quot;)&#10;            favoritesPrefs.edit().putString(KEY_FAVORITES, gson.toJson(importData.favorites)).apply()&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing ${importData.deletedEntries.size} deleted entries&quot;)&#10;            deletedRepo.setDeletedEntries(importData.deletedEntries)&#10;&#10;            // Import home coordinates if available and valid&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing home coordinates: ${importData.homeCoordinates}&quot;)&#10;            if (importData.homeCoordinates.isNotEmpty() &amp;&amp;&#10;                homeCoordinatesManager.validateCoordinates(importData.homeCoordinates)) {&#10;                homeCoordinatesManager.saveHomeCoordinates(importData.homeCoordinates)&#10;                homeCoordinates.setText(importData.homeCoordinates)&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates imported successfully&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Home coordinates empty or invalid&quot;)&#10;            }&#10;&#10;            // Import saved rocket filters if available&#10;            if (importData.savedRocketFilters != null) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Found ${importData.savedRocketFilters.size} rocket filters to import&quot;)&#10;&#10;                // Check if savedRocketFilters field exists but is null&#10;                if (importData.savedRocketFilters == null) {&#10;                    Log.e(&quot;SettingsImport&quot;, &quot;savedRocketFilters exists in class but null in instance&quot;)&#10;                }&#10;&#10;                // Clear existing filters first&#10;                val existingFilterNames = filterPreferences.listFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingFilterNames.size} existing rocket filters: $existingFilterNames&quot;)&#10;                for (name in existingFilterNames) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Deleting rocket filter: $name&quot;)&#10;                    filterPreferences.deleteFilter(name, &quot;Rocket&quot;)&#10;                }&#10;&#10;                // Import the filters&#10;                for ((name, characters) in importData.savedRocketFilters) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Importing rocket filter '$name' with ${characters.size} characters: $characters&quot;)&#10;                    try {&#10;                        filterPreferences.saveEnabledCharacters(characters)&#10;                        filterPreferences.saveCurrentAsFilter(name)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved rocket filter: $name&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error saving rocket filter '$name': ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Set active rocket filter if it exists in the imported data&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Active rocket filter from import: ${importData.activeRocketFilter}&quot;)&#10;                if (importData.activeRocketFilter.isNotEmpty() &amp;&amp;&#10;                    importData.savedRocketFilters.containsKey(importData.activeRocketFilter)) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Setting active rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                    try {&#10;                        filterPreferences.setActiveRocketFilter(importData.activeRocketFilter)&#10;                        // If active, also load it&#10;                        filterPreferences.loadFilter(importData.activeRocketFilter, &quot;Rocket&quot;)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated rocket filter: ${importData.activeRocketFilter}&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error activating rocket filter: ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Verify filters were imported&#10;                val verifyFilters = filterPreferences.listFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Verification - Imported rocket filters: $verifyFilters&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;No rocket filters to import (null)&quot;)&#10;            }&#10;&#10;            // Import saved quest filters if available&#10;            if (importData.savedQuestFilters != null) {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Found ${importData.savedQuestFilters.size} quest filters to import&quot;)&#10;&#10;                // Clear existing quest filters first&#10;                val existingQuestFilterNames = filterPreferences.listQuestFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Clearing ${existingQuestFilterNames.size} existing quest filters: $existingQuestFilterNames&quot;)&#10;                for (name in existingQuestFilterNames) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Deleting quest filter: $name&quot;)&#10;                    filterPreferences.deleteFilter(name, &quot;Quest&quot;)&#10;                }&#10;&#10;                // Import the quest filters&#10;                for ((name, questIds) in importData.savedQuestFilters) {&#10;                    // Convert quest IDs to strings for storage&#10;                    val questStrings = questIds.map { it.toString() }.toSet()&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Importing quest filter '$name' with ${questStrings.size} quests: $questStrings&quot;)&#10;&#10;                    try {&#10;&#10;                        filterPreferences.saveEnabledQuestFilters(questStrings)&#10;                        filterPreferences.saveCurrentQuestFilter(name)&#10;                        val forms = importData.savedQuestSpindaForms[name] ?: emptySet()&#10;                        filterPreferences.saveEnabledSpindaForms(forms)&#10;                        val questStringss = questIds.toSet()&#10;                        filterPreferences.saveEnabledQuestFilters(questStringss)&#10;                        filterPreferences.saveCurrentQuestFilter(name)&#10;&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully saved quest filter: $name&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error saving quest filter '$name': ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Set active quest filter if it exists in the imported data&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Active quest filter from import: ${importData.activeQuestFilter}&quot;)&#10;                if (importData.activeQuestFilter.isNotEmpty() &amp;&amp;&#10;                    importData.savedQuestFilters.containsKey(importData.activeQuestFilter)) {&#10;                    Log.d(&quot;SettingsImport&quot;, &quot;Setting active quest filter: ${importData.activeQuestFilter}&quot;)&#10;                    try {&#10;                        filterPreferences.setActiveQuestFilter(importData.activeQuestFilter)&#10;                        // If active, also load it&#10;                        filterPreferences.loadFilter(importData.activeQuestFilter, &quot;Quest&quot;)&#10;                        Log.d(&quot;SettingsImport&quot;, &quot;Successfully activated quest filter: ${importData.activeQuestFilter}&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;SettingsImport&quot;, &quot;Error activating quest filter: ${e.message}&quot;, e)&#10;                    }&#10;                }&#10;&#10;                // Verify filters were imported&#10;                val verifyQuestFilters = filterPreferences.listQuestFilterNames()&#10;                Log.d(&quot;SettingsImport&quot;, &quot;Verification - Imported quest filters: $verifyQuestFilters&quot;)&#10;            } else {&#10;                Log.d(&quot;SettingsImport&quot;, &quot;No quest filters to import (null)&quot;)&#10;            }&#10;&#10;            // Update UI checkboxes.&#10;            checkboxNYC.isChecked = importData.dataSources.contains(&quot;NYC&quot;)&#10;            checkboxLondon.isChecked = importData.dataSources.contains(&quot;LONDON&quot;)&#10;            checkboxSG.isChecked = importData.dataSources.contains(&quot;Singapore&quot;)&#10;            checkboxVancouver.isChecked = importData.dataSources.contains(&quot;VANCOUVER&quot;)&#10;            checkboxSydney.isChecked = importData.dataSources.contains(&quot;SYDNEY&quot;)&#10;&#10;            // Import overlay customization settings&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button size: ${importData.overlayButtonSize}&quot;)&#10;            customizationManager.saveButtonSize(importData.overlayButtonSize)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button order: ${importData.overlayButtonOrder}&quot;)&#10;            customizationManager.saveButtonOrder(importData.overlayButtonOrder)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Importing overlay button visibility: ${importData.overlayButtonVisibility}&quot;)&#10;            customizationManager.saveButtonVisibility(importData.overlayButtonVisibility)&#10;&#10;            Log.d(&quot;SettingsImport&quot;, &quot;Settings import completed successfully&quot;)&#10;            Toast.makeText(requireContext(), &quot;Settings imported successfully&quot;, Toast.LENGTH_LONG).show()&#10;        } catch (ex: Exception) {&#10;            Log.e(&quot;SettingsImport&quot;, &quot;Import failed with exception: ${ex.message}&quot;, ex)&#10;            Log.e(&quot;SettingsImport&quot;, &quot;JSON that caused failure: ${jsonString.take(200)}...&quot;)&#10;            ex.printStackTrace()&#10;            Toast.makeText(requireContext(), &quot;Failed to import settings: ${ex.message}&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mints/projectgammatwo/viewmodels/RaidsViewModel.kt" />
              <option name="originalContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;QuestsViewModel&quot;, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.mints.projectgammatwo.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import android.util.Log.e&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.gson.JsonSyntaxException&#10;import com.mints.projectgammatwo.data.ApiClient&#10;import com.mints.projectgammatwo.data.DataSourcePreferences&#10;import com.mints.projectgammatwo.data.Quests&#10;import com.mints.projectgammatwo.data.QuestsApiService&#10;import com.mints.projectgammatwo.data.RaidApiService&#10;import com.mints.projectgammatwo.data.Raids&#10;import com.mints.projectgammatwo.data.Raids.RaidsResponse&#10;import com.mints.projectgammatwo.data.Raids.Raid&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import okio.IOException&#10;import retrofit2.HttpException&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;class RaidsViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _raidsLiveData = MutableLiveData&lt;List&lt;Raid&gt;&gt;()&#10;    val raidsLiveData: LiveData&lt;List&lt;Raid&gt;&gt; = _raidsLiveData&#10;&#10;    private val _raidsCountLiveData = MutableLiveData&lt;Int&gt;()&#10;    val raidsCountLiveData: LiveData&lt;Int&gt; = _raidsCountLiveData&#10;&#10;    private val _filterSizeLiveData = MutableLiveData&lt;Int&gt;()&#10;    val filterSizeLiveData: LiveData&lt;Int&gt; = _filterSizeLiveData&#10;&#10;&#10;    private val _error = MutableLiveData&lt;String&gt;()&#10;    val error: LiveData&lt;String&gt; get() = _error&#10;&#10;    val tag = &quot;RaidsViewModel&quot;&#10;&#10;    fun fetchRaids() {&#10;        Log.d(tag, &quot;Starting fetchRaids...&quot;)&#10;        val context = getApplication&lt;Application&gt;().applicationContext&#10;        val dataSourcePreferences = DataSourcePreferences(context)&#10;&#10;        val selectedSources = dataSourcePreferences.getSelectedSources()&#10;        val interceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.NONE&#10;        }&#10;        val client = OkHttpClient.Builder().addInterceptor(interceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(tag, &quot;Selected data sources: $selectedSources&quot;)&#10;                val deferredList = selectedSources.mapNotNull { source -&gt;&#10;                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl -&gt;&#10;                        async(Dispatchers.IO) {&#10;                            try {&#10;                                val retrofit = Retrofit.Builder()&#10;                                    .baseUrl(baseUrl)&#10;                                    .addConverterFactory(GsonConverterFactory.create())&#10;                                    .client(client)&#10;                                    .build()&#10;                                val service = retrofit.create(RaidApiService::class.java)&#10;&#10;                                val response =&#10;                                    service.getRaids(System.currentTimeMillis()).execute()&#10;&#10;                                // Check if the response is successful&#10;                                if (response.isSuccessful) {&#10;                                    Log.d(tag, &quot;API call successful for source $source&quot;)&#10;                                    Pair(source, Result.success(response))&#10;                                } else {&#10;                                    // Handle HTTP errors (4xx, 5xx)&#10;                                    val errorMsg = &quot;HTTP ${response.code()}: ${response.message()}&quot;&#10;                                    Log.w(tag, &quot;API error for source $source: $errorMsg&quot;)&#10;                                    Pair(&#10;                                        source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                            HttpException(response)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            } catch (e: IOException) {&#10;                                // Network connectivity issues, timeouts&#10;                                Log.e(tag, &quot;Network error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;Network error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;&#10;                            } catch (e: HttpException) {&#10;                                // HTTP errors (if using suspend functions)&#10;                                Log.e(tag, &quot;HTTP error for source $source: ${e.code()}&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        e&#10;                                    )&#10;                                )&#10;                            } catch (e: JsonSyntaxException) {&#10;                                // JSON parsing errors&#10;                                Log.e(tag, &quot;JSON parsing error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        IOException(&quot;JSON parsing error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                // Any other unexpected errors&#10;                                Log.e(tag, &quot;Unexpected error for source $source&quot;, e)&#10;                                Pair(&#10;                                    source, Result.failure&lt;retrofit2.Response&lt;RaidsResponse&gt;&gt;(&#10;                                        Exception(&quot;Unexpected error for source $source&quot;, e)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                val responses = deferredList.map { it.await() }&#10;&#10;                // Filter successful responses&#10;                val successfulResponses = responses.mapNotNull { (source, result) -&gt;&#10;                    result.getOrNull()?.let { response -&gt;&#10;                        Pair(source, response)&#10;                    }&#10;                }&#10;&#10;                // If no successful responses, handle the error state&#10;                if (successfulResponses.isEmpty()) {&#10;                    Log.w(tag, &quot;No successful API responses received&quot;)&#10;                    _raidsLiveData.postValue(emptyList())&#10;                    _raidsCountLiveData.postValue(0)&#10;                    _filterSizeLiveData.postValue(0)&#10;                    _error.postValue(&quot;Unable to fetch raids. Please check your connection.&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Process successful responses&#10;                val combinedRaids = successfulResponses.flatMap { (source, response) -&gt;&#10;                    response.body()?.raids?.map { raid -&gt;&#10;                        raid.copy(source = source)&#10;                    } ?: emptyList()&#10;                }.toMutableList()&#10;&#10;                // Filter raids (you might want to add filtering preferences similar to HomeViewModel)&#10;                val filteredRaids = combinedRaids&#10;                    .filter { raid -&gt;&#10;                        // Add any filtering logic here&#10;                        // For now, we'll include all raids&#10;                        true&#10;                    }&#10;                    .sortedBy { it.raid_start }&#10;                    .reversed()&#10;&#10;                // Update LiveData&#10;                _raidsLiveData.postValue(filteredRaids)&#10;                _raidsCountLiveData.postValue(filteredRaids.size)&#10;                _filterSizeLiveData.postValue(filteredRaids.size)&#10;&#10;                Log.d(tag, &quot;Successfully fetched raids from ${successfulResponses.size} sources. Total raids: ${filteredRaids.size}&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                e(tag, &quot;Error in fetchRaids&quot;, e)&#10;                _raidsLiveData.postValue(emptyList())&#10;                _raidsCountLiveData.postValue(0)&#10;                _filterSizeLiveData.postValue(0)&#10;                _error.postValue(&quot;An unexpected error occurred&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getRaids(): List&lt;Raid&gt;? {&#10;        return _raidsLiveData.value&#10;    }&#10;&#10;    // Method to handle raid deletion (if needed)&#10;    fun deleteRaid(raid: Raid) {&#10;        _raidsLiveData.value = _raidsLiveData.value?.toMutableList()?.apply { remove(raid) }&#10;        _raidsCountLiveData.value = _raidsLiveData.value?.size ?: 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:id=&quot;@+id/appBarLayout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/CustomToolbarTheme&quot;&#10;            app:popupTheme=&quot;@style/OverflowMenuTheme&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.fragment.app.FragmentContainerView&#10;        android:id=&quot;@+id/nav_host_fragment&quot;&#10;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&#10;        app:layout_constraintRight_toRightOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/appBarLayout&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/bottomNav&quot;&#10;        app:defaultNavHost=&quot;true&quot;&#10;        app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.bottomnavigation.BottomNavigationView&#10;        android:id=&quot;@+id/bottomNav&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:menu=&quot;@menu/bottom_nav_menu&quot; /&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.ui.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:id=&quot;@+id/appBarLayout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/CustomToolbarTheme&quot;&#10;            app:popupTheme=&quot;@style/OverflowMenuTheme&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.fragment.app.FragmentContainerView&#10;        android:id=&quot;@+id/nav_host_fragment&quot;&#10;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&#10;        app:layout_constraintRight_toRightOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/appBarLayout&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/bottomNav&quot;&#10;        app:defaultNavHost=&quot;true&quot;&#10;        app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.bottomnavigation.BottomNavigationView&#10;        android:id=&quot;@+id/bottomNav&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:menu=&quot;@menu/bottom_nav_menu&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_overlay_settings.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_confirm_import_hotspots.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmTitle&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import Hotspots&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Message --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/confirmMessage&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;This will import all hotspot locations to your favorites. Do you want to continue?&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmTitle&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Cancel Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/cancelConfirmButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Cancel&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/confirmImportButton&quot; /&gt;&#10;&#10;    &lt;!-- Confirm Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/confirmImportButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Import&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/confirmMessage&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/cancelConfirmButton&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_overlay_button_customization.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:background=&quot;?android:attr/selectableItemBackground&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle for reordering --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/drag_icon&quot;&#10;        android:layout_width=&quot;24dp&quot;&#10;        android:layout_height=&quot;24dp&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        android:contentDescription=&quot;Drag to reorder&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Icon Preview --&gt;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/button_icon&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:contentDescription=&quot;Button icon&quot;&#10;        app:tint=&quot;?android:attr/textColorPrimary&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/drag_icon&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Button Name --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/button_name&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;12dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:textColor=&quot;?android:attr/textColorPrimary&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/button_icon&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/visibility_switch&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Visibility Switch --&gt;&#10;    &lt;androidx.appcompat.widget.SwitchCompat&#10;        android:id=&quot;@+id/visibility_switch&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/overlay_customization_layout.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;320dp&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:background=&quot;@android:color/background_dark&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Drag Handle --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/drag_handle&quot;&#10;        android:layout_width=&quot;48dp&quot;&#10;        android:layout_height=&quot;48dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Drag handle&quot;&#10;        android:src=&quot;@drawable/ic_drag_handle_overlay&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Title --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/title&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:text=&quot;Customize Overlay&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/drag_handle&quot; /&gt;&#10;&#10;    &lt;!-- Close Button --&gt;&#10;    &lt;ImageButton&#10;        android:id=&quot;@+id/close_customization_button&quot;&#10;        android:layout_width=&quot;36dp&quot;&#10;        android:layout_height=&quot;36dp&quot;&#10;        android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&#10;        android:contentDescription=&quot;Close&quot;&#10;        android:src=&quot;@drawable/close_24px&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/title&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;!-- Button Size Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Size:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/title&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/size_value&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;48dp&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;SeekBar&#10;        android:id=&quot;@+id/size_seekbar&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:max=&quot;64&quot;&#10;        android:min=&quot;32&quot;&#10;        android:progress=&quot;48&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_label&quot; /&gt;&#10;&#10;    &lt;!-- Button Visibility Section --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/visibility_label&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Button Visibility:&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/size_seekbar&quot; /&gt;&#10;&#10;    &lt;!-- RecyclerView for button customization --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/buttons_recycler_view&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;8dp&quot;&#10;        android:maxHeight=&quot;300dp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/visibility_label&quot; /&gt;&#10;&#10;    &lt;!-- Reset Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/reset_button&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:text=&quot;Reset to Defaults&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/buttons_recycler_view&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/menu/favorites_menu.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/menu/favorites_menu.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;item&#10;        android:id=&quot;@+id/menu_import_favorites&quot;&#10;        android:title=&quot;Import Favorites&quot; /&gt;&#10;&#10;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_sortByName&quot;&#10;        android:title=&quot;Sort By Name&quot;/&gt;&#10;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_sortByDefault&quot;&#10;        android:title=&quot;Sort By Order Added&quot;/&gt;&#10;&#10;&#10;&lt;/menu&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;item&#10;        android:id=&quot;@+id/menu_import_favorites&quot;&#10;        android:title=&quot;Import Favorites&quot; /&gt;&#10;&#10;    &lt;item&#10;        android:id=&quot;@+id/menu_import_hotspots&quot;&#10;        android:title=&quot;Import Hotspots&quot; /&gt;&#10;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_sortByName&quot;&#10;        android:title=&quot;Sort By Name&quot;/&gt;&#10;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_sortByDefault&quot;&#10;        android:title=&quot;Sort By Order Added&quot;/&gt;&#10;&#10;&#10;&lt;/menu&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/raw/hotspots.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/raw/hotspots.txt" />
              <option name="updatedContent" value="[&#10;    {&#10;        &quot;name&quot;: &quot;Kiritimati&quot;,&#10;        &quot;lat&quot;: 1.98715,&#10;        &quot;lng&quot;: -157.47714&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Pago Pago&quot;,&#10;        &quot;lat&quot;: -14.27859,&#10;        &quot;lng&quot;: -170.68886&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sau Paulo Brazil&quot;,&#10;        &quot;lat&quot;: -23.58659,&#10;        &quot;lng&quot;: -46.65702&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sau Luis Brazil&quot;,&#10;        &quot;lat&quot;: -2.5578,&#10;        &quot;lng&quot;: -44.30924&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Santa Cruz Spain&quot;,&#10;        &quot;lat&quot;: 28.48952,&#10;        &quot;lng&quot;: -16.31807&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Indaial Brazil&quot;,&#10;        &quot;lat&quot;: -26.89304,&#10;        &quot;lng&quot;: -49.22998&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Izmir Turkey&quot;,&#10;        &quot;lat&quot;: 38.46297,&#10;        &quot;lng&quot;: 27.21787&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Antalya Turkey&quot;,&#10;        &quot;lat&quot;: 36.87944,&#10;        &quot;lng&quot;: 30.709&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Canary Islands&quot;,&#10;        &quot;lat&quot;: 28.1289,&#10;        &quot;lng&quot;: -15.4339&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Alcatraz Island&quot;,&#10;        &quot;lat&quot;: 37.82658,&#10;        &quot;lng&quot;: -122.42296&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Bornova Buyuk Park Turkey&quot;,&#10;        &quot;lat&quot;: 38.46314,&#10;        &quot;lng&quot;: 27.21649&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Bryant Park&quot;,&#10;        &quot;lat&quot;: 40.7536,&#10;        &quot;lng&quot;: -73.9832&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Budapest&quot;,&#10;        &quot;lat&quot;: 47.52876,&#10;        &quot;lng&quot;: 19.05138&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Busan&quot;,&#10;        &quot;lat&quot;: 35.15621,&#10;        &quot;lng&quot;: 129.05732&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Ceasers Palace&quot;,&#10;        &quot;lat&quot;: 36.116,&#10;        &quot;lng&quot;: -115.17422&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyland&quot;,&#10;        &quot;lat&quot;: 33.81195,&#10;        &quot;lng&quot;: -117.91907&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Central Park&quot;,&#10;        &quot;lat&quot;: 40.77042,&#10;        &quot;lng&quot;: -73.97464&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Dallas&quot;,&#10;        &quot;lat&quot;: 32.7759,&#10;        &quot;lng&quot;: -96.79678&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyworld FL&quot;,&#10;        &quot;lat&quot;: 28.41597,&#10;        &quot;lng&quot;: -81.58093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Greece&quot;,&#10;        &quot;lat&quot;: 40.62773,&#10;        &quot;lng&quot;: 22.95471&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Hong Kong&quot;,&#10;        &quot;lat&quot;: 22.31905,&#10;        &quot;lng&quot;: 114.17212&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Honolulu&quot;,&#10;        &quot;lat&quot;: 21.29836,&#10;        &quot;lng&quot;: -157.86011&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Korea&quot;,&#10;        &quot;lat&quot;: 37.56792,&#10;        &quot;lng&quot;: 126.98776&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Las Vegas&quot;,&#10;        &quot;lat&quot;: 36.11207,&#10;        &quot;lng&quot;: -115.1719&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;London&quot;,&#10;        &quot;lat&quot;: 51.51008,&#10;        &quot;lng&quot;: -0.12385&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Melbourne&quot;,&#10;        &quot;lat&quot;: -37.81751,&#10;        &quot;lng&quot;: 144.9633&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;MonteCarlo&quot;,&#10;        &quot;lat&quot;: 36.10447,&#10;        &quot;lng&quot;: -115.17458&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;New York&quot;,&#10;        &quot;lat&quot;: 40.75593,&#10;        &quot;lng&quot;: -73.98461&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;NianticHQ&quot;,&#10;        &quot;lat&quot;: 37.78946,&#10;        &quot;lng&quot;: -122.40162&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Osaka&quot;,&#10;        &quot;lat&quot;: 34.70246,&#10;        &quot;lng&quot;: 135.50024&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Peru&quot;,&#10;        &quot;lat&quot;: -11.56302,&#10;        &quot;lng&quot;: -77.27028&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Pier 39&quot;,&#10;        &quot;lat&quot;: 37.80867,&#10;        &quot;lng&quot;: -122.40982&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Royal Botanical Gardens&quot;,&#10;        &quot;lat&quot;: -33.8642,&#10;        &quot;lng&quot;: 151.2178&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Santa Monica&quot;,&#10;        &quot;lat&quot;: 34.00903,&#10;        &quot;lng&quot;: -118.49728&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Shinjuku Tokyo&quot;,&#10;        &quot;lat&quot;: 35.68902,&#10;        &quot;lng&quot;: 139.70122&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Singapore&quot;,&#10;        &quot;lat&quot;: 1.28872,&#10;        &quot;lng&quot;: 103.84874&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Sydney&quot;,&#10;        &quot;lat&quot;: -33.86882,&#10;        &quot;lng&quot;: 151.2093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Times Square&quot;,&#10;        &quot;lat&quot;: 40.7589,&#10;        &quot;lng&quot;: -73.9851&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Disneyland Japan&quot;,&#10;        &quot;lat&quot;: 35.63121,&#10;        &quot;lng&quot;: 139.88093&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Ueno Onshi Tokyo&quot;,&#10;        &quot;lat&quot;: 35.71238,&#10;        &quot;lng&quot;: 139.77247&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;UnionSquare&quot;,&#10;        &quot;lat&quot;: 37.78799,&#10;        &quot;lng&quot;: -122.40744&#10;    },&#10;    {&#10;        &quot;name&quot;: &quot;Zaragoza&quot;,&#10;        &quot;lat&quot;: 41.66134,&#10;        &quot;lng&quot;: -0.89283&#10;    }&#10;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>