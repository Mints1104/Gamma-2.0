package com.mints.projectgammatwo.viewmodelsimport android.app.Applicationimport android.content.Contextimport android.util.Logimport androidx.lifecycle.AndroidViewModelimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.viewModelScopeimport com.google.gson.Gsonimport com.google.gson.JsonSyntaxExceptionimport com.mints.projectgammatwo.data.ApiClientimport com.mints.projectgammatwo.data.DataSourcePreferencesimport com.mints.projectgammatwo.data.QuestFilterPreferencesimport com.mints.projectgammatwo.data.VisitedQuestsPreferencesimport com.mints.projectgammatwo.data.Questsimport com.mints.projectgammatwo.data.Quests.Questimport com.mints.projectgammatwo.data.QuestsApiServiceimport kotlinx.coroutines.CancellationExceptionimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.asyncimport kotlinx.coroutines.launchimport okhttp3.OkHttpClientimport okhttp3.logging.HttpLoggingInterceptorimport retrofit2.Retrofitimport retrofit2.converter.gson.GsonConverterFactoryimport kotlin.math.atan2import kotlin.math.cosimport kotlin.math.powimport kotlin.math.sinimport kotlin.math.sqrtimport com.mints.projectgammatwo.data.CurrentQuestDataimport okio.IOExceptionimport retrofit2.HttpExceptionimport java.util.concurrent.TimeUnitimport androidx.core.content.editimport kotlinx.coroutines.withContextimport com.mints.projectgammatwo.Rclass QuestsViewModel(application: Application) : AndroidViewModel(application) {    private val _questsLiveData = MutableLiveData<List<Quest>>()    val questsLiveData: LiveData<List<Quest>> = _questsLiveData    private val _questsCountLiveData = MutableLiveData<Int>()    val questsCountLiveData: LiveData<Int> = _questsCountLiveData    private val _filterSizeLiveData = MutableLiveData<Int>()    val filterSizeLiveData: LiveData<Int> = _filterSizeLiveData    // Map of "type,0,id" -> list of SubVariant(filterString, label, condition, type, id, amount, reward)    // e.g. "9,0,483" -> [SubVariant("9,1,483","× 1 — Spin 14 stops", ...), SubVariant("9,3,483","× 3 — Win a raid", ...)]    data class SubVariant(        val filterString: String,        val label: String,        val condition: String,        val type: String,        val id: String,        val amount: String,        val reward: String    )    private val _rewardSubVariantsLiveData = MutableLiveData<Map<String, List<SubVariant>>>()    val rewardSubVariantsLiveData: LiveData<Map<String, List<SubVariant>>> = _rewardSubVariantsLiveData    private val _variantsLoadingLiveData = MutableLiveData(false)    val variantsLoadingLiveData: LiveData<Boolean> = _variantsLoadingLiveData    companion object {        /** Sub-variant cache is considered stale after 24 hours. */        private const val CACHE_MAX_AGE_MS = 24 * 60 * 60 * 1000L    }    init {        val context = getApplication<Application>().applicationContext        val questPrefs = context.getSharedPreferences("quest_filters", Context.MODE_PRIVATE)        // Run the legacy Spinda key migration on a background thread — questPrefs.all        // reads every key+value from disk and must not block the main thread.        viewModelScope.launch(Dispatchers.IO) {            val legacySpindaKeys = questPrefs.all.keys.filter { key ->                key == "enabled_spinda_forms" || key.startsWith("spinda_")            }            if (legacySpindaKeys.isNotEmpty()) {                questPrefs.edit {                    legacySpindaKeys.forEach { remove(it) }                }                Log.d("QuestsViewModel", "Migrated: removed ${legacySpindaKeys.size} legacy Spinda keys")            }            // Also scrub any spinda_form_* values that leaked into enabled_encounter_conditions.            val encounterConditions = questPrefs.getStringSet("enabled_encounter_conditions", emptySet())!!            val cleanedConditions = encounterConditions.filterNot { it.startsWith("spinda_form_") }.toSet()            if (cleanedConditions.size != encounterConditions.size) {                questPrefs.edit { putStringSet("enabled_encounter_conditions", cleanedConditions) }                Log.d("QuestsViewModel", "Migrated: removed ${encounterConditions.size - cleanedConditions.size} spinda_form_ values from encounter conditions")            }        }        // Restore cached sub-variants synchronously on the main thread so the filter UI        // is populated immediately on app restart. SharedPreferences caches all values        // in memory after the first file load, so individual key reads are fast.        val cacheTimestamp = questPrefs.getLong("quest_sub_variants_timestamp", 0L)        val cacheAge = System.currentTimeMillis() - cacheTimestamp        val cached = if (cacheAge < CACHE_MAX_AGE_MS) {            questPrefs.getString("quest_sub_variants", null)        } else {            Log.d("QuestsViewModel", "Sub-variant cache is stale (${cacheAge / 3600000}h old), discarding")            null        }        if (!cached.isNullOrEmpty()) {            try {                val type = object : com.google.gson.reflect.TypeToken<Map<String, List<SubVariant>>>() {}.type                val map: Map<String, List<SubVariant>> = Gson().fromJson(cached, type)                if (map.isNotEmpty()) _rewardSubVariantsLiveData.value = map            } catch (e: Exception) {                Log.w("QuestsViewModel", "Failed to restore cached sub-variants", e)            }        }    }    private fun buildConditionKey(type: String, id: String, amount: String, condition: String, reward: String): String {        return "$type|$id|$amount|$condition|$reward"    }    private fun buildLegacyConditionKey(type: String, id: String, amount: String, condition: String): String {        return "$type|$id|$amount|$condition"    }    private fun parseFilterPrefix(filterStr: String): Pair<String, String>? {        val parts = filterStr.split(",")        if (parts.size < 3) return null        val type = parts[0]        val id = if (type == "3") parts[1] else parts[2]        return type to id    }    private fun buildFullFilterList(filters: Quests.Filters): List<String> {        val list = mutableListOf<String>()        filters.t3.forEach { list.add("3,$it,0") }        filters.t4.forEach { list.add("4,0,$it") }        (filters.t9 ?: emptyList()).forEach { list.add("9,0,$it") }        filters.t12.forEach { list.add("12,0,$it") }        filters.t7.forEach { list.add("7,0,$it") }        filters.t2.forEach { list.add("2,0,$it") }        return list    }    private val _error = MutableLiveData<String>()    val error: LiveData<String> get() = _error    // Single OkHttpClient reused for all requests    private val httpClient: OkHttpClient by lazy {        val interceptor = HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.NONE }        OkHttpClient.Builder()            .addInterceptor(interceptor)            .connectTimeout(30, TimeUnit.SECONDS)            .readTimeout(30, TimeUnit.SECONDS)            .writeTimeout(30, TimeUnit.SECONDS)            .build()    }    // Cache QuestsApiService per base URL    private val serviceCache = mutableMapOf<String, QuestsApiService>()    // Cache for last visited coordinates to avoid repeated SharedPreferences reads    private var cachedLastVisitedCoords: Pair<Double?, Double?>? = null    private fun getServiceForBase(baseUrl: String): QuestsApiService {        return serviceCache.getOrPut(baseUrl) {            Retrofit.Builder()                .baseUrl(baseUrl)                .addConverterFactory(GsonConverterFactory.create())                .client(httpClient)                .build()                .create(QuestsApiService::class.java)        }    }    // Calculate the distance between two quests using the Haversine formula.    private fun haversineDistance(a: Quest, b: Quest): Double {        val R = 6371e3 // Earth's radius in meters        val lat1 = Math.toRadians(a.lat)        val lat2 = Math.toRadians(b.lat)        val deltaLat = Math.toRadians(b.lat - a.lat)        val deltaLon = Math.toRadians(b.lng - a.lng)        val aVal = sin(deltaLat / 2).pow(2.0) +                cos(lat1) * cos(lat2) *                sin(deltaLon / 2).pow(2.0)        val c = 2 * atan2(sqrt(aVal), sqrt(1 - aVal))        return R * c    }    // Calculate the distance from a given point (lat, lng) to a quest.    private fun haversineDistanceFromPoint(lat: Double, lng: Double, quest: Quest): Double {        val R = 6371e3 // Earth's radius in meters        val lat1 = Math.toRadians(lat)        val lat2 = Math.toRadians(quest.lat)        val deltaLat = Math.toRadians(quest.lat - lat)        val deltaLon = Math.toRadians(quest.lng - lng)        val aVal = sin(deltaLat / 2).pow(2.0) +                cos(lat1) * cos(lat2) * sin(deltaLon / 2).pow(2.0)        val c = 2 * atan2(sqrt(aVal), sqrt(1 - aVal))        return R * c    }    // Sort the list of quests by repeatedly choosing the nearest unvisited quest.    // If startLat and startLng are provided, use them as the reference point.    private fun sortQuestsByNearestNeighbor(        quests: List<Quest>,        startLat: Double? = null,        startLng: Double? = null    ): List<Quest> {        if (quests.isEmpty()) return quests        val sorted = mutableListOf<Quest>()        val remaining = quests.toMutableList()        // Determine the starting quest using the provided coordinates if available.        val startingQuest = if (startLat != null && startLng != null) {            remaining.minByOrNull { quest ->                haversineDistanceFromPoint(startLat, startLng, quest)            } ?: remaining.first()        } else {            remaining.first()        }        sorted.add(startingQuest)        remaining.remove(startingQuest)        var current = startingQuest        while (remaining.isNotEmpty()) {            val next = remaining.minByOrNull { haversineDistance(current, it) }!!            sorted.add(next)            remaining.remove(next)            current = next        }        return sorted    }    // Pick nearest N quests to a given point to reduce sort workload    private fun nearestNByPoint(quests: List<Quest>, lat: Double, lng: Double, n: Int): List<Quest> {        if (quests.size <= n) return quests        return quests            .asSequence()            .map { it to haversineDistanceFromPoint(lat, lng, it) }            .sortedBy { it.second }            .take(n)            .map { it.first }            .toList()    }    // Save the coordinates of the last visited quest. Store as string for precision; fallback compatible when reading.    fun saveLastVisitedCoordinates(quest: Quest) {        viewModelScope.launch {            withContext(Dispatchers.IO) {                val context = getApplication<Application>().applicationContext                val prefs = context.getSharedPreferences("last_visited_pref", Context.MODE_PRIVATE)                prefs.edit().apply {                    putString("lastVisited", "${quest.lat},${quest.lng}")                    // Keep old keys for backward compatibility                    putFloat("lastVisitedLat", quest.lat.toFloat())                    putFloat("lastVisitedLng", quest.lng.toFloat())                    apply()                }            }            // Update cache immediately            cachedLastVisitedCoords = quest.lat to quest.lng        }    }    // Load last visited coordinates from cache or SharedPreferences    private fun loadLastVisitedCoordinates(): Pair<Double?, Double?> {        // Return cached value if available        cachedLastVisitedCoords?.let { return it }        // Otherwise load from SharedPreferences        val context = getApplication<Application>().applicationContext        val prefs = context.getSharedPreferences("last_visited_pref", Context.MODE_PRIVATE)        val lastCombined = prefs.getString("lastVisited", null)        val result = if (!lastCombined.isNullOrEmpty() && "," in lastCombined) {            val parts = lastCombined.split(",")            parts.getOrNull(0)?.toDoubleOrNull() to parts.getOrNull(1)?.toDoubleOrNull()        } else {            val latF = prefs.getFloat("lastVisitedLat", Float.NaN)            val lngF = prefs.getFloat("lastVisitedLng", Float.NaN)            val lat = if (!latF.isNaN()) latF.toDouble() else null            val lng = if (!lngF.isNaN()) lngF.toDouble() else null            lat to lng        }        // Cache the result        cachedLastVisitedCoords = result        return result    }    fun fetchQuests() {        Log.d("QuestsViewModel", "Starting fetchQuests()")        val context = getApplication<Application>().applicationContext        val filterPreferences = QuestFilterPreferences(context)        val visitedPreferences = VisitedQuestsPreferences(context)        val dataSourcePreferences = DataSourcePreferences(context)        val enabledFilters = filterPreferences.getEnabledFilters()        val filtersToUse = if (enabledFilters.isEmpty()) emptyList() else enabledFilters.toList()        Log.d("QuestsViewModel","Filters enabled: $filtersToUse")        _filterSizeLiveData.postValue(filtersToUse.size)        // The API expects base filter keys ("4,0,483", "9,0,1006", "3,200,0", "7,0,483")        // not variant-specific strings ("4,1,483"). Convert variant filter strings to their        // canonical API form so the server returns results. The variant-specific strings are        // only used for local post-fetch filtering inside this function.        val apiFiltersToUse = filtersToUse.map { filter ->            val parts = filter.split(",")            if (parts.size < 3) return@map filter            val type = parts[0]            val last = parts[2]            when (type) {                // Stardust: "3,<amount>,0" — amount is the meaningful discriminator; keep as-is                "3"  -> filter                // Encounter: "7,0,<id>" — already base form                "7"  -> filter                // Candy, XL Candy, Mega Energy, Item: "T,<amt>,<id>" → "T,0,<id>"                "4"  -> "4,0,$last"                "9"  -> "9,0,$last"                "12" -> "12,0,$last"                "2"  -> "2,0,$last"                else -> filter            }        }.distinct()        val selectedSources = dataSourcePreferences.getSelectedSources()        // Load last visited coordinates using cached helper        val (startLat, startLng) = loadLastVisitedCoordinates()        viewModelScope.launch {            try {                Log.d("QuestsViewModel", "Selected data sources: $selectedSources")                val deferredList = selectedSources.mapNotNull { source ->                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl ->                        async(Dispatchers.IO) {                            try {                                val service = getServiceForBase(baseUrl)                                val response = if (apiFiltersToUse.isEmpty()) {                                    service.getAllQuests(System.currentTimeMillis()).execute()                                } else {                                    service.getQuests(apiFiltersToUse, System.currentTimeMillis()).execute()                                }                                if (response.isSuccessful) {                                    Log.d("QuestsViewModel", "API call successful for source $source")                                    Pair(source, Result.success(response))                                } else {                                    val errorMsg = "HTTP ${response.code()}: ${response.message()}"                                    Log.w("QuestsViewModel", "API error for source $source: $errorMsg")                                    Pair(source, Result.failure<retrofit2.Response<Quests.QuestsResponse>>(                                        HttpException(response)                                    ))                                }                            } catch (e: IOException) {                                Log.e("QuestsViewModel", "Network error for source $source", e)                                Pair(source, Result.failure<retrofit2.Response<Quests.QuestsResponse>>(                                    IOException("Network error for source $source", e)                                ))                            } catch (e: HttpException) {                                Log.e("QuestsViewModel", "HTTP error for source $source: ${e.code()}", e)                                Pair(source, Result.failure<retrofit2.Response<Quests.QuestsResponse>>(                                    e                                ))                            } catch (e: JsonSyntaxException) {                                Log.e("QuestsViewModel", "JSON parsing error for source $source", e)                                Pair(source, Result.failure<retrofit2.Response<Quests.QuestsResponse>>(                                    IOException("JSON parsing error for source $source", e)                                ))                            } catch (e: Exception) {                                Log.e("QuestsViewModel", "Unexpected error for source $source", e)                                Pair(source, Result.failure<retrofit2.Response<Quests.QuestsResponse>>(                                    Exception("Unexpected error for source $source", e)                                ))                            }                        }                    }                }                val responses = deferredList.map { it.await() }                val successfulResponses = responses.mapNotNull { (source, result) ->                    result.getOrNull()?.let { response ->                        Pair(source, response)                    }                }                if (successfulResponses.isEmpty()) {                    Log.w("QuestsViewModel", "No successful API responses received")                    _questsLiveData.postValue(emptyList())                    _error.postValue(getApplication<Application>().getString(R.string.quests_error_unable_fetch))                    return@launch                }                Log.d("QuestsViewModel", "Successfully fetched quests from ${successfulResponses.size} sources")                // Write the refresh timestamp now — we have confirmed a live network response.                // This is done eagerly so the UI always shows the correct "last refreshed" time                // even if sub-variant discovery later finds nothing new.                val fetchTimestamp = System.currentTimeMillis()                withContext(Dispatchers.IO) {                    context.getSharedPreferences("quest_filters", Context.MODE_PRIVATE)                        .edit { putLong("filters_last_refreshed", fetchTimestamp) }                }                // Fetch unfiltered quests for variant discovery to avoid filter-dependent gaps                _variantsLoadingLiveData.postValue(true)                val variantDeferredList = selectedSources.mapNotNull { source ->                    ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl ->                        async(Dispatchers.IO) {                            try {                                val service = getServiceForBase(baseUrl)                                service.getAllQuests(System.currentTimeMillis()).execute()                            } catch (e: Exception) {                                Log.w("QuestsViewModel", "Variant fetch failed for source $source", e)                                null                            }                        }                    }                }                val variantResponses = variantDeferredList.mapNotNull { it.await() }                val variantBodies = variantResponses                    .filter { it.isSuccessful }                    .mapNotNull { it.body() }                // Save filters to SharedPreferences from unfiltered response if available                variantBodies.firstOrNull()?.filters?.let { filters ->                    withContext(Dispatchers.IO) {                        val filtersJson = Gson().toJson(filters)                        context.getSharedPreferences("quest_filters", Context.MODE_PRIVATE)                            .edit { putString("quest_api_filters", filtersJson) }                    }                }                val cachedFilters = context.getSharedPreferences("quest_filters", Context.MODE_PRIVATE)                    .getString("quest_api_filters", null)                    ?.let { json -> Gson().fromJson(json, Quests.Filters::class.java) }                val filtersForVariants = variantBodies.firstOrNull()?.filters ?: cachedFilters                val fullFilterList = filtersForVariants?.let { buildFullFilterList(it) }.orEmpty()                // If the unfiltered endpoint returns no quests, expand the filter list in chunks.                val variantQuests = if (fullFilterList.isNotEmpty()) {                    val chunks = fullFilterList.chunked(80)                    val variantQuestDeferredList = selectedSources.mapNotNull { source ->                        ApiClient.DATA_SOURCE_URLS[source]?.let { baseUrl ->                            async(Dispatchers.IO) {                                val service = getServiceForBase(baseUrl)                                val all = mutableListOf<Quest>()                                for (chunk in chunks) {                                    try {                                        val response = service.getQuests(chunk, System.currentTimeMillis()).execute()                                        if (response.isSuccessful) {                                            all.addAll(response.body()?.quests ?: emptyList())                                        } else {                                            Log.w("QuestsViewModel", "Variant chunk fetch failed: HTTP ${response.code()}")                                        }                                    } catch (e: Exception) {                                        Log.w("QuestsViewModel", "Variant chunk fetch failed", e)                                    }                                }                                all                            }                        }                    }                    variantQuestDeferredList.flatMap { it.await() }                } else {                    emptyList()                }                val allQuestsForVariants = when {                    variantQuests.isNotEmpty() -> variantQuests                    variantBodies.isNotEmpty() -> variantBodies.flatMap { it.quests }                    else -> successfulResponses.flatMap { (_, response) -> response.body()?.quests ?: emptyList() }                }                // Build sub-variant map: keep same-amount variants distinct by reward label + condition                val subVariantMap = mutableMapOf<String, MutableList<SubVariant>>()                for (quest in allQuestsForVariants) {                    val types = quest.rewardsTypes.split(",").map { it.trim() }                    val ids   = quest.rewardsIds.split(",").map { it.trim() }                    val amts  = quest.rewardsAmounts.split(",").map { it.trim() }                    val condition = quest.conditionsString.trim()                    val rewardLabel = quest.rewardsString.trim()                    types.indices.forEach { i ->                        val type = types.getOrNull(i) ?: return@forEach                        val id   = ids.getOrNull(i)   ?: return@forEach                        val amt  = amts.getOrNull(i)  ?: return@forEach                        if (id.isBlank() || amt.isBlank() || type.isBlank()) return@forEach                        val (baseKey, filterStr, label) = when (type) {                            "3"  -> Triple("3,$id,0",    "3,$amt,0",    "$rewardLabel — $condition")                            "2"  -> Triple("2,0,$id",    "2,$amt,$id",  "$rewardLabel — $condition")                            "4"  -> Triple("4,0,$id",    "4,$amt,$id",  "$rewardLabel — $condition")                            "7"  -> Triple("7,0,$id",    "7,0,$id",     "$rewardLabel — $condition")                            "9"  -> Triple("9,0,$id",    "9,$amt,$id",  "$rewardLabel — $condition")                            "12" -> Triple("12,0,$id",   "12,$amt,$id", "$rewardLabel — $condition")                            else -> Triple("$type,0,$id","$type,$amt,$id","$rewardLabel — $condition")                        }                        val list = subVariantMap.getOrPut(baseKey) { mutableListOf() }                        val conditionKey = buildConditionKey(type, id, amt, condition, rewardLabel)                        val isDuplicate = list.any {                            buildConditionKey(it.type, it.id, it.amount, it.condition, it.reward) == conditionKey                        }                        if (!isDuplicate) {                            list.add(SubVariant(filterStr, label, condition, type, id, amt, rewardLabel))                        }                    }                }                subVariantMap.forEach { (key, list) ->                    if (key.startsWith("7,")) {                        list.sortBy { it.label }                    } else {                        list.sortBy { it.filterString.split(",").getOrNull(1)?.toIntOrNull() ?: 0 }                    }                }                if (subVariantMap.isNotEmpty()) {                    _rewardSubVariantsLiveData.postValue(subVariantMap)                    // Persist so the filter UI is populated immediately on the next app launch.                    withContext(Dispatchers.IO) {                        val json = Gson().toJson(subVariantMap)                        context.getSharedPreferences("quest_filters", Context.MODE_PRIVATE)                            .edit {                                putString("quest_sub_variants", json)                                putLong("quest_sub_variants_timestamp", fetchTimestamp)                            }                    }                }                _variantsLoadingLiveData.postValue(false)                // Perform CPU-intensive filtering and sorting on background thread                val sortedQuests = withContext(Dispatchers.Default) {                    val allQuests = successfulResponses.flatMap { (source, response) ->                        response.body()?.quests?.map { quest ->                            quest.copy(source = source)                        } ?: emptyList()                    }                    Log.d("QuestsViewModel", "Total quests fetched: ${allQuests.size}")                    val visited = visitedPreferences.getVisitedQuests()                    var filteredQuests = allQuests.filter { quest ->                        val id = "${quest.name}|${quest.lat}|${quest.lng}"                        !visited.contains(id)                    }                    Log.d("QuestsViewModel", "Filtered quests after removing visited: ${filteredQuests.size}")                    val enabledConditions = filterPreferences.getEnabledEncounterConditions()                    if (enabledConditions.isNotEmpty() && filtersToUse.isNotEmpty()) {                        val enabledPrefixes = filtersToUse.mapNotNull { parseFilterPrefix(it) }.toSet()                        val prefixesWithConditions = enabledConditions.mapNotNull { key ->                            val parts = key.split("|")                            if (parts.size < 2) null else Pair(parts[0], parts[1])                        }.toSet()                        filteredQuests = filteredQuests.filter { quest ->                            val types = quest.rewardsTypes.split(",").map { it.trim() }                            val ids = quest.rewardsIds.split(",").map { it.trim() }                            val amts = quest.rewardsAmounts.split(",").map { it.trim() }                            val condition = quest.conditionsString.trim()                            val rewardLabel = quest.rewardsString.trim()                            types.indices.any { i ->                                val type = types.getOrNull(i) ?: return@any false                                val id = ids.getOrNull(i) ?: return@any false                                val amt = amts.getOrNull(i) ?: return@any false                                val prefix = type to id                                if (!enabledPrefixes.contains(prefix)) return@any false                                if (prefixesWithConditions.contains(prefix)) {                                    val key = buildConditionKey(type, id, amt, condition, rewardLabel)                                    val legacyKey = buildLegacyConditionKey(type, id, amt, condition)                                    enabledConditions.contains(key) || enabledConditions.contains(legacyKey)                                } else {                                    true                                }                            }                        }                        Log.d("QuestsViewModel", "Filtered quests after condition filtering: ${filteredQuests.size}")                    }                    // Pre-limit by proximity to last visited when available to reduce sorting cost                    filteredQuests = if (startLat != null && startLng != null) {                        nearestNByPoint(filteredQuests, startLat, startLng, 500)                    } else {                        filteredQuests.take(500)                    }                    // Sort the filtered quests using the last visited coordinates                    sortQuestsByNearestNeighbor(filteredQuests, startLat, startLng)                }                _questsCountLiveData.postValue(sortedQuests.size)                _questsLiveData.postValue(sortedQuests)                CurrentQuestData.currentQuests = sortedQuests.toMutableList()            } catch (e: CancellationException) {                // Coroutine was cancelled - this is normal behavior, don't treat it as an error                Log.d("QuestsViewModel", "Fetch quests was cancelled")                throw e // Re-throw to properly propagate cancellation            } catch (e: Exception) {                Log.e("QuestsViewModel", "Error in fetchQuests", e)                _questsLiveData.postValue(emptyList())                _error.postValue(getApplication<Application>().getString(R.string.quests_error_unexpected))            } finally {                _variantsLoadingLiveData.postValue(false)            }        }    }}